<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>恶心心JavaScript系列：节流和防抖</title>
    <url>/js-debouncing-throttling.html</url>
    <content><![CDATA[<div class="note primary">
            <p>Reduce event trigger rate by throttling &amp; debouncing</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>节流和防抖都是为了解决一个问题——事件的触发率。事件的触发率，顾名思义就是单位时间内你的回调函数被调用的次数。这篇文章总结一下节流和防抖的使用场景和两者的定义与区别。</p>
<h2 id="事件的触发率"><a href="#事件的触发率" class="headerlink" title="事件的触发率"></a>事件的触发率</h2><p>什么时候关注事件的触发率呢？</p>
<ul>
<li>点击一个按钮的时候？这个时候触发率有多高？就算你点击的很快那也是比较小的，不够明显。</li>
<li>在输入框内迅速的打字，输入框的改变事件触发率高吗？这个是比较明显的，最常见的一个例子就是在搜索引擎内输入时的自动提示。</li>
<li>最明显的是什么事件？什么事件的触发率会很高？比如说<code>scroll</code>和<code>mousemove</code>事件触发率会非常高！</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>如果你关注的某个事件的触发率比较高，那么你应该需要注意这个事件的回调函数。</p>
<p>如果你的回调函数内几乎没做什么事，没有很大的计算，没有涉及很慢的操作（下面会说有哪些操作），那么你可以酌情忽略。</p>
<p>如果某个事件的触发率比较高并且其事件回调函数内涉及如下操作，那么你就<strong>需要考虑回流或者防抖</strong>了。</p>
<p>比如说：</p>
<ul>
<li>XHR网络请求</li>
<li>引起浏览器的回流或者重绘</li>
<li>计算大量数据</li>
<li>…</li>
</ul>
<div class="note success">
            <p>节流和防抖就是为了减少事件的触发率来节省资源。这两种方式实际上就是在响应用户动作和最佳资源使用上的一个折中。</p>
          </div>
<h2 id="节流（throttling）"><a href="#节流（throttling）" class="headerlink" title="节流（throttling）"></a>节流（throttling）</h2><p>节流，顾名思义就是限制流速，可以给定一个事件触发率的一个上限值，让频繁的事件触发变的稍慢一些。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>当然这个上限值可以通过多种方式来实现：</p>
<ul>
<li>通过每隔多少时间触发一次来设置</li>
<li>通过每隔多少次触发当做一次触发来设置</li>
<li>通过某个时间段内只能触发几次来设置</li>
</ul>
<p>重构项目时为了避免重写大量回调函数，我们可以封装一个wrapper函数，这个函数返回一个新的代理函数，原来的回调函数不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">delay,fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastInvoke=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> now=<span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now-lastInvoke&lt;delay) <span class="keyword">return</span>;</span><br><span class="line">        lastInvoke=now;</span><br><span class="line">        <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个封装实际上就是用到了闭包来保存上次事件成功触发的时间。<br>你可以通过如下方式使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的回调函数</span></span><br><span class="line"><span class="keyword">const</span> myHandler=<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do sth.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新生成的代理函数</span></span><br><span class="line"><span class="keyword">const</span> tHandler=throttled(<span class="number">200</span>,myHandler);</span><br><span class="line">domNode.addEventListener(<span class="string">'mousemove'</span>,tHandler);</span><br></pre></td></tr></table></figure>
<p>这样事件实际触发的上限值是200ms触发一次，两次触发之间的所有无效触发都被忽略。<br>当然这个<code>delay</code>所设置的时间需要有各种考虑，需要平衡网页的响应时间和流畅程度。<strong>节流对于CSS的<code>transition</code>比较有效。</strong></p>
<h3 id="节流的应用场景"><a href="#节流的应用场景" class="headerlink" title="节流的应用场景"></a>节流的应用场景</h3><p>需要追踪用户的动作，但是因为事件回调的负担，不能高频率触发事件。比如追踪<code>scroll</code>的位置来做出某些响应。</p>
<h2 id="防抖（debouncing）"><a href="#防抖（debouncing）" class="headerlink" title="防抖（debouncing）"></a>防抖（debouncing）</h2><p>防抖，亦可顾名思义，就是防止抖动，把原来的一些列抖动当做一次平移。也就是说将一系列连续的事件触发结束后的一段时间内没有再触发，那么就真正的触发一次。再生动形象一点，就是等风平浪静之后只触发一次事件。</p>
<h3 id="防抖的实现"><a href="#防抖的实现" class="headerlink" title="防抖的实现"></a>防抖的实现</h3><p>防抖可以通过JS的计时器<code>setTimeout()</code>和<code>clearTimeout()</code>来实现。</p>
<p>和节流的实现方式类似，我们用一个wrapper函数来创建一个代理函数，原来未防抖的回调函数不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">delay,fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeId=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timeId)&#123;</span><br><span class="line">            clearTimeout(timeId);</span><br><span class="line">        &#125;</span><br><span class="line">        timeId=setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">            timeId=<span class="literal">null</span>;</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式和节流创建函数类似，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myHandler=<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do sth.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> dHandler=debounced(<span class="number">200</span>,myHandler);</span><br><span class="line">domNode.addEventListener(<span class="string">'input'</span>,dHandler);</span><br></pre></td></tr></table></figure>
<h3 id="防抖的应用场景"><a href="#防抖的应用场景" class="headerlink" title="防抖的应用场景"></a>防抖的应用场景</h3><p>防抖主要应用于那些不必时时刻刻追踪用户动作的事件触发。比如最常见的例子，Baidu搜索中用户输入的自动提示（假设不保存在本地，而需要XHR请求），你可以设置用户停止输入200ms后触发一次事件，如果两次用户输入小于200ms则不会触发并且需要重新计时。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些常见的节流和防抖的工具函数在一些常见的工具库中就能够找到，比如说<span class="exturl" data-url="aHR0cHM6Ly9sb2Rhc2guY29tLw==" title="https://lodash.com/">lodash<i class="fa fa-external-link"></i></span>，其中就有<span class="exturl" data-url="aHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvNC4xNy4xNSN0aHJvdHRsZQ==" title="https://lodash.com/docs/4.17.15#throttle">throttle<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvNC4xNy4xNSNkZWJvdW5jZQ==" title="https://lodash.com/docs/4.17.15#debounce">debounce<i class="fa fa-external-link"></i></span>函数。</p>
<ul>
<li>节流就是直接限制触发频率，或指定多长时间触发一次，或指定时间段内触发几次，或多次触发当做一次触发</li>
<li>防抖是等风平浪静时再响应触发，风平浪静指的是时间触发后x毫秒后未再次触发。</li>
<li>节流和防抖无法解决所有的问题，比如恶心冗杂的代码。因此在想用节流防抖来优化降低事件触发率之前先做好其他优化。</li>
<li>节流和防抖对于一些场景下的高频事件触发并不适用，比如说某些滑动组件如果使用节流那就会出bug，用户也就感觉恶心心。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlYnVyc3QuaW8vdGhyb3R0bGluZy1hbmQtZGVib3VuY2luZy1pbi1qYXZhc2NyaXB0LTY0NmQwNzZkMGE0NA==" title="https://codeburst.io/throttling-and-debouncing-in-javascript-646d076d0a44">Throttling and debouncing in JavaScript<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>恶心心JavaScript系列：对象设置不变性</title>
    <url>/js-dont-know-const.html</url>
    <content><![CDATA[<div class="note primary">
            <p>如何让JS中的对象不变。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在其他语言比如Java中你可以设置对象为常量，对象属性为常量，通过使用<code>final</code>关键字。在JS中你可能知道使用<code>const</code>关键字，但是对于一个对象用<code>const</code>关键字描述结果是什么？只是将变量所保存的引用索引无法改变了而已，对象内部还是可以改变的。</p>
<p>今天我们就来总结一下有哪些方法可以让一个对象保持不变性。</p>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>目前为止，你可能只知道通过<code>const</code>来设置一个变量为常量，但是对象如何设置为常量？通过<code>const</code>修饰只能保证其“值不变性”，如何保证其“引用目标内容不变性”？这就是我们要讨论的话题。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code>只是修饰的变量本身，如果该变量是个值类型，那么这个值不可改变；如果该变量是个引用类型，则该变量无法再引用其他引用类型，也就是引用对象目标不可变，但是对象内部可以改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line">a=<span class="number">2</span>;<span class="comment">//不可改：Uncaught TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>);<span class="comment">//可改，看下一行的打印</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2,3,4]</span></span><br><span class="line">arr=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];<span class="comment">//不可改：Uncaught TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj=&#123;&#125;;</span><br><span class="line">obj.m=<span class="number">1</span>;<span class="comment">//可改，看下一行打印</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123;m:1&#125;</span></span><br><span class="line">obj=&#123;&#125;;<span class="comment">//不可改：Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>如果想让一个对象属性变为真正的常量，可以通过描述符的方式，使其<strong>不可修改、不可重定义或删除</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'m'</span>,&#123;</span><br><span class="line">    value:<span class="number">1</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span>;</span><br><span class="line">    enumerable:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.m=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.m);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h3 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h3><p>通过<code>Object.preventExtensions()</code>方法可以禁止一个对象添加新属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.b=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h3><p>通过<code>Object.seal()</code>方法可以“密封”一个对象，相当于先调用<code>Object.preventExtensions()</code>，再将所有现有属性改为<code>configurable:false</code>。原来是<code>writable:true</code>的仍可修改。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="keyword">delete</span> obj.a;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h3><p>通过<code>Object.freeze()</code>方法可以“冻结”一个对象，相当于先调用<code>Object.seal()</code>，再将所有属性改为<code>writable:false</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="深不可变性"><a href="#深不可变性" class="headerlink" title="深不可变性"></a>深不可变性</h3><p>深不可变性可以通过DFS或者BFS，递归或者队列设置不可变性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>通过描述符可以设置一个对象属性不可变性</li>
<li>通过<code>Object.preventExtensions</code>设置对象不可添加属性</li>
<li>通过<code>Object.seal</code>设置对象不可添加属性，不可配置已有属性和删除已有属性</li>
<li>通过<code>Object.freeze</code>设置对象所有属性“浅不可变”</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9Zb3UtRG9udC1Lbm93LUpTL2Jsb2IvMm5kLWVkL29iamVjdHMtY2xhc3Nlcy9jaDMubWQ=" title="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch3.md">You Don’t Know JS Yet: Objects &amp; Classes - 2nd Edition-&gt;Chapter 3: Objects<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>恶心心JavaScript系列：原型链属性隐藏规则</title>
    <url>/js-dont-know-property-hidden.html</url>
    <content><![CDATA[<div class="note primary">
            <p>让你误解的JavaScript原型链属性隐藏规则。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript的原型可能是最让你无解的地方，我们总是千方百计地想通过JS来实现继承，但是实际上JS仅仅是对象关联和任务委托罢了。JS中的继承看起来更像兄弟之间的任务委托而不是真正的父子关系。JS中没有构造函数只有构造函数调用。</p>
<p>好了，切入正题。在JS中，你可能认为是这样，你有一个对象<code>myDog</code>，它的原型链上其中一个对象有一个<code>name</code>属性值为<code>Tom</code>，<code>myDog</code>并没有这个属性，现在你通过<code>myDog.name</code>访问结果一定是<code>Tom</code>没错。但是如果你为<code>myDog</code>通过<code>obj.key=value</code>的形式新添加一个<code>name</code>属性，其值为<code>Jone</code>，你可能会回答原型链对象上的属性被屏蔽了。</p>
<p>但其实并不是如此。</p>
<h2 id="屏蔽规则"><a href="#屏蔽规则" class="headerlink" title="屏蔽规则"></a>屏蔽规则</h2><p>这是需要某种规则的，那么这个规则是什么？下面我们一一讨论<code>obj.key=value</code>的三种情况。</p>
<h3 id="原型链某对象上存在对应属性名并且没有标记为只读，那么就会为当前对象添加属性，原型链对象上的属性被屏蔽"><a href="#原型链某对象上存在对应属性名并且没有标记为只读，那么就会为当前对象添加属性，原型链对象上的属性被屏蔽" class="headerlink" title="原型链某对象上存在对应属性名并且没有标记为只读，那么就会为当前对象添加属性，原型链对象上的属性被屏蔽"></a>原型链某对象上存在对应属性名并且没有标记为只读，那么就会为当前对象添加属性，原型链对象上的属性被屏蔽</h3><p>换句话说，原型链某个对象上存在同名属性并且<code>writable:true</code>，那么就会屏蔽。<strong>这就是我们认为应该确实如此的规则</strong></p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Dog.prototype,<span class="string">'name'</span>,&#123;</span><br><span class="line">    value:<span class="string">'Tom'</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    emumerable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> myDog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="built_in">console</span>.log(myDog);<span class="comment">//"Tom"</span></span><br><span class="line">myDog.name=<span class="string">"Jone"</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog);<span class="comment">//"Jone"</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链某对象上存在对应属性名并且标记为只读，那么就会忽略为当前对象添加属性，严格模式下会出错"><a href="#原型链某对象上存在对应属性名并且标记为只读，那么就会忽略为当前对象添加属性，严格模式下会出错" class="headerlink" title="原型链某对象上存在对应属性名并且标记为只读，那么就会忽略为当前对象添加属性，严格模式下会出错"></a>原型链某对象上存在对应属性名并且标记为只读，那么就会忽略为当前对象添加属性，严格模式下会出错</h3><p>话句话说，如果原型链某个对象上存在同名属性且<code>writable:false</code>，那么就忽略添加属性操作，严格模式报错。</p>
<p>还是那个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Dog.prototype,<span class="string">'name'</span>,&#123;</span><br><span class="line">    value:<span class="string">'Tom'</span>,</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    emumerable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> littleDog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="built_in">console</span>.log(littleDog.name);<span class="comment">//"Tom"</span></span><br><span class="line">littleDog.name=<span class="string">"Jone"</span></span><br><span class="line"><span class="built_in">console</span>.log(littleDog.name);<span class="comment">//"Tom"</span></span><br><span class="line">littleDog.hasOwnProperty(<span class="string">'name'</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链某对象上存在对应属性名的setter，那么就会忽略为当前对象添加属性并调用这个setter。"><a href="#原型链某对象上存在对应属性名的setter，那么就会忽略为当前对象添加属性并调用这个setter。" class="headerlink" title="原型链某对象上存在对应属性名的setter，那么就会忽略为当前对象添加属性并调用这个setter。"></a>原型链某对象上存在对应属性名的setter，那么就会忽略为当前对象添加属性并调用这个setter。</h3><p>话句话说，原型链的某个对象上存在同名的setter，当你为当前对象同名属性赋值时会调用这个setter。</p>
<p>如上例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Dog.prototype,<span class="string">'name'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span> ()&#123;<span class="keyword">return</span> <span class="keyword">this</span>._name;&#125;,</span><br><span class="line">    <span class="keyword">set</span> (val)&#123;<span class="keyword">this</span>._name=val&#125;,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    emumerable:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> tinyDog=<span class="keyword">new</span> Dog();</span><br><span class="line">tinyDog.name=<span class="string">"Tom"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(tinyDog.name);<span class="comment">//"Tom"</span></span><br><span class="line">tinyDog.name=<span class="string">"Jone"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(tinyDOg.name);<span class="comment">//"Jone"</span></span><br><span class="line">tinyDog.hasOwnProperty(<span class="string">'name'</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="如何强制屏蔽"><a href="#如何强制屏蔽" class="headerlink" title="如何强制屏蔽"></a>如何强制屏蔽</h2><p>针对后两种情况会导致属性无法屏蔽，要想屏蔽可以使用<code>Object.defineProperty()</code>方法进行创建属性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>obj.key=value</code>进行属性创建的时候，有可能会屏蔽原型链上的属性也有可能不屏蔽，有如下规则：</p>
<ol>
<li>原型链上存在同名数据属性并且可写<code>writable:true</code>，那么就会在<code>obj</code>上创建属性并屏蔽原型链上的属性。</li>
<li>原型链上存在同名数据属性并且不可写<code>writable:false</code>，那么就忽略在<code>obj</code>上创建同名属性动作，严格模式下报错</li>
<li>原型链上存在同名<code>setter</code>函数，那么会调用这个函数。</li>
</ol>
<p>要想强制屏蔽后两种情况，请用<code>Object.defineProperty()</code>方法。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9Zb3UtRG9udC1Lbm93LUpTL2Jsb2IvMm5kLWVkL29iamVjdHMtY2xhc3Nlcy9jaDUubWQ=" title="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch5.md">You Don’t Know JS Yet: Objects &amp; Classes - 2nd Edition-&gt;Chapter 5: Prototypes<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS系列：回流和重绘</title>
    <url>/css-reflow-repaint.html</url>
    <content><![CDATA[<div class="note primary">
            <p>Reflow and Repaint</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>头条面试题，这方面没有深入了解，今天总结一下。</p>
<h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><p><img src="/images/loading.gif" data-original="http://www.phpied.com/files/reflow/render.png" alt></p>
<ul>
<li>浏览器将下载好的HTML源码解析成DOM树，根节点是<code>&lt;html&gt;</code>（<code>documentElement</code>）</li>
<li>浏览器解析CSS，忽略掉无法识别的CSS代码，CSS代码包括浏览器默认样式、开发者的CSS文件还有嵌入HTML的style属性里的样式。</li>
<li>构造渲染树（<code>render tree</code>）。渲染树不同于DOM树，它能够获取到节点样式，仅包含需要渲染的节点，任何不可见的元素（<code>display:none</code>，<code>&lt;head&gt;</code>）都不会出现在渲染树中。另外如果一个<code>&lt;p&gt;</code>标签内有多行元素，在渲染树中每行都会看做是一个节点。</li>
<li>渲染树构造完成后浏览器就可以在屏幕上绘制界面了。</li>
</ul>
<h2 id="渲染机制例子"><a href="#渲染机制例子" class="headerlink" title="渲染机制例子"></a>渲染机制例子</h2><ul>
<li><p>HTML源码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Beautiful page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Once upon a time there was </span><br><span class="line">      a looong paragraph...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">      Secret message</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">documentElement (html)</span><br><span class="line">  head</span><br><span class="line">      title</span><br><span class="line">  body</span><br><span class="line">      p</span><br><span class="line">          [text node]</span><br><span class="line"></span><br><span class="line">      div </span><br><span class="line">          [text node]</span><br><span class="line"></span><br><span class="line">      div</span><br><span class="line">          img</span><br><span class="line"></span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> root (RenderView)</span><br><span class="line">   body</span><br><span class="line">       p</span><br><span class="line">           line 1</span><br><span class="line">           line 2</span><br><span class="line">           line 3</span><br><span class="line">           ...</span><br><span class="line">           </span><br><span class="line">       div</span><br><span class="line">           img</span><br><span class="line">    </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="回流和重绘（reflow-amp-repaint）"><a href="#回流和重绘（reflow-amp-repaint）" class="headerlink" title="回流和重绘（reflow&amp;repaint）"></a>回流和重绘（<code>reflow&amp;repaint</code>）</h2><p>首先可以确定的是网页肯定至少有一次布局和绘制，除非是一个空白页面。</p>
<h3 id="什么是回流和重绘"><a href="#什么是回流和重绘" class="headerlink" title="什么是回流和重绘"></a>什么是回流和重绘</h3><ul>
<li>部分或全部渲染树需要重新验证，节点大小需要重新计算，这称之为<strong>回流</strong>（reflow,relayout）。至少有一次回流发生，即页面的初始布局。</li>
<li>页面部分因为样式的改变而需要更新修改结果，比如说背景颜色、字体颜色、可见性（<code>visibility:hidden</code>），页面可见的更新称之为<strong>重绘</strong>。</li>
</ul>
<h3 id="什么会触发回流和重绘"><a href="#什么会触发回流和重绘" class="headerlink" title="什么会触发回流和重绘"></a>什么会触发回流和重绘</h3><ul>
<li>增加、删除、修改节点</li>
<li>隐藏DOM节点：使用<code>display:none</code>（回流并重绘）；使用<code>visibility:hidden</code>（仅重绘，因为没有布局大小上的改变）</li>
<li>移动等动画作用于DOM节点</li>
<li>添加样式表，并修改样式</li>
<li>用户操作比如放缩窗口大小、修改字体大小、滑动滚动条。</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bstyle = <span class="built_in">document</span>.body.style; <span class="comment">// cache</span></span><br><span class="line"> </span><br><span class="line">bstyle.padding = <span class="string">"20px"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line">bstyle.border = <span class="string">"10px solid red"</span>; <span class="comment">// another reflow and a repaint</span></span><br><span class="line"> </span><br><span class="line">bstyle.color = <span class="string">"blue"</span>; <span class="comment">// repaint only, no dimensions changed</span></span><br><span class="line">bstyle.backgroundColor = <span class="string">"#fad"</span>; <span class="comment">// repaint</span></span><br><span class="line"> </span><br><span class="line">bstyle.fontSize = <span class="string">"2em"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// new DOM element - reflow, repaint</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'dude!'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="headerlink" title="如何减少回流和重绘"></a>如何减少回流和重绘</h3><p>因为除了一些必要的回流和重绘，其他的回流和重绘是不必要甚至是非常浪费资源的，因此我们要尽量避免这种回流和重绘，那么如何避免呢？</p>
<h4 id="浏览器的自动优化"><a href="#浏览器的自动优化" class="headerlink" title="浏览器的自动优化"></a>浏览器的自动优化</h4><p>浏览器为回流和重绘设置一个队列，队列里面保存需要修改的内容，浏览器可以批量处理。时间达到限制或者改变数目达到限制，多次引起回流的改变可以绑定成一个，这样只有一次回流。</p>
<p>但有一些改变或请求可以<strong>强制浏览器清空队列并执行重绘</strong>，如下：</p>
<ul>
<li><code>offsetTop</code>,<code>offsetLeft</code>,<code>offsetWidth</code>,<code>offsetHeight</code>（只读，当前元素和最近relative祖先元素的left距离，当前元素的可见高度）</li>
<li><code>scrollTop</code>,<code>scrollLeft</code>,<code>scrollWidth</code>,<code>scrollHeight</code></li>
<li><code>clientTop</code>,<code>clientLeft</code>,<code>clienWidth</code>,<code>clientHeight</code></li>
<li><code>getComputedStyle()</code>,或者<code>currentStyle</code> in IE</li>
</ul>
<p>因为浏览器必须返回给你这些变量的<strong>最新的值</strong>，因此浏览器必须清空修改队列，并执行相应的更新操作。</p>
<h4 id="常用避免策略"><a href="#常用避免策略" class="headerlink" title="常用避免策略"></a>常用避免策略</h4><ul>
<li><p>不要独立地单独修改样式，修改<code>class</code>或者修改<code>cssText</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>,</span><br><span class="line">    top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or when top and left are calculated dynamically...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在动态的DOM树上批量修改</p>
<ul>
<li>用一个临时进行修改，最终将修改的变量加入到DOM树中。</li>
<li>克隆准备修改的节点，在克隆节点上修改，然后替换原来的节点</li>
<li>隐藏原来的节点（<code>display:none</code>，1次回流，1次重绘），在这个节点上进行批量修改，重新显示这个节点（1次回流，1次重绘）。</li>
</ul>
</li>
<li><p>不要频繁计算样式，不要让浏览器的队列频繁刷新执行修改，比如不要在循环中使用上面提到的那些变量。<strong>应该使用一个缓存变量暂时存储。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// no-no!</span></span><br><span class="line"><span class="keyword">for</span>(big; loop; here) &#123;</span><br><span class="line">    el.style.left = el.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">    el.style.top  = el.offsetTop  + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">var</span> left = el.offsetLeft,</span><br><span class="line">    top  = el.offsetTop</span><br><span class="line">    esty = el.style;</span><br><span class="line"><span class="keyword">for</span>(big; loop; here) &#123;</span><br><span class="line">    left += <span class="number">10</span>;</span><br><span class="line">    top  += <span class="number">10</span>;</span><br><span class="line">    esty.left = left + <span class="string">"px"</span>;</span><br><span class="line">    esty.top  = top  + <span class="string">"px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通常来说，可以考虑当前的修改会让渲染树进行多少计算，然后针对性的进行优化。</p>
<blockquote>
<p>比如说将一个准备进行动画的节点设为<code>postion:absolute</code>使之成为<code>&lt;body&gt;</code>的子节点，这就不会影响大量的其他节点</p>
</blockquote>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>渲染树是DOM树的可见部分</li>
<li>渲染树的重新计算叫做回流</li>
<li>重新计算后将修改绘制在屏幕上叫做重绘</li>
<li>回流一定重绘</li>
<li>重绘不一定回流</li>
<li>需要批量修改样式时使用临时变量，或使目标节点暂时脱离渲染树，或使目标节点减少在渲染树上和其他节点的关系，这样可以一定程度减少回流和重绘</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwaWVkLmNvbS9yZW5kZXJpbmctcmVwYWludC1yZWZsb3dyZWxheW91dC1yZXN0eWxlLw==" title="https://www.phpied.com/rendering-repaint-reflowrelayout-restyle/">Rendering: repaint, reflow/relayout, restyle<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS系列：CSS选择器总结【WIP】</title>
    <url>/css-selectors.html</url>
    <content><![CDATA[<div class="note primary">
            <p>type,universal,attribute,class,id,pseudo-class,pseudo-element,combinator</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>css的选择器一直常用的就几个，也就记住了这几个，初学时系统的学过一遍不过现在也忘得差不多了，今天就来总结一下CSS中到底有哪些选择器。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>所有的选择器如下，我们接下来会一一介绍其用法和语义，还有他们的优先级。</p>
<ul>
<li>简单选择器<ul>
<li>通配选择器</li>
<li>标签（类型）选择器</li>
<li>属性选择器</li>
<li>类选择器</li>
<li>ID选择器</li>
<li>伪类选择器</li>
</ul>
</li>
<li>伪元素选择器</li>
<li>组合选择器</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>再具体介绍各类选择器之前，我们必须先来谈个概念——命名空间。<strong>这部分内容没怎么用过，不会详细展开，只会简单总结一下用法。以后用到会继续补充，如果有错请右下角小窗或者文章右上角修改pr</strong></p>
<p>命名空间可以作用于通配选择器、标签（类型）选择器和属性选择器，目的就是只选择某个或某些命名空间内的元素。<br>命名空间通常用于处理文档中包含多个命名空间，比如说HTML5文档内联一些SVG、MathML、XML等。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>任何 <code>@namespace</code> 规则都必须在所有的 <code>@charset</code> 和 <code>@import</code> 规则之后, 并且在样式表中，位于其他任何 <code>style declarations</code> 之前。</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认命名空间 */</span></span><br><span class="line"><span class="keyword">@namespace</span> url(XML-namespace-URL);</span><br><span class="line"><span class="keyword">@namespace</span> <span class="string">"XML-namespace-URL"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命名空间前缀 */</span></span><br><span class="line"><span class="keyword">@namespace</span> prefix url(XML-namespace-URL);</span><br><span class="line"><span class="keyword">@namespace</span> prefix <span class="string">"XML-namespace-URL"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*匹配prefix命名空间的selector元素*/</span></span><br><span class="line">prefix|selector&#123;&#125;</span><br><span class="line"><span class="comment">/*匹配所有命名空间下的selector元素*/</span></span><br><span class="line">*|selector&#123;&#125;</span><br><span class="line"><span class="comment">/*匹配默认命名空间下的selector元素*/</span></span><br><span class="line"><span class="selector-tag">selector</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> url(<span class="attribute">http:</span>//www.w3.org/<span class="number">1999</span>/xhtml);</span><br><span class="line"><span class="keyword">@namespace</span> svg url(<span class="attribute">http:</span>//www.w3.org/<span class="number">2000</span>/svg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配所有的XHTML &lt;a&gt; 元素, 因为 XHTML 是默认无前缀命名空间 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配所有的 SVG &lt;a&gt; 元素 */</span></span><br><span class="line">svg|a &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配 XHTML 和 SVG &lt;a&gt; 元素 */</span></span><br><span class="line">*|a &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单选择器及其语义"><a href="#简单选择器及其语义" class="headerlink" title="简单选择器及其语义"></a>简单选择器及其语义</h2><p>我们把以下常见的6中选择器称为简单原则器。</p>
<h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><p><code>*</code>，选择任意标签元素。</p>
<h3 id="标签（类型）选择器"><a href="#标签（类型）选择器" class="headerlink" title="标签（类型）选择器"></a>标签（类型）选择器</h3><p><code>type</code>，选择<code>type</code>类型的标签。</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>根据标签的属性来选择。</p>
<h4 id="属性存在性和值选择器"><a href="#属性存在性和值选择器" class="headerlink" title="属性存在性和值选择器"></a>属性存在性和值选择器</h4><ul>
<li><code>[att]</code>，选择含<code>att</code>属性的元素，不管属性值是什么。</li>
<li><code>[att=val]</code>，选择含<code>att</code>属性并且属性值为<code>val</code>的元素。</li>
<li><code>[att~=val]</code>，选择满足如下条件的元素：含<code>att</code>属性，并且<code>att</code>属性值是一个列表，列表中有一个值为<code>val</code>。（<code>val</code>只是一个值，如果其中含空格或者为空串就不会代表任何值）</li>
<li><code>[att|=val]</code>，选择包含<code>att</code>属性并且属性值是<code>val</code>或者以<code>val</code>开头并且后跟<code>-</code>的元素。</li>
</ul>
<h4 id="值串匹配属性选择器"><a href="#值串匹配属性选择器" class="headerlink" title="值串匹配属性选择器"></a>值串匹配属性选择器</h4><ul>
<li><code>[att^=val]</code>，选择含<code>att</code>属性并且值以<code>val</code>开头的元素，如果<code>val</code>为空串则不代表任何值。</li>
<li><code>[att$=val]</code>，选择含<code>att</code>属性并且值以<code>val</code>结束的元素，如果<code>val</code>为空串则不代表任何值。</li>
<li><code>[att*=val]</code>，选择含<code>att</code>属性并且值包含<code>val</code>子串的元素，如果<code>val</code>为空串则不代表任何值。</li>
</ul>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p><code>.selector</code>，选择含有<code>class</code>属性并且值中包含<code>selector</code>值的元素。<strong>类似于<code>[class~=selector]</code>属性选择器</strong>。</p>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p><code>#selector</code>，选择包含<code>id</code>属性并且值为<code>selector</code>的元素。</p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p><code>:selector</code>，伪类是为了解决使用其他简单选择器无法实现的选择问题。选择通常是基于和DOM树无关的信息。通常以<code>:</code>开头。</p>
<h4 id="动态伪类选择器"><a href="#动态伪类选择器" class="headerlink" title="动态伪类选择器"></a>动态伪类选择器</h4><p>不会出现在源码和DOM树中。</p>
<h5 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h5><ul>
<li><code>:link</code>，选择未被访问过的链接元素。</li>
<li><code>:visited</code>，选择已被访问过的链接元素。</li>
</ul>
<h5 id="用户动作伪类选择器"><a href="#用户动作伪类选择器" class="headerlink" title="用户动作伪类选择器"></a>用户动作伪类选择器</h5><p>有可能同时触发。</p>
<ul>
<li><code>:hover</code>，选择被用户选定的（不一定激活元素动作）的元素。</li>
<li><code>:active</code>，选择被用户激活动作的元素。</li>
<li><code>:focus</code>，选择被用户聚焦的元素。</li>
</ul>
<h4 id="目标伪类选择器"><a href="#目标伪类选择器" class="headerlink" title="目标伪类选择器"></a>目标伪类选择器</h4><ul>
<li><code>:target</code>，和网页内部索引有关，某个URI对应一个<code>id</code>，比如当前链接是<code>http://example.com/html/top.html#section_2</code>，被这个链接能够索引到<code>id</code>为<code>section_2</code>的元素，<code>:target</code>就是选择当前URI索引的<code>target</code>元素，如果页内没有<code>target</code>（<code>id</code>）就不会被触发。</li>
</ul>
<h4 id="语言伪类选择器"><a href="#语言伪类选择器" class="headerlink" title="语言伪类选择器"></a>语言伪类选择器</h4><ul>
<li><code>:lang(language)</code>，</li>
</ul>
<h4 id="UI元素状态伪类选择器"><a href="#UI元素状态伪类选择器" class="headerlink" title="UI元素状态伪类选择器"></a>UI元素状态伪类选择器</h4><ul>
<li><code>:enabled</code></li>
<li><code>:disabled</code></li>
<li><code>:checked</code></li>
<li><code>:interminate</code></li>
</ul>
<h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy0zLw==" title="https://www.w3.org/TR/selectors-3/">Selectors Level 3<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTQvUkVDLWNzcy1uYW1lc3BhY2VzLTMtMjAxNDAzMjAv" title="https://www.w3.org/TR/2014/REC-css-namespaces-3-20140320/">CSS Namespaces Module Level 3<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：原型继承和原型链</title>
    <url>/js-concept-17-prototype-inheritance.html</url>
    <content><![CDATA[<div class="note primary">
            <p>prototype inheritance、prototype chain</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JS中的继承是通过原型来实现的，这一部分内容看过很多次，但是一直没有总结，今天就来总结一下这一部分内容</p>
<h2 id="4个问题"><a href="#4个问题" class="headerlink" title="4个问题"></a>4个问题</h2><p>首先来看这四个判断，我们的内容会由这四个判断展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span><span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="必须明确的几个关键点"><a href="#必须明确的几个关键点" class="headerlink" title="必须明确的几个关键点"></a>必须明确的几个关键点</h2><ul>
<li>每个对象都可以访问一个<code>__proto__</code>属性，指向创建当前对象的构造函数的<code>prototype</code>对象。</li>
<li>函数也是对象，可以称之为<code>function object</code>，即函数对象。</li>
<li>每个函数都有一个<code>prototype</code>属性，指向原型对象。</li>
<li>每个函数的<code>prototype</code>对象里都有一个<code>constructor</code>属性指向函数本身。</li>
<li>原型链的尽头是<code>Object.prototype</code>，他没有<code>__proto__</code>属性，实际上有这个属性，但是为<code>null</code></li>
</ul>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> o=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__===<span class="built_in">Object</span>.prototype<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为<code>obj</code>是一个对象，所以它有一个<code>__proto__</code>属性，并且它由<code>Object</code>构造函数创建，<code>Object</code>函数有一个<code>prototype</code>属性，因此<code>obj.__proto__</code>和<code>Object.prototype</code>指向同一个对象。不妨自己动手打印一下，这两个对象是一样的。</p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.constructor === <span class="built_in">Object</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为每个函数的<code>prototype</code>属性都有一个<code>constructor</code>属性指向函数本身，因此<code>Object.prototype.constructor</code>指向<code>Object</code>函数。</p>
<h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为函数也是对象（<code>function object</code>），因此它有一个<code>__proto__</code>属性，那这个属性指向哪呢？函数对象是由哪个构造函数创建的？很容易猜到，就是<code>Function</code>对象。因此<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>
<h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>还是如此，函数也是对象。<code>Function</code>函数有一个<code>__proto__</code>属性，那它指向哪呢？因为<code>Function</code>也是一个函数，创建函数的很容易想到是<code>Function</code>，可能有点奇怪，不过就是如此。</p>
<h3 id="例子5"><a href="#例子5" class="headerlink" title="例子5"></a>例子5</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.constructor === <span class="built_in">Function</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>每个函数的原型对象都会有一个<code>constructor</code>属性指向函数本身，因此<code>Function.prototype.constructor</code>就是指向<code>Function</code>函数。</p>
<h3 id="例子6"><a href="#例子6" class="headerlink" title="例子6"></a>例子6</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>某个函数的原型对象是一个对象，那么他的<code>__proto__</code>属性指向谁呢？因为<code>Object</code>函数用于创建对象，因此<code>Function.prototype.__proto__</code>就指向<code>Object.prototype</code>。</p>
<h2 id="instanceof怎么判断的以及4个问题的答案"><a href="#instanceof怎么判断的以及4个问题的答案" class="headerlink" title="instanceof怎么判断的以及4个问题的答案"></a>instanceof怎么判断的以及4个问题的答案</h2><p>就如下代码，<code>instanceof</code>的判断条件是，如果在<code>b.prototype</code>在<code>a</code>的原型链中就返回<code>true</code>，如果没有则<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> b</span><br></pre></td></tr></table></figure>
<p>因此一开始的4个问题的答案就很容易解答了。</p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为<code>Object.__proto__</code>指向<code>Function.prototype</code>，即<code>Function.prototype</code>在<code>Object</code>的原型链上。</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为<code>Object.__proto__.__proto__</code>指向<code>Object.prototype</code>，即<code>Object.prototype</code>在<code>Object</code>的原型链上。</p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为<code>Function.__proto__</code>指向<code>Function.prototype</code>，即<code>Function.prototype</code>在<code>Function</code>的原型链上。</p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为<code>Function.__proto__.__proto__</code>指向<code>Object.prototype</code>，即<code>Object.prototype</code>在<code>Function</code>的原型链上。</p>
<h2 id="如何实现原型继承"><a href="#如何实现原型继承" class="headerlink" title="如何实现原型继承"></a>如何实现原型继承</h2><p>总共分3步（这没有实现静态方法的继承）：</p>
<ol>
<li><code>super.call(this)</code></li>
<li><code>child.prototype=Object.create(super.prototype)</code></li>
<li><code>child.prototype.constructor=child</code></li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>,name);<span class="comment">//#1，构造父类属性</span></span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype=<span class="built_in">Object</span>.create(Animal.prototype);<span class="comment">//#2，实现原型链继承</span></span><br><span class="line">Cat.prototype.constructor=Cat;<span class="comment">//#3，设置构造函数</span></span><br></pre></td></tr></table></figure>
<h3 id="静态的继承"><a href="#静态的继承" class="headerlink" title="静态的继承"></a>静态的继承</h3><p>在ES6的<code>class-extends</code>方式中，你可以指定静态<code>static</code>的方法和属性，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> staticMethod()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"static method invoked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.staticMethod();<span class="comment">//static method invoked!</span></span><br></pre></td></tr></table></figure>
<p>因为<code>Dog</code>函数本身没有这个方法，那么肯定在它的原型链上，问题是Dog的原型根据ES5的写法应该<code>Dog.__proto__===Function.prototype</code>为<code>true</code>，然而这个例子中<code>Dog.__proto__===Animal</code>为<code>true</code>，这说明上面ES5的继承方法缺少了静态继承，<strong>补全以上代码的话应该有4步</strong>：</p>
<ol>
<li><code>super.call(this)</code></li>
<li><code>child.prototype=Object.create(super.prototype)</code></li>
<li><code>child.prototype.constructor=child</code></li>
<li><code>child.__proto__=Animal</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>,name);<span class="comment">//#1，构造父类属性</span></span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype=<span class="built_in">Object</span>.create(Animal.prototype);<span class="comment">//#2，实现原型链继承</span></span><br><span class="line">Cat.prototype.constructor=Cat;<span class="comment">//#3，设置构造函数</span></span><br><span class="line">Cat.__proto__=Animal<span class="comment">//#4，实现静态继承</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="头条面经的几个问题"><a href="#头条面经的几个问题" class="headerlink" title="头条面经的几个问题"></a>头条面经的几个问题</h2><p>在看头条面经时看到的问题，来一一分析一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.a=<span class="string">'Object'</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.a = <span class="string">'Function'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Person()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Person.a)</span><br><span class="line"><span class="built_in">console</span>.log(child.a)</span><br><span class="line"><span class="built_in">console</span>.log(child.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__.constructor)</span><br><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__.constructor.constructor)</span><br><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__.constructor.constructor.constructor)</span><br></pre></td></tr></table></figure>
<h3 id="打印1"><a href="#打印1" class="headerlink" title="打印1"></a>打印1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.a)<span class="comment">//Function</span></span><br></pre></td></tr></table></figure>
<p>首先<code>Person</code>是一个函数对象，它本身没有<code>a</code>这个属性，因此需要沿着原型链向上找。函数是由<code>Function</code>创建的，因此<code>Person.__proto__</code>指向<code>Function.prototype</code>，而<code>Function.prototype</code>有属性<code>a</code>，值为“Function”因此结果为“Function”。</p>
<h3 id="打印2"><a href="#打印2" class="headerlink" title="打印2"></a>打印2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.a)<span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p>首先<code>child</code>对象本身没有这个属性，因此需要沿着原型链向上找。<code>child</code>由<code>Person</code>创建，因此<code>child.__proto__</code>指向<code>Person</code>的原型，<code>Person.prototype</code>没有这个属性，因此继续向上找，<code>Person.prototype</code>是由<code>Object</code>创建的，因此<code>Person.prototype.__proto__</code>指向<code>Object</code>的原型对象，而<code>Object.prototype.a</code>是“Object”，因此结果是“Object”</p>
<h3 id="打印3"><a href="#打印3" class="headerlink" title="打印3"></a>打印3</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.__proto__)<span class="comment">//Person.prototype</span></span><br></pre></td></tr></table></figure>
<p><code>child</code>对象由<code>Person</code>创建，因此<code>child.__proto__</code>指向<code>Person.prototype</code>，打印的就是<code>Person.prototype</code>，不出意外的话里面有一个<code>constructor</code>属性指向<code>Person</code>，还有一个<code>__proto__</code>属性指向<code>Object.prototype</code>。</p>
<h3 id="打印4"><a href="#打印4" class="headerlink" title="打印4"></a>打印4</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__)<span class="comment">//Object.prototype</span></span><br></pre></td></tr></table></figure>
<p>参考<strong>打印3</strong>，<code>child.__proto__</code>指向<code>Person.prototype</code>，因此就等价于打印<code>Person.prototype.__proto__</code>，而<code>Person.prototype</code>是由<code>Object</code>创建的，因此<code>Person.prototype.__proto__</code>指向<code>Object.prototype</code>因此打印的就是<code>Object.prototype</code>里面的内容。</p>
<h3 id="打印5"><a href="#打印5" class="headerlink" title="打印5"></a>打印5</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__.constructor)<span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p>参考<strong>打印4</strong>，直到<code>child.__proto__.proto__</code>指向<code>Object.prototype</code>，那它的<code>constructor</code>属性就指向<code>Object</code>函数本身。</p>
<h3 id="打印6"><a href="#打印6" class="headerlink" title="打印6"></a>打印6</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__.constructor.constructor)<span class="comment">//Function</span></span><br></pre></td></tr></table></figure>
<p>参考<strong>打印5</strong>，知道<code>child.__proto__.__proto__.constructor</code>指向的是<code>Object</code>，那么<code>Object.constructor</code>指向的谁呢？首先<code>Object</code>本身没有<code>constructor</code>属性，那么就沿着原型链向上找，而<code>Object</code>是一个函数对象，即由<code>Function</code>创建，因此<code>Object.__proto__</code>指向<code>Function.prototype</code>，而<code>Function.prototype.constructor</code>是<code>Function</code>本身，因此结果就是“Function”。</p>
<h3 id="打印7"><a href="#打印7" class="headerlink" title="打印7"></a>打印7</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(child.__proto__.__proto__.constructor.constructor.constructor)<span class="comment">//Function</span></span><br></pre></td></tr></table></figure>
<p>参考<strong>打印6</strong>，因为<code>child.__proto__.__proto__.constructor.constructor</code>指向<code>Function</code>，因此等价于<code>Function.constructor</code>，而<code>Function</code>函数对象本身没有这个属性，于是沿着原型链向上找，<code>Function.__proto__</code>指向<code>Function.prototype</code>，而<code>Function.prototype.constructor</code>是<code>Function</code>本身，因此结果也是“Function”</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每个对象都可以访问一个<code>__proto__</code>属性，指向创建当前对象的构造函数的<code>prototype</code>对象。</li>
<li>函数也是对象，可以称之为<code>function object</code>，即函数对象。</li>
<li>每个函数都有一个<code>prototype</code>属性，指向原型对象。</li>
<li>每个函数的<code>prototype</code>对象里都有一个<code>constructor</code>属性指向函数本身。</li>
<li>原型链的尽头是<code>Object.prototype</code>，他没有<code>__proto__</code>属性，实际上有这个属性，但是为<code>null</code></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZW1lbnRvci5pby9zYW5kZWVwcmFuamFuMjAwNy9wcm90b3R5cGUtaW4tamF2YXNjaXB0LWtuYnZlMGxxbw==" title="https://www.codementor.io/sandeepranjan2007/prototype-in-javascipt-knbve0lqo">Prototype in Javascript<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2JldHRlci1wcm9ncmFtbWluZy9wcm90b3R5cGVzLWluLWphdmFzY3JpcHQtNWJiYTI5OTBlMDRi" title="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b">Prototypes in JavaScript<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvMzQ2NTgyP3R5cGU9MCZhbXA7b3JkZXI9MCZhbXA7cG9zPTE1JmFtcDtwYWdlPTA=" title="https://www.nowcoder.com/discuss/346582?type=0&amp;order=0&amp;pos=15&amp;page=0">北京头条前端面经<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWNvZGVjYW1wLm9yZy9uZXdzL3Byb3RvdHlwZS1pbi1qcy1idXN0ZWQtNTU0N2VjNjg4NzIv" title="https://www.freecodecamp.org/news/prototype-in-js-busted-5547ec68872/">Prototype in JavaScript: it’s quirky, but here’s how it works<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：原始数据类型和对象属性【WIP】</title>
    <url>/js-concept-2-primitive-type.html</url>
    <content><![CDATA[<div class="note primary">
            <p>number、boolean、null、undefined、string、bigint、symbol</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章会总结一下JS的原始类型和对象属性相关的问题。关于类型隐式转换会在后续文章中总结。</p>
<p>本篇文章大致会涉及以下内容：</p>
<ul>
<li>各种原始数据类型介绍</li>
<li>原始数据类型的自动装箱和拆箱</li>
<li>对象数据属性和对象访问属性</li>
<li>对象属性描述符</li>
</ul>
<h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>根据<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9EYXRhX3N0cnVjdHVyZXMjUHJpbWl0aXZlX3ZhbHVlcw==" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Primitive_values">MDN<i class="fa fa-external-link"></i></span>的说法，ECMAScript标准定义了8种数据类型：</p>
<ul>
<li>Seven data types that are primitives:<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>BigInt</li>
<li>String</li>
<li>Symbol</li>
</ul>
</li>
<li>and Object</li>
</ul>
<h3 id="Number-Type-amp-BigInt"><a href="#Number-Type-amp-BigInt" class="headerlink" title="Number Type&amp;BigInt"></a>Number Type&amp;BigInt</h3><p>之前写过一篇文章，是关于JS的number类型的，JS中没有Integer，只有double-float（虽然关于位运算提供了一层32位抽象），关于IEEE754标准已经写过几篇文章了，这篇文章不会再提及。有兴趣的可以看一下这两篇文章：</p>
<ul>
<li><a href="/ieee754-float-instance-js.html">IEEE754 实例 ——JS 中的 Number 类型</a></li>
<li><a href="/float-think.html">有关计算机浮点数的思考。</a></li>
</ul>
<p>接下来总结一些常用点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span>!==<span class="literal">NaN</span><span class="comment">//true，规定</span></span><br><span class="line"><span class="literal">NaN</span>===<span class="literal">NaN</span><span class="comment">//false</span></span><br><span class="line"><span class="number">1</span>&gt;<span class="literal">NaN</span><span class="comment">//false</span></span><br><span class="line"><span class="number">1</span>&lt;=<span class="literal">NaN</span><span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><blockquote>
<p><code>true</code> or <code>false</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">false</span>)<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">"false"</span>)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>)<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>([])<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><blockquote>
<p><code>null</code></p>
</blockquote>
<p>一般把<code>null</code>考虑为一个对象引用，这个对象引用为空。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span><span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><blockquote>
<p><code>undefined</code></p>
</blockquote>
<p>一切声明但未初始化的变量值为<code>undefined</code>，对于<code>var</code>声明的变量仅在执行上下文创建时期引起的变量提升初值为<code>undefined</code></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>immutable,too。不像C语言那样可以改。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test=<span class="string">"abc"</span>;</span><br><span class="line">test[<span class="number">0</span>]=<span class="string">'d'</span>;</span><br><span class="line">test<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><blockquote>
<p>独一无二，不可修改，可用作对象属性的key</p>
</blockquote>
<h2 id="Wrapper-amp-Auto-Boxing"><a href="#Wrapper-amp-Auto-Boxing" class="headerlink" title="Wrapper &amp; Auto-Boxing"></a>Wrapper &amp; Auto-Boxing</h2><p>原始类型没有对象类型的优点，比如内置属性方法什么的，所以就有了一些原始类型的封装类，称之为<code>Wrapper Object</code>。</p>
<p>比如这些：</p>
<ul>
<li>String</li>
<li>Boolean</li>
<li>Number</li>
<li>…</li>
</ul>
<p>就以<code>String</code>函数举例，使用它有两种方式：</p>
<ul>
<li><p>以普通函数方式，将入参转换为字符串并返回对应String的原始类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">1337</span>); <span class="comment">// "1337"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>); <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>); <span class="comment">// "null"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>); <span class="comment">// "undefined"</span></span><br><span class="line"><span class="built_in">String</span>(); <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">"dog"</span>) === <span class="string">"dog"</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">"dog"</span>); <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以构造函数方式，创建一个对应类型的封装对象<code>wrapper object</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"dog"</span>)</span><br><span class="line"><span class="keyword">typeof</span> pet; <span class="comment">// "object"</span></span><br><span class="line">pet === <span class="string">"dog"</span>; <span class="comment">// false</span></span><br><span class="line"><span class="comment">//pet是一个对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  0: "d",</span></span><br><span class="line"><span class="comment">  1: "o",</span></span><br><span class="line"><span class="comment">  2: "g",</span></span><br><span class="line"><span class="comment">  length: 3</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Data-property-amp-accessor-property"><a href="#Data-property-amp-accessor-property" class="headerlink" title="Data property &amp; accessor property"></a>Data property &amp; accessor property</h2><h2 id="Property-Descriptor"><a href="#Property-Descriptor" class="headerlink" title="Property Descriptor"></a>Property Descriptor</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuYnJldy5jb20uaGsvbm90LWV2ZXJ5dGhpbmctaW4tamF2YXNjcmlwdC1pcy1hbi1vYmplY3Qv" title="http://blog.brew.com.hk/not-everything-in-javascript-is-an-object/">(Not) Everything in JavaScript is an Object<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMC8wOS8yNy90aGUtc2VjcmV0LWxpZmUtb2YtamF2YXNjcmlwdC1wcmltaXRpdmVzLw==" title="https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/">The Secret Life of JavaScript Primitives<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmJpdHNyYy5pby9kaXZpbmctZGVlcGVyLWluLWphdmFzY3JpcHRzLW9iamVjdHMtMzE4YjFlMTNkYzEy" title="https://blog.bitsrc.io/diving-deeper-in-javascripts-objects-318b1e13dc12">Diving Deeper in JavaScripts Objects<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Bib2xhamlheW9kZWppdGhlLWRpZmZlcmVuY2VzLWJldHdlZW4tb2JqZWN0LWZyZWV6ZS12cy1jb25zdC1pbi1qYXZhc2NyaXB0LTRlYWNlYTUzNGQ3Yw==" title="https://medium.com/@bolajiayodejithe-differences-between-object-freeze-vs-const-in-javascript-4eacea534d7c">The differences between Object.freeze() vs Const in JavaScript<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：map、reduce、filter</title>
    <url>/js-concept-19-map-reduce-filter.html</url>
    <content><![CDATA[<div class="note primary">
            <p>map、reduce、filter</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>终于来到这个主题了。这三个函数可以让你coding像飘柔般流畅。这是一种函数式编程。今天就来总结一下这三种函数的使用方法和使用场景。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>MDN的syntax：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return element for new_array</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<ul>
<li>callback：回调函数<ul>
<li>currentValue：迭代的当前值</li>
<li>【optional】index：数组当前下标</li>
<li>【optional】array：数组对象</li>
</ul>
</li>
<li>【optional】thisArg：执行callback时this的引用对象</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>定义一个对应关系，将原集合一一映射到新的集合。</p>
<p>例如，矩阵的数乘：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-4</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> vectorMultWithNum=<span class="function">(<span class="params">arr,num</span>)=&gt;</span>arr.map(<span class="function"><span class="params">x</span>=&gt;</span>x*num);</span><br><span class="line"><span class="keyword">let</span> result=vectorMultWithNum(arr,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">//[4, 8, -16, 36]</span></span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>MND的syntax：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg]);</span><br></pre></td></tr></table></figure>
<ul>
<li>callback：回调函数<ul>
<li>element：迭代的当前值</li>
<li>【optional】index：数组当前下标</li>
<li>【optional】array：数组对象</li>
</ul>
</li>
<li>【optional】thisArg：执行callback时this的引用对象</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>定义一个过滤条件函数，满足时返回true，否则false。</p>
<p>例如，获得数组的所有偶数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> result=arr.filter(<span class="function"><span class="params">x</span>=&gt;</span>x%<span class="number">2</span>===<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">//[10]</span></span><br></pre></td></tr></table></figure>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>MDN的syntax：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>
<ul>
<li>callback：回调函数<ul>
<li>accumulator：累加器，或者是上次合并后的结果。或者是initialValue</li>
<li>currentValue：迭代的当前值</li>
<li>【optional】index：数组当前下标。注意是否提供了initialValue</li>
<li>【optional】array：数组对象</li>
</ul>
</li>
<li>【optional】initialValue：累加器的初始值。如果不指定初始值那就将数组第一个元素值当做初始值并跳过第一个元素。空数组不指定初始值会报错。</li>
</ul>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>这三个函数中，reduce是最有艺术感的，他能把数组中的所有元素值进行一个一个合并生成最后的结果。</p>
<h4 id="简单sum求和"><a href="#简单sum求和" class="headerlink" title="简单sum求和"></a>简单sum求和</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result=arr.reduce(<span class="function">(<span class="params">sum,cur</span>)=&gt;</span>sum+cur);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<h4 id="多次复合函数"><a href="#多次复合函数" class="headerlink" title="多次复合函数"></a>多次复合函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">x,...fns</span>)=&gt;</span>fns.reduceRight(<span class="function">(<span class="params">f,g</span>)=&gt;</span>g(f),x);</span><br><span class="line"><span class="keyword">const</span> fn1=<span class="function"><span class="params">x</span>=&gt;</span>x**<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> fn2=<span class="function"><span class="params">x</span>=&gt;</span>x+<span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> result=compose(x,fn1,fn2);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">//(x+11)**2===(1+11)**2===144</span></span><br><span class="line"><span class="comment">//144</span></span><br></pre></td></tr></table></figure>
<h3 id="Promise-Chain"><a href="#Promise-Chain" class="headerlink" title="Promise Chain"></a>Promise Chain</h3><p>之前写过一篇关于使用JavaScript实现一个任务队列的。</p>
<p>如果使用reduce的话会显得代码很简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = [];</span><br><span class="line">    &#125;</span><br><span class="line">    task(delay, callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks.push(&#123; delay, callback &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tasks.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.tasks.reduce(<span class="function">(<span class="params">s,x</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.then(<span class="function"><span class="params">r</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        x.callback();</span><br><span class="line">                        resolve();</span><br><span class="line">                    &#125;,x.delay);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,<span class="built_in">Promise</span>.resolve()).then(<span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tasks=[];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Queue()</span><br><span class="line">    .task(<span class="number">1000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .task(<span class="number">2000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .task(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure>
<h3 id="其他应用场景"><a href="#其他应用场景" class="headerlink" title="其他应用场景"></a>其他应用场景</h3><p>其他场景还有很多，关键点就是迭代合并操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一些用法还不是很熟练，比如promise，接下来会加强这一部分的连接。再见！</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2pzZ3VydS9qYXZhc2NyaXB0LWZ1bmN0aW9uYWwtcHJvZ3JhbW1pbmctbWFwLWZpbHRlci1hbmQtcmVkdWNlLTg0NmZmOWJhNDkyZA==" title="https://medium.com/jsguru/javascript-functional-programming-map-filter-and-reduce-846ff9ba492d">JavaScript Functional Programming — map, filter and reduce<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>协议系列：HTTP历史版本特性更改关键点总结</title>
    <url>/http-change-history.html</url>
    <content><![CDATA[<div class="note primary">
            <p>HTTP1.0、HTTP1.0、HTTP2.0、HTTP3</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在维基百科看HTTP状态码的时候看到了HTTP的版本历史，发现了一些不知道的东西，今天就来总结一下这部分内容。</p>
<p>一些详细的历史内容比如说谁发布的标准等等，在本篇文章中并不会涉及，读者有兴趣可以自行Google，本篇文章重点是HTTP版本的关键特性变化。</p>
<p>如果有关键内容没有提及或者说有错误的话，请右下方小窗我或者文章右上角修改文件在GitHub发起pr。</p>
<ul>
<li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
<li><a href="#http11">HTTP1.1</a></li>
<li><a href="#http2">HTTP2</a></li>
<li><a href="#http3">HTTP3</a></li>
<li><a href="#https">HTTPS</a></li>
<li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>相较于HTTP1.0发生了如下改变：</p>
<ul>
<li>持久连接。HTTP1.0每次TCP连接只允许一次资源请求，一个request——response的pair。HTTP1.1允许每次连接都有多个请求响应pair。这样也利用了TCP的慢启动策略，速度上有明显的提升。</li>
<li>pipelining流水线。HTTP1.1发送请求后不再等待响应后再请求其他资源，允许一次发送多个请求。</li>
<li>Byte Range Serving。顾名思义，HTTP1.1允许客户端请求资源的一部分。这个和Chunked transfer encoding可以互相替代。</li>
<li>Chunked transfer encoding，一种数据流机制。HTTP1.1允许将数据分割成块，这些块独立的进行传输。HTTP2已经不用这种方法了。</li>
</ul>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>向前兼容，HTTP3没有隔离以前的重要版本，能够运行基于HTTP1.0和1.1的应用程序。</p>
<ul>
<li>不支持HTTP1.1的Chunked transfer encoding，自己提供了另一种类似的数据流机制。</li>
</ul>
<h2 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h2><p>向前兼容的，HTTP3没有隔离以前的重要版本，能够运行基于HTTP2的应用程序。今年一些浏览器比如Google、Firefox已经开始支持HTTP3了。</p>
<ul>
<li>传输层级基于UDP</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>暂时就总结这么多，以后遇到时再来添加。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSHlwZXJ0ZXh0X1RyYW5zZmVyX1Byb3RvY29s" title="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Hypertext Transfer Protocol<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Protocol</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Protocol</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>协议系列：HTTP常见请求方式和状态码总结</title>
    <url>/http-status-code.html</url>
    <content><![CDATA[<div class="note primary">
            <p>404 not found。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看<a href="secure-same-origin-policy.html">同源策略和跨域问题</a>时，看到CORS的解决方案是需要prefight，跨域时先向目标源发送一个OPTIONS请求，就发现这部分知识没有系统的了解过。今天就来总结一下常见的HTTP请求方式和HTTP状态码。</p>
<ul>
<li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
<li><a href="#%e5%b8%b8%e8%a7%81http%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f">常见HTTP请求方式</a></li>
<li><a href="#%e5%b8%b8%e8%a7%81http%e7%8a%b6%e6%80%81%e7%a0%81">常见HTTP状态码</a><ul>
<li><a href="#1xx-informational-response%e4%bf%a1%e6%81%af%e5%93%8d%e5%ba%94">1xx informational response，信息响应</a></li>
<li><a href="#2xx-success%e6%88%90%e5%8a%9f">2xx success，成功</a></li>
<li><a href="#3xx-redirection%e9%87%8d%e5%ae%9a%e4%bd%8d">3xx redirection，重定位</a></li>
<li><a href="#4xx-client-errors%e5%ae%a2%e6%88%b7%e7%ab%af%e9%94%99%e8%af%af">4xx client errors，客户端错误</a></li>
<li><a href="#5xx-server-errors%e6%9c%8d%e5%8a%a1%e5%99%a8%e9%94%99%e8%af%af">5xx server errors，服务器错误</a></li>
</ul>
</li>
<li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<h2 id="常见HTTP请求方式"><a href="#常见HTTP请求方式" class="headerlink" title="常见HTTP请求方式"></a>常见HTTP请求方式</h2><p>这些请求方式是case-sensitive的，但是一些请求工具或请求框架可能已经做了toUpperCase处理。</p>
<ul>
<li>GET（HTTP1.0）。这个是最常见的请求方式了，只读资源而不产生副作用。</li>
<li>POST（HTTP1.0）。请求数据通常来自于表单。</li>
<li>OPTIONS（HTTP1.1）。请求返回服务器对特定资源支持哪些请求方式。</li>
<li>HEAD（HTTP1.0）。和Get类似之只读资源并不产生副作用。区别是响应无响应体，只想获取一些响应头中的元信息。</li>
<li>PUT（HTTP1.1）。指定URI，如果对应资源存在则修改（替代）；如果不存在则创建。不带验证机制。</li>
<li>DELETE（HTTP1.1）。删除指定资源。不带验证机制。</li>
<li>TRACE（HTTP1.1）。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</li>
<li>CONNECT（HTTP1.1）。服务器会将通信路径返回给客户端。</li>
<li>PATCH。对资源进行部分修改，区别于PUT。不带验证机制。</li>
</ul>
<h2 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h2><ul>
<li>1xx informational response，信息响应。接收的请求正在处理。</li>
<li>2xx success，成功。请求正常处理完毕。</li>
<li>3xx redirection，重定位。需要进行附加操作以完成请求。</li>
<li>4xx client errors，客户端错误</li>
<li>5xx server errors，服务器错误</li>
</ul>
<h3 id="1xx-informational-response，信息响应"><a href="#1xx-informational-response，信息响应" class="headerlink" title="1xx informational response，信息响应"></a>1xx informational response，信息响应</h3><h3 id="2xx-success，成功"><a href="#2xx-success，成功" class="headerlink" title="2xx success，成功"></a>2xx success，成功</h3><h3 id="3xx-redirection，重定位"><a href="#3xx-redirection，重定位" class="headerlink" title="3xx redirection，重定位"></a>3xx redirection，重定位</h3><ul>
<li>304 Not modified。请求方通过<code>If-Modified-Since</code>或者<code>If-None-Match</code>请求头知道请求的资源并未改变，服务器无需重传，客户端使用缓存的版本即可。</li>
</ul>
<h3 id="4xx-client-errors，客户端错误"><a href="#4xx-client-errors，客户端错误" class="headerlink" title="4xx client errors，客户端错误"></a>4xx client errors，客户端错误</h3><ul>
<li>400 Bad Request。客户端错误导致服务器无法处理，比如请求格式错误、数据太大等。</li>
<li>401 Unauthorized。类似403。</li>
<li>403 Forbidden。客户端请求时包含非法数据，服务器理解请求但是拒绝处理。可能是因为用户无权限，或者请求了一个禁止的行为（比如创建重复记录）。</li>
<li>404 Not Found。资源未找到。</li>
<li>405 Method Not Allowed。请求方法不允许。比如使用PUT方法访问只读资源，应该使用POST而使用GET。</li>
<li>415 Unsupported Media Type。媒体文件格式不支持。比如客户端上传图片使用<code>images/svg+xml</code>，而服务器需要另外的图片格式。</li>
</ul>
<h3 id="5xx-server-errors，服务器错误"><a href="#5xx-server-errors，服务器错误" class="headerlink" title="5xx server errors，服务器错误"></a>5xx server errors，服务器错误</h3><ul>
<li>500 Internal Server Error。服务器内部错误，需要查看服务器报错日志。</li>
<li>502 Bad Gateway。请求的服务器是作为一个网关或者代理运行的。上流服务器返回的响应是非法的。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这部分内容只是简单地总结。一些状态码和方法并没有实际的用过，因此用于回查。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9IVFRQX3N0YXR1c19jb2Rlcw==" title="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">List of HTTP status codes<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSHlwZXJ0ZXh0X1RyYW5zZmVyX1Byb3RvY29s" title="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Hypertext Transfer Protocol<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXMvYmxvYi9tYXN0ZXIvbm90ZXMvSFRUUC5tZA==" title="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md">CyC2018 HTTP<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Protocol</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Protocol</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全系列：同源策略和跨域请求</title>
    <url>/secure-same-origin-policy.html</url>
    <content><![CDATA[<div class="note primary">
            <p>同源策略和跨域请求。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1. 前言"></a>0x1. 前言</h2><p>同源策略问题也是一个面试常问的问题，这篇文章来总结一下。</p>
<p>大体内容如下：</p>
<ul>
<li><a href="#0x1-%e5%89%8d%e8%a8%80">0x1. 前言</a></li>
<li><a href="#0x2-%e5%90%8c%e6%ba%90%e7%ad%96%e7%95%a5">0x2. 同源策略</a><ul>
<li><a href="#0x21-%e4%bb%80%e4%b9%88%e6%98%af%e5%90%8c%e6%ba%90">0x2.1 什么是同源</a></li>
<li><a href="#0x22-%e5%90%8c%e6%ba%90%e9%97%ae%e9%a2%98%e4%b8%be%e4%be%8b">0x2.2 同源问题举例</a></li>
<li><a href="#0x23-%e5%90%8c%e6%ba%90%e7%ad%96%e7%95%a5%e7%9a%84%e9%99%90%e5%88%b6">0x2.3 同源策略的限制</a></li>
<li><a href="#0x24-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89%e5%90%8c%e6%ba%90%e7%ad%96%e7%95%a5">0x2.4 为什么有同源策略</a></li>
</ul>
</li>
<li><a href="#0x3-%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98">0x3. 跨域问题</a><ul>
<li><a href="#0x31-%e5%a6%82%e4%bd%95%e5%8f%91%e8%b5%b7ajax%e8%b7%a8%e5%9f%9f%e8%af%b7%e6%b1%82">0x3.1 如何发起Ajax跨域请求</a><ul>
<li><a href="#0x311-jsonpjson-with-padding">0x3.1.1 JSONP(JSON with Padding)</a></li>
<li><a href="#0x312-corscross-origin-resource-sharing">0x3.1.2 CORS(Cross-Origin Resource Sharing)</a></li>
<li><a href="#0x313-websockets">0x3.1.3 WebSockets</a></li>
<li><a href="#0x314-cors-vs-jsonp">0x3.1.4 CORS vs JSONP</a></li>
</ul>
</li>
<li><a href="#0x32-%e5%85%b6%e4%bb%96%e8%b7%a8%e5%9f%9f%e9%97%ae%e9%a2%98">0x3.2 其他跨域问题</a><ul>
<li><a href="#0x321-%e8%b7%a8%e5%9f%9f%e5%85%b1%e4%ba%abcookie">0x3.2.1 跨域共享Cookie</a></li>
<li><a href="#0x322-%e8%b7%a8%e5%9f%9fiframe">0x3.2.2 跨域iframe</a></li>
<li><a href="#0x322-%e8%b7%a8%e5%9f%9flocalstorage">0x3.2.2 跨域localStorage</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#0x4-reference">0x4. Reference</a></li>
</ul>
<h2 id="0x2-同源策略"><a href="#0x2-同源策略" class="headerlink" title="0x2. 同源策略"></a>0x2. 同源策略</h2><blockquote>
<p>同源策略是一种安全机制，这种安全机制限制了一个源内的文档或脚本如何和其他源的资源交互。这种机制有利于隔离潜在的恶意文本。</p>
</blockquote>
<h3 id="0x2-1-什么是同源"><a href="#0x2-1-什么是同源" class="headerlink" title="0x2.1 什么是同源"></a>0x2.1 什么是同源</h3><p>如果两个源的【协议、主机、端口号】三元组都相同的话那么就称这两个源是同源的。</p>
<h3 id="0x2-2-同源问题举例"><a href="#0x2-2-同源问题举例" class="headerlink" title="0x2.2 同源问题举例"></a>0x2.2 同源问题举例</h3><p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
<h3 id="0x2-3-同源策略的限制"><a href="#0x2-3-同源策略的限制" class="headerlink" title="0x2.3 同源策略的限制"></a>0x2.3 同源策略的限制</h3><p>同源策略限制的是JavaScript的脚本，也就是说一些资源比如说CSS、HTML和动态加载的脚本就能够通过HTML标签跨域。<a href="secure-xss-csrf.html">CSRF</a>就是利用了这一点。</p>
<p>那么具体限制JavaScript的哪些行为呢？</p>
<ul>
<li>跨域Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>跨域DOM 无法获得。</li>
<li>跨域AJAX 请求不能发送。</li>
</ul>
<h3 id="0x2-4-为什么有同源策略"><a href="#0x2-4-为什么有同源策略" class="headerlink" title="0x2.4 为什么有同源策略"></a>0x2.4 为什么有同源策略</h3><p>同源策略在一定程度上保证了信息安全。<br>就像CSRF那个例子一样。现在网站很多都是通过cookie进行身份认证的，如果网站A的cookie能够在网站B获取，那么我就可以在网站B发送请求给网站A的服务器。</p>
<h2 id="0x3-跨域问题"><a href="#0x3-跨域问题" class="headerlink" title="0x3. 跨域问题"></a>0x3. 跨域问题</h2><p>在一些场景中同源策略就显得限制性太强了，比如不同子域名属于跨域，不允许其交互，但是属于同一个父域名。</p>
<h3 id="0x3-1-如何发起Ajax跨域请求"><a href="#0x3-1-如何发起Ajax跨域请求" class="headerlink" title="0x3.1 如何发起Ajax跨域请求"></a>0x3.1 如何发起Ajax跨域请求</h3><p>下面是一些常见的Ajax跨域请求方法。</p>
<h4 id="0x3-1-1-JSONP-JSON-with-Padding"><a href="#0x3-1-1-JSONP-JSON-with-Padding" class="headerlink" title="0x3.1.1 JSONP(JSON with Padding)"></a>0x3.1.1 JSONP(JSON with Padding)</h4><p>跨域Ajax请求的常用方法。只能发送<code>Get</code>请求。<br>通过动态添加<code>&lt;script&gt;&lt;/script&gt;</code>标签，利用<code>src</code>字段向目的源服务器请求数据，这是不受同源策略限制的，因为并没有使用JavaScript进行跨域请求。</p>
<p><code>src</code>中必须声明回调函数，也就是有一个查询字符串<code>callback</code>参数，值为回调函数的名称。</p>
<p>如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://server.example.com/Users/1234?callback=parseResponse"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端会将返回的数据包装在<code>parseResponse()</code>的括号内（这就是JSONP名称的由来<code>Padding or Payload</code>），注意这是一个文本。</p>
<p>客户端实际接收到的数据是<code>parseResponse(data)</code>，因为<code>&lt;scirpt&gt;</code>标签加载的文件会自动执行，所以只要定义了<code>parseResponse</code>这个函数那就会自动调用。</p>
<p>只能通过<code>&lt;script&gt;</code>的<code>src</code>指定请求路径，这就决定了<code>JSONP</code>只能发起get请求。</p>
<h4 id="0x3-1-2-CORS-Cross-Origin-Resource-Sharing"><a href="#0x3-1-2-CORS-Cross-Origin-Resource-Sharing" class="headerlink" title="0x3.1.2 CORS(Cross-Origin Resource Sharing)"></a>0x3.1.2 CORS(Cross-Origin Resource Sharing)</h4><p>目标源服务端允许的源可向其发起跨域请求。</p>
<p>过程如下：</p>
<ol>
<li>客户端跨域请求</li>
<li>浏览器发送一个<code>OPTIONS</code>请求到目标源服务器，这个请求报文里包含<code>Origin</code>字段（当前网站的源），还有一些其他细节。</li>
<li>目标源服务端返回。</li>
<li>浏览器检查目标源服务器返回的报文，如果包含<code>Access-Control-Allow-Origin</code>字段且当前源满足条件则发起请求。</li>
</ol>
<p>验证是否满足跨域条件的例子（来自维基百科）：</p>
<ul>
<li><p><code>OPTIONS</code>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS /</span><br><span class="line">Host: service.example.com</span><br><span class="line">Origin: http://www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标源服务器返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.example.com</span><br><span class="line">Access-Control-Allow-Methods: PUT, DELETE</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>维基百科跨域XHR的创建：</p>
<p><img src="/images/loading.gif" data-original="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Flowchart_showing_Simple_and_Preflight_XHR.svg/770px-Flowchart_showing_Simple_and_Preflight_XHR.svg.png" alt></p>
<h4 id="0x3-1-3-WebSockets"><a href="#0x3-1-3-WebSockets" class="headerlink" title="0x3.1.3 WebSockets"></a>0x3.1.3 WebSockets</h4><p><code>ws</code>是一种协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀，这个协议不受同源策略限制。</p>
<p>客户端请求时添加<code>origin</code>字段，表示当前源是哪，服务器根据这个字段进行相应，如果在白名单内则允许本次通信。</p>
<h4 id="0x3-1-4-CORS-vs-JSONP"><a href="#0x3-1-4-CORS-vs-JSONP" class="headerlink" title="0x3.1.4 CORS vs JSONP"></a>0x3.1.4 CORS vs JSONP</h4><ul>
<li>JSONP只支持GET请求；CORS也支持其他HTTP请求</li>
<li>CORS使程序员写跨域请求像普通请求一样，便于维护；JSONP则相对不易维护。</li>
<li>JSONP在古老的浏览器上也能运行；CORS在大多数现代浏览器上能运行</li>
<li>JSONP可能会被XSS攻击如果跨域请求目的源不够安全的话；CORS则更安全。</li>
</ul>
<h3 id="0x3-2-其他跨域问题"><a href="#0x3-2-其他跨域问题" class="headerlink" title="0x3.2 其他跨域问题"></a>0x3.2 其他跨域问题</h3><h4 id="0x3-2-1-跨域共享Cookie"><a href="#0x3-2-1-跨域共享Cookie" class="headerlink" title="0x3.2.1 跨域共享Cookie"></a>0x3.2.1 跨域共享Cookie</h4><p>跨域Cookie的共享可以通过修改<code>document.domain</code>属性来跨域。<strong><code>domain</code>必须是当前页面的域名或者是其父域名。</strong>，而且端口号必须相同，设置<code>domain</code>时会将端口号设为<code>null</code>。</p>
<p>共享Cookie也可以在服务端设置Cookie时，将Cookie的域名范围设为父域名。</p>
<p>比如<code>http://a.example.com</code>和<code>http://b.example.com</code>，服务器设置cookie时，只需要设置为<code>Set-Cookie: key=value; domain=.example.com; path=/</code></p>
<h4 id="0x3-2-2-跨域iframe"><a href="#0x3-2-2-跨域iframe" class="headerlink" title="0x3.2.2 跨域iframe"></a>0x3.2.2 跨域iframe</h4><p>如果两个不同源的网页拥有共同的一级域名，那么就可以通过修改<code>document.domain</code>的方式实现跨域。</p>
<p>如果完全不同源可以通过如下三种方式：</p>
<ul>
<li>片段标识符</li>
<li>window.name</li>
<li>Cross-document messaging</li>
</ul>
<p>前两种比较捞就不总结了，第三种跨文本通信才是正统的Web API，就是通过<code>window.postMessage(message,origin)</code>方法进行跨窗口通信，不管是否同源。</p>
<p>一般来说通过postMessage+listener的方式进行通信。</p>
<h4 id="0x3-2-2-跨域localStorage"><a href="#0x3-2-2-跨域localStorage" class="headerlink" title="0x3.2.2 跨域localStorage"></a>0x3.2.2 跨域localStorage</h4><p>可以使用如上所说的跨文本通信进行通信。</p>
<h2 id="0x4-Reference"><a href="#0x4-Reference" class="headerlink" title="0x4. Reference"></a>0x4. Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE2LzA0L3NhbWUtb3JpZ2luLXBvbGljeS5odG1s" title="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2FtZS1vcmlnaW5fcG9saWN5" title="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9BcmNoaXZlL01pc2NfdG9wX2xldmVsL1NhbWUtb3JpZ2luX3BvbGljeV9mb3JfZmlsZTpfVVJJcw==" title="https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs">Same-origin policy for file: URIs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2FtZS1vcmlnaW5fcG9saWN5" title="https://en.wikipedia.org/wiki/Same-origin_policy">Same-origin policy<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3Mtb3JpZ2luX3Jlc291cmNlX3NoYXJpbmc=" title="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross-origin resource sharing<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSlNPTlA=" title="https://en.wikipedia.org/wiki/JSONP">JSONP<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>用JavaScript实现一个任务队列</title>
    <url>/js-taskqueue.html</url>
    <content><![CDATA[<div class="note primary">
            <p>用JavaScript实现一个任务队列。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>头条一面的题，有思路，但是JavaScript Promise用的不够熟练，记录一下。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个API，实现对应的功能。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>给定如下接口，请实现一个任务队列。效果是<code>task</code>方法用于注册任务，<code>start</code>函数调用后，1s后打印1，再过2s后打印2，再过3秒后打印3。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Queue()</span><br><span class="line">    .task(<span class="number">1000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .task(<span class="number">2000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .task(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h4><p>首先<code>task</code>方法仅仅是注册，因此需要将注册的内容保存下来。</p>
<p>定义一个如下对象用于保存注册的任务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.tasks = [&#123;</span><br><span class="line">    delay:<span class="number">1</span>,</span><br><span class="line">    callback:<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;,</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h4><p>然后可以链式调用<code>task</code>方法，因此其返回值就是<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">task(delay, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(&#123; delay, callback &#125;);</span><br><span class="line">    <span class="comment">// console.log(callback)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h4><p>最后是关键部分，如何把任务给连接起来并开启队列执行。</p>
<p>执行顺序应该是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">task1设置</span><br><span class="line">-&gt;1s...task1运行</span><br><span class="line">-&gt;task2在task1回调函数执行后设置</span><br><span class="line">-&gt;2s...task2运行</span><br><span class="line">-&gt;task3在task2回调函数执行后设置</span><br><span class="line">-&gt;3s...task3运行</span><br></pre></td></tr></table></figure>
<p>我们创建一个<code>Promise</code>对象，添加一个定时器，在<code>setTimeout</code>回调函数中执行完注册的callback后<code>resolve</code>。这样我就可以在这个<code>Promise</code>对象的then方法中添加下一个定时器。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = [];</span><br><span class="line">    &#125;</span><br><span class="line">    task(delay, callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks.push(&#123; delay, callback &#125;);</span><br><span class="line">        <span class="comment">// console.log(callback)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.task.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="keyword">this</span>.tasks.shift();</span><br><span class="line">        <span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"starting......"</span>);</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                cur.callback();</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;, cur.delay);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.tasks.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> element = <span class="keyword">this</span>.tasks.shift();</span><br><span class="line"></span><br><span class="line">            func = func.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                        element.callback();</span><br><span class="line">                        resolve();</span><br><span class="line">                    &#125;, element.delay);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        func.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"ending....."</span>);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Queue()</span><br><span class="line">    .task(<span class="number">1000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .task(<span class="number">2000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .task(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Promise</code>对象的使用不够熟练，后续会继续深入学习，敬请期待。</p>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全系列：XSS和CSRF</title>
    <url>/secure-xss-csrf.html</url>
    <content><![CDATA[<div class="note primary">
            <p>XSS、CSRF</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web应用的安全问题也是一个web开发人员需要了解的事，今天我们就来看一看常见的两种安全问题，<code>XSS</code>和<code>CSRF</code>。</p>
<p><strong>因为对安全问题不够熟悉，读者如果发现问题请右下角小窗私聊或文章右上角修改按钮github提交pr。</strong></p>
<p>大体内容如下：</p>
<ul>
<li>XSS<ul>
<li>什么是XSS</li>
<li>XSS分类</li>
<li>XSS实例</li>
<li>XSS避免</li>
</ul>
</li>
<li>CSRF<ul>
<li>什么是CSRF</li>
<li>CSRF实例</li>
<li>CSRF避免</li>
</ul>
</li>
</ul>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><blockquote>
<p>Cross-site scripting (XSS) bugs are one of the most common and dangerous types of vulnerabilities in Web applications.These nasty buggers can allow your enemies to steal or modify user data in your apps.</p>
</blockquote>
<p>通过这个<span class="exturl" data-url="aHR0cHM6Ly94c3MtZ2FtZS5hcHBzcG90LmNvbS8=" title="https://xss-game.appspot.com/">小实验（游戏）<i class="fa fa-external-link"></i></span>，你就可以大致了解一下XSS是一个什么东西了。</p>
<p>认识的一个大佬也写过一篇<span class="exturl" data-url="aHR0cHM6Ly9vcnpib3guZ2l0aHViLmlvL291ci10ZWNoLyMvYXJ0aWNsZXMvWFNTLUV4cGxhaW4tMQ==" title="https://orzbox.github.io/our-tech/#/articles/XSS-Explain-1">XSS文章<i class="fa fa-external-link"></i></span>，可以当做参考。</p>
<p>做了一下这个实验，勉勉强强算是通关了。</p>
<p>在这个XSS Game中做了什么？<strong>整体感觉就是从客户端找漏洞（看网页源码，JS、HTML），然后通过表单或者url注入脚本或者一些其他第三方脚本。</strong></p>
<blockquote>
<p>Cross-site scripting carried out on websites accounted for roughly 84% of all security vulnerabilities documented by Symantec up until 2007.（Wikipedia）</p>
</blockquote>
<h3 id="常见XSS分类"><a href="#常见XSS分类" class="headerlink" title="常见XSS分类"></a>常见XSS分类</h3><ul>
<li>Stored XSS Attacks：持久注入，注入数据库</li>
<li>Reflected XSS Attacks:注入的数据会由服务器返回或者直接跳转到另一个页面显示</li>
<li>DOM-based XSS Attacks：修改DOM</li>
</ul>
<h3 id="XSS注入方式"><a href="#XSS注入方式" class="headerlink" title="XSS注入方式"></a>XSS注入方式</h3><ul>
<li>表单注入</li>
<li>URL注入</li>
<li>引用外部脚本</li>
</ul>
<h3 id="XSS避免"><a href="#XSS避免" class="headerlink" title="XSS避免"></a>XSS避免</h3><ul>
<li>同源策略</li>
<li>白名单策略（内容安全策略，Content Safe Policy）</li>
<li>表单验证</li>
<li>拼凑字符串时验证来自querystring的变量</li>
</ul>
<h3 id="XSS-Game实验内容"><a href="#XSS-Game实验内容" class="headerlink" title="XSS Game实验内容"></a>XSS Game实验内容</h3><p>大体记录一下实验内容吧。</p>
<h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><p>一个提交表单的页面，输入数据data并提交。<br>观察py代码可以看到他会将data渲染到页面内，那么我可以输入以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>OK，Hello World to XSS就完成了。</p>
<h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p>一个发送评论的页面。<br>通过观察源码，发现他也会将输入的数据data直接显示出来。</p>
<p>但是这时候使用level1中的方法已经不管用了（可能是因为页面已经加载完了，无法执行script脚本</p>
<p>但是我可以通过如下代码来实现，插入一个无效图片，通过onerror方法来执行脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>level2 is over！</p>
<h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><p>没有可输入的表单，但是可以通过URL输入，有个哈希参数用于图片显示。</p>
<p>通过观察源码，发现他将url输入的数字编号通过img标签进行拼接了（num就是我们输入的数）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html += "<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'/static/level3/cloud" + num + ".jpg'</span> /&gt;</span>";</span><br></pre></td></tr></table></figure>
<p>那我们可以通过如下代码来封闭标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">https://xss-game.appspot.com/level3/frame#x' onerror='alert("xss")'&gt;</span><br></pre></td></tr></table></figure>
<p>完成！</p>
<h4 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h4><p>一个输入表单数据timer，然后提交。</p>
<p>通过查看py代码，发现他的数据渲染部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;/static/loading.gif&quot; onload=&quot;startTimer(&apos;&#123;&#123; timer &#125;&#125;&apos;);&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>我们利用封闭标签，输入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;);alert(&apos;xss</span><br><span class="line"></span><br><span class="line">模板渲染后：onload=&quot;startTimer(&apos;&apos;);alert(&apos;xss&apos;);&quot;</span><br></pre></td></tr></table></figure>
<p>这样就完成了。</p>
<h4 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h4><p>观察源码有一个a标签是通过模板渲染的:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; next &#125;&#125;"</span>&gt;</span>Next &gt;&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用a标签的伪协议来完成，我们可以输入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)</span><br><span class="line"></span><br><span class="line">模板渲染后：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>&gt;</span>Next &gt;&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h4><p>可以通过URL请求其他文件，可以通过data协议（<code>data:text/plain,alert(&#39;s&#39;)</code>）创建一个简单的文本。</p>
<p>结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level6/frame#data:text/plain,alert('xss')</span><br></pre></td></tr></table></figure>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><blockquote>
<p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。（Wikipedia）</p>
</blockquote>
<p>顾名思义，就是攻击者伪造请求。假如说用户在A网站登录了，这时候浏览器保存了登录信息，这段时间内用户又访问了B网站，B网站内存在一个A网站则请求（这个请求是攻击者伪造的），这样就属于跨站请求伪造。</p>
<h3 id="维基百科上的例子"><a href="#维基百科上的例子" class="headerlink" title="维基百科上的例子"></a>维基百科上的例子</h3><p>前提是没有同源策略，Attackers才能使用银行的登录信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">假如一家银行用以运行转账操作的URL地址如下： http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</span><br><span class="line"></span><br><span class="line">那么，一个恶意攻击者可以在另一个网站上放置如下代码： <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</span><br><span class="line"></span><br><span class="line">这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</span><br><span class="line"></span><br><span class="line">透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</span><br></pre></td></tr></table></figure>
<p>因为同源策略不允许读取其他源的cookie，所以如何完成攻击呢？<br>如果可以，使用XSS攻击加CSRF攻击就可以很好的完成。首先使用stored的XSS注入到数据库，然后显示到银行的网页，此时victim不小心点击的这个标签，就会发起请求了。</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ul>
<li>检查Referer字段，发起请求的来源。存在客户端伪造Referer的可能</li>
<li>添加校验token（伪随机数）</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly94c3MtZ2FtZS5hcHBzcG90LmNvbS8=" title="https://xss-game.appspot.com/">Warning: You are entering the XSS game area<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9vcnpib3guZ2l0aHViLmlvL291ci10ZWNoLyMvYXJ0aWNsZXMvWFNTLUV4cGxhaW4tMQ==" title="https://orzbox.github.io/our-tech/#/articles/XSS-Explain-1">XSS跨站脚本攻击探讨总结<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3Mtc2l0ZV9zY3JpcHRpbmc=" title="https://en.wikipedia.org/wiki/Cross-site_scripting">Cross-site scripting<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU3JUFCJTk5JUU4JUFGJUI3JUU2JUIxJTgyJUU0JUJDJUFBJUU5JTgwJUEw" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">跨站请求伪造<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS系列：对齐</title>
    <url>/css-align-center.html</url>
    <content><![CDATA[<div class="note primary">
            <p>水平居中、垂直居中、右对齐。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>元素居中是实际前端开发中常用的一种操作。元素居中分为垂直居中和水平居中，为了以后方便重查，本篇文章总结一下一些常见的对齐方式。</p>
<p><strong>样例代码如下，查看时请参考下面的代码。</strong></p>
<p></p><p class="codepen" data-height="800" data-theme-id="dark" data-default-tab="css,result" data-user="scarboroughcoral" data-slug-hash="oNNmbMV" style="height: 400px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Centering with CSS Part 1"><br>  <span>See the Pen <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL3NjYXJib3JvdWdoY29yYWwvcGVuL29OTm1iTVY=" title="https://codepen.io/scarboroughcoral/pen/oNNmbMV"><br>  Centering with CSS Part 1<i class="fa fa-external-link"></i></span> by 李明岳 (<span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL3NjYXJib3JvdWdoY29yYWw=" title="https://codepen.io/scarboroughcoral">@scarboroughcoral<i class="fa fa-external-link"></i></span>)<br>  on <span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlv" title="https://codepen.io">CodePen<i class="fa fa-external-link"></i></span>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="文本水平居中"><a href="#文本水平居中" class="headerlink" title="文本水平居中"></a>文本水平居中</h4><ul>
<li><code>text-align</code>属性</li>
</ul>
<h4 id="div水平居中"><a href="#div水平居中" class="headerlink" title="div水平居中"></a>div水平居中</h4><ul>
<li><strong>蓝色盒子</strong>，将父容器设为<code>text-align:center</code>，div设为<code>display:inline-block</code>，适用于多个div水平居中。</li>
<li>【推荐】<strong>黄色盒子</strong>，使用<code>margin:auto</code>属性设置（需要设置宽度）</li>
<li>【推荐，常用于响应式开发，注意脱离文档流带来的问题】<strong>绿色盒子</strong>，父容器<code>position:relative</code>，div设置<code>position:absolute</code>和<code>left:50%</code>和<code>transform:translateX(-50%)</code></li>
<li><strong>绿色盒子</strong>，父容器<code>position:relative</code>，div设置<code>position:absolute</code>和<code>left:50%</code>和<code>margin-left:(-width/2)</code></li>
<li>【极度推荐,响应式，无需计算margin】<strong>粉色盒子</strong>，父容器<code>display:flex</code>并<code>flex-direction:row</code>（默认），然后<code>justify-content:center</code>（要看主轴的方向）</li>
</ul>
<h3 id="右对齐"><a href="#右对齐" class="headerlink" title="右对齐"></a>右对齐</h3><h4 id="文本右对齐"><a href="#文本右对齐" class="headerlink" title="文本右对齐"></a>文本右对齐</h4><ul>
<li>使用<code>text-align:right</code></li>
</ul>
<h4 id="div右对齐"><a href="#div右对齐" class="headerlink" title="div右对齐"></a>div右对齐</h4><ul>
<li>使用<code>position:absolute</code>和<code>right:0</code>实现</li>
<li>【推荐】使用<code>flex</code>布局</li>
<li>（十分奇妙）使用<code>margin-left:auto</code>，需要设置宽度</li>
<li>使用<code>float</code>，注意脱离文档流带来的问题（eg：如果高度大于父容器，则需要设置父容器<code>overflow:auto</code>）</li>
<li>将父容器设为<code>text-align:right</code>，div设为<code>display:inline-block</code></li>
</ul>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>垂直居中不太好演示，代码直接在这里写了。</p>
<h4 id="文本垂直居中"><a href="#文本垂直居中" class="headerlink" title="文本垂直居中"></a>文本垂直居中</h4><ul>
<li>《不推荐》使用<code>padding</code></li>
<li>【推荐】使用<code>height</code>和<code>line-height</code>设置，考虑文本多行<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the text has multiple lines, add the following: */</span></span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="div垂直居中"><a href="#div垂直居中" class="headerlink" title="div垂直居中"></a>div垂直居中</h4><ul>
<li><p>父容器设置<code>line-height</code>和<code>height</code>等高，div设置为<code>display:inline-block</code>和<code>vertical-align:middle</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父容器<code>position:relative</code>，div设置<code>position:absolute</code>和<code>top:50%</code>和<code>margin-top:(-height/2)</code></p>
</li>
<li><p>【推荐,响应式】父容器<code>position:relative</code>，div设置<code>position:absolute</code>和<code>top:50%</code>和<code>transform:translateY(-50%)</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>【极度推荐,响应式，无需计算margin】使用<code>flex</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大致就是如此，后续发现其他方法继续补充。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9jc3MvY3NzX2FsaWduLmFzcA==" title="https://www.w3schools.com/css/css_align.asp">CSS Layout - Horizontal &amp; Vertical Align<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWNvZGVjYW1wLm9yZy9uZXdzL2hvdy10by1jZW50ZXItdGhpbmdzLXdpdGgtc3R5bGUtaW4tY3NzLWRjODdiNzU0MjY4OQ==" title="https://www.freecodecamp.org/news/how-to-center-things-with-style-in-css-dc87b7542689">How to center things with style in CSS<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：执行上下文（栈帧）、作用域、闭包、this之间的关系</title>
    <url>/js-concept-7-scope-2.html</url>
    <content><![CDATA[<div class="note primary">
            <p>执行上下文（栈帧）、作用域、闭包、this之间的关系。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章<a href="js-concept-7-scope.html">《JavaScript必知33个概念系列：作用域》</a>总结的作用域问题，但是有一些关系还是没有整理清楚，本篇文章单独说明执行上下文（栈帧）、作用域、闭包、this之间的关系。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文大体可以分为两种：</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
</ul>
<p>每个执行上下文有两个状态：</p>
<ul>
<li>创建状态</li>
<li>执行状态</li>
</ul>
<h3 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h3><h4 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h4><ul>
<li>创建一个global（window）对象</li>
<li>创建this变量，默认指向window</li>
<li>为全局执行上下文的变量分配内存</li>
<li>为全局执行上下文内的变量赋值为<code>undefined</code></li>
<li>为全局执行上下文的函数分配内存，并将内容存入内存。</li>
</ul>
<h4 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h4><ul>
<li>逐行执行</li>
</ul>
<h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><h4 id="创建状态-1"><a href="#创建状态-1" class="headerlink" title="创建状态"></a>创建状态</h4><ul>
<li>创建一个argarguments（参数列表）对象</li>
<li>创建this变量，默认指向window</li>
<li>为当前函数执行上下文内的变量分配内存</li>
<li>为当前函数执行上下文内的变量赋值为<code>undefined</code></li>
<li>为当前函数执行上下文的函数分配内存，并将内容存入内存。</li>
</ul>
<h4 id="执行状态-1"><a href="#执行状态-1" class="headerlink" title="执行状态"></a>执行状态</h4><ul>
<li>逐行执行</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>MDN 中定义作用域就是当前的执行上下文。</p>
</blockquote>
<p>如果在当前函数执行上下文下访问一个变量val，发现当前函数执行上下文内没有，那就向上层执行上下文内找。这条链就称为作用域链。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>一个常见的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line">count += add5(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>利用执行上下文来理解，当调用<code>makeAdder(5)</code>之后该函数的执行上下文（包括参数<code>x</code>）已经弹出了，但是函数<code>add5</code>调用时可以访问<code>x</code>，这是因为<code>makeAdder(5)</code>返回后创建了闭包，其中保存了<code>makeAdder</code>的执行上下文环境，当调用<code>add5</code>时，会在闭包环境下创建自己的执行上下文，那么变量就可以沿着作用域链访问了（就可以访问<code>x</code>）。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this</code>存在于当前执行上下文中，其引用会因绑定方式而决定，请看<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwanMtY29uY2VwdC0xNS10aGlzLWNhbGwtYmluZC1hcHBseS5odG1s" title="http://localhost:4000js-concept-15-this-call-bind-apply.html">JavaScript 必知 33 个概念系列：this、call、bind、apply<i class="fa fa-external-link"></i></span>。</p>
<p>箭头函数创建执行上下文时不会创建<code>this</code>变量，所以内部访问变量时会沿着作用域链向上找。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90eWxlcm1jZ2lubmlzLmNvbS91bHRpbWF0ZS1ndWlkZS10by1leGVjdXRpb24tY29udGV4dHMtaG9pc3Rpbmctc2NvcGVzLWFuZC1jbG9zdXJlcy1pbi1qYXZhc2NyaXB0Lw==" title="https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/">The Ultimate Guide to Hoisting, Scopes, and Closures in JavaScript<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>Web API系列：存储</title>
    <url>/js-storage.html</url>
    <content><![CDATA[<div class="note primary">
            <p>cookie、localStorage、sessionStorage、indexedDB</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前可能用过<code>Web API</code>对象里面的存储对象，比如说<code>cookie</code>和<code>localStorage</code>。但是仅仅把他们当做一个浏览器端存储的工具，并没有认真区分它们的不同和应用场景。</p>
<p>首先为什么需要浏览器端存储数据的<code>Web API</code>？HTTP是一个无状态（stateless）协议，需要浏览器记录一些东西。</p>
<p><strong>本篇主要是简单的了解一些概念和用法，不会深入的总结</strong>，后续会深入了解。</p>
<p>今天总结的主要有三个话题：</p>
<ul>
<li>区别</li>
<li>使用场景举例</li>
<li>使用方法（Web API）</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ul>
<li>存储的数据没有截止日期（有效期）的设置，也就是说只要你不主动删除它，它就可能永远存在。</li>
<li>只能由客户端读取</li>
<li>只能通过JavaScript清除存储条目，或者是用浏览器清除缓存和本地存储数据。</li>
<li>存储的限制容量比sessionStorage和cookie要大</li>
</ul>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ul>
<li>存储的数据只在一个会话中有效，也就是说当关闭浏览器（或者对应tab）时数据会失效。</li>
<li>数据不会自动提交到服务器，只能由客户端读取</li>
<li>存储的限制容量大于cookie（至少5MB）</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul>
<li>一般存储一些后续请求中需要发送给服务器的数据，也就是说每次请求都会发送cookie（会涉及性能问题）</li>
<li>有效期会可以由客户端设置，也可以由服务端设置（一般有服务端设置）</li>
<li>Cookie一般主要由服务端读取，当然客户端也可以读取。（localStorage和sessionStorage只能由客户端读取）</li>
<li>存储大小小于4KB</li>
<li>可以设置<code>httpOnly</code>为<code>true</code>，这样就禁止客户端读取cookie</li>
<li>涉及隐私问题</li>
</ul>
<h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><ul>
<li>浏览器客户端的低级API</li>
<li>能够存储大量的结构化数据，包括文件，支持大量数据存储。</li>
<li>使用索引进行查询，性能高</li>
<li>是一个事务型数据库系统，有点像基于SQL的关系型数据库管理系统（但列不是固定的）</li>
<li>是基于JavaScript的面向对象数据库</li>
</ul>
<h2 id="使用场景举例"><a href="#使用场景举例" class="headerlink" title="使用场景举例"></a>使用场景举例</h2><h3 id="localStorage-1"><a href="#localStorage-1" class="headerlink" title="localStorage"></a>localStorage</h3><ul>
<li>持久的较少量数据存储</li>
</ul>
<h3 id="sessionStorage-1"><a href="#sessionStorage-1" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ul>
<li>会话相关的较少量数据存储</li>
</ul>
<h3 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie的工作过程是这样的：</p>
<ol>
<li>客户端发起请求</li>
<li><p>服务端想要在客户端保存一些状态信息，于是在HTTP响应报文添加头部字段<code>Set-Cookie</code>，这样客户端就会保存下来。</p>
<ol>
<li>可以指定有效时间（<code>Expires</code>或<code>Max-Age</code>）和域名路径（<code>Domain</code>和<code>Path</code>）来限制cookie。</li>
<li><code>Secure</code>对于<code>http:</code>协议尽管加密也不安全，一些浏览器已经已经不支持不安全的网站（<code>http:</code>）设置<code>Secure</code>了。</li>
<li><code>HttpOnly</code>设置之后不允许浏览器端JavaScript访问<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/2.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>客户端的后续请求都会携带客户端的cookie信息，即请求头<code>Cookie</code>字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/2.0</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面是一些cookie的使用场景。</p>
<ul>
<li>会话管理<ul>
<li>登陆状态、购物车、游戏分数等服务端需要记录的</li>
</ul>
</li>
<li>个性化<ul>
<li>用户偏好、主题、其他设置等</li>
</ul>
</li>
<li>追踪<ul>
<li>记录分析用户行为</li>
</ul>
</li>
</ul>
<h3 id="indexedDB-1"><a href="#indexedDB-1" class="headerlink" title="indexedDB"></a>indexedDB</h3><ul>
<li>大量数据存储</li>
<li>高性能查询</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="localStorage-2"><a href="#localStorage-2" class="headerlink" title="localStorage"></a>localStorage</h3><ul>
<li><p>set</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'myCat'</span>, <span class="string">'Tom'</span>);</span><br><span class="line">localStorage.setItem(<span class="string">'colorSetting'</span>, <span class="string">'#a4509b'</span>);</span><br><span class="line">localStorage.colorSetting = <span class="string">'#a4509b'</span>;<span class="comment">//不推荐</span></span><br><span class="line">localStorage[<span class="string">'colorSetting'</span>] = <span class="string">'#a4509b'</span>;<span class="comment">///不推荐</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>get</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = localStorage.getItem(<span class="string">'myCat'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">localStorage.removeItem(<span class="string">'myCat'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>clear</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Clear all items</span></span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sessionStorage-2"><a href="#sessionStorage-2" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>和localStorage接口类似。</p>
<h3 id="cookie-2"><a href="#cookie-2" class="headerlink" title="cookie"></a>cookie</h3><ul>
<li><p>write</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"yummy_cookie=choco"</span>; </span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"tasty_cookie=strawberry"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>read</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie); </span><br><span class="line"><span class="comment">// logs "yummy_cookie=choco; tasty_cookie=strawberry"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reset</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"yummy_cookie="</span>; </span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"tasty_cookie="</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="indexedDB-2"><a href="#indexedDB-2" class="headerlink" title="indexedDB"></a>indexedDB</h3><p>先了解一下indexedDB的推荐使用流程</p>
<ol>
<li>检查是否支持indexedDB</li>
<li>打开数据库<code>database</code></li>
<li>在数据库中创建一个对象存储仓库<code>object store</code></li>
<li>开启事务，请求数据库操作（添加、获取等）</li>
<li>等待操作完成（可以通过监听事件来操作）</li>
<li>使用查询结果</li>
</ol>
<p>其他的使用方法暂时不深入了解了，以后用到时再写一篇。</p>
<h2 id="相关话题"><a href="#相关话题" class="headerlink" title="相关话题"></a>相关话题</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zY290Y2guaW8vQFByYXR5dXNoQi9sb2NhbC1zdG9yYWdlLXZzLXNlc3Npb24tc3RvcmFnZS12cy1jb29raWU=" title="https://scotch.io/@PratyushB/local-storage-vs-session-storage-vs-cookie">Local Storage vs Session Storage vs Cookie<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Db29raWVz" title="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">HTTP cookies<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUEk=" title="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB API<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSQ==" title="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage API<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUEkvVXNpbmdfSW5kZXhlZERC" title="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">Using IndexedDB<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>Web API</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：this、call、bind、apply</title>
    <url>/js-concept-15-this-call-bind-apply.html</url>
    <content><![CDATA[<div class="note primary">
            <p>this、call、bind、apply</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript的灵活性也导致了规则的多样性。今天来总结一下JavaScript中的<code>this</code>关键字，及其相关话题<code>bind,call,apply</code></p>
<h2 id="JavaScript中的this"><a href="#JavaScript中的this" class="headerlink" title="JavaScript中的this"></a>JavaScript中的this</h2><p>以前学其他语言比如说Java或者CPP时，那时理解的<code>this</code>就是当前对象，当调用构造函数创建对象时，<code>this</code>会绑定到创建的对象上。关于JavaScript中的<code>this</code>并没有过多的关注。</p>
<h3 id="JavaScript中this的5个绑定规则"><a href="#JavaScript中this的5个绑定规则" class="headerlink" title="JavaScript中this的5个绑定规则"></a>JavaScript中this的5个绑定规则</h3><blockquote>
<p>函数在哪里调用，<code>this</code>的引用就来自于这里。</p>
</blockquote>
<ul>
<li>隐式绑定</li>
<li>显示绑定</li>
<li>new 绑定</li>
<li>词法绑定</li>
<li>window 绑定</li>
</ul>
<p>接下来我们一一解释。</p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>如下代码，大多数<code>this</code>绑定的情况都是如此，你只需要判断调用函数的对象就知道this指的谁，<strong>即“.”左侧</strong>。下面例子中<code>this</code>分别指的是<code>user</code>和<code>user.mother</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Tyler'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  greet() &#123;</span><br><span class="line">    alert(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  mother: &#123;</span><br><span class="line">    name: <span class="string">'Stacey'</span>,</span><br><span class="line">    greet() &#123;</span><br><span class="line">      alert(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.greet();</span><br><span class="line">user.mother.greet();</span><br></pre></td></tr></table></figure></p>
<h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>显示绑定就用到<code>bind,call,apply</code>方法了。这三个方法来自于<code>Function.prototype</code>。所以说每个函数都会有这三个方法。其中<code>call,apply</code>来自于ES3，<code>bind</code>来自于ES5。</p>
<h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><blockquote>
<p>“call” is a method on every function that allows you to invoke the function specifying in what context the function will be invoked.</p>
</blockquote>
<p>如下代码，当调用<code>greet</code>函数的时候并不知道这个<code>this</code>引用的哪个对象，无法通过<code>user.greet(x,x,x)</code>来调用，因为<code>user</code>并没有这个函数对象。那么我们只能单独的调用这个函数，我们可以通过<code>call</code>的方式来指定调用当前函数的对象，第一个参数就是<code>this</code>引用的对象，剩余的参数是函数调用所需要的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span> (<span class="params">l1, l2, l3</span>) </span>&#123;</span><br><span class="line">  alert(</span><br><span class="line">    <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I know <span class="subst">$&#123;l1&#125;</span>, <span class="subst">$&#123;l2&#125;</span>, and <span class="subst">$&#123;l3&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Tyler'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> languages = [<span class="string">'JavaScript'</span>, <span class="string">'Ruby'</span>, <span class="string">'Python'</span>]</span><br><span class="line"></span><br><span class="line">greet.call(user, languages[<span class="number">0</span>], languages[<span class="number">1</span>], languages[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><p><code>apply</code>和<code>call</code>类似，只不过<code>apply</code>解决了<code>call</code>一个问题，就像上面那个例子，当调用的函数需要接受很多参数的时候，需要一个一个将参数传入，如果我们有10个参数就需要单独输入10个参数。而<code>apply</code>只需要将参数当做数组传入，不必一个一个传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> languages = [<span class="string">'JavaScript'</span>, <span class="string">'Ruby'</span>, <span class="string">'Python'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// greet.call(user, languages[0], languages[1], languages[2])</span></span><br><span class="line">greet.apply(user, languages)</span><br></pre></td></tr></table></figure>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><p><code>bind</code>和<code>call</code>也是类似的，只不过他不会立即调用函数，而是返回一个新函数，这个新函数绑定了一系列参数，其中第一个参数就是<code>this</code>的引用对象，其余参数是函数调用时所需要的参数，当你调用新函数时，仅需要将未绑定的参数（如果已全部绑定就无需传参）传入就行了。</p>
<p>还是上面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span> (<span class="params">l1, l2, l3</span>) </span>&#123;</span><br><span class="line">  alert(</span><br><span class="line">    <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I know <span class="subst">$&#123;l1&#125;</span>, <span class="subst">$&#123;l2&#125;</span>, and <span class="subst">$&#123;l3&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Tyler'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> languages = [<span class="string">'JavaScript'</span>, <span class="string">'Ruby'</span>, <span class="string">'Python'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newFn = greet.bind(user, languages[<span class="number">0</span>], languages[<span class="number">1</span>], languages[<span class="number">2</span>])</span><br><span class="line">newFn() <span class="comment">// alerts "Hello, my name is Tyler and I know JavaScript, Ruby, and Python"</span></span><br></pre></td></tr></table></figure>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><blockquote>
<p>当使用<code>new</code>创建对象时，<code>JavaScript Interpretor</code>就会创建一个对象，这个对象叫<code>this</code>，也就是说<code>this</code>的引用对象就是新创建的对象。</p>
</blockquote>
<p>如下代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Under the hood, JavaScript creates a new object called `this`</span></span><br><span class="line"><span class="comment">    which delegates to the User's prototype on failed lookups. If a</span></span><br><span class="line"><span class="comment">    function is called with the new keyword, then it's this new object</span></span><br><span class="line"><span class="comment">    that interpretor created that the this keyword is referencing.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> User(<span class="string">'Tyler'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="词法绑定"><a href="#词法绑定" class="headerlink" title="词法绑定"></a>词法绑定</h4><p>所谓的词法绑定就是“你主观认为<code>this</code>的引用对象就是所绑定的对象”</p>
<p>例子如下，我们使用<code>reduce</code>函数，传入一个回调函数，这个回调函数中使用的<code>this</code>会引用哪个对象？当我们使用<code>function</code>定义时会创建<code>context</code>，<code>this</code>是引用的这个<code>context</code>，就如同下面的代码，这是有问题的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Tyler'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  languages: [<span class="string">'JavaScript'</span>, <span class="string">'Ruby'</span>, <span class="string">'Python'</span>],</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">const</span> hello = <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I know`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> langs = <span class="keyword">this</span>.languages.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">str, lang, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="keyword">this</span>.languages.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;str&#125;</span> and <span class="subst">$&#123;lang&#125;</span>.`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;str&#125;</span> <span class="subst">$&#123;lang&#125;</span>,`</span></span><br><span class="line">    &#125;, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    alert(hello + langs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.greet()<span class="comment">//Uncaught TypeError: Cannot read property 'length' of undefined.</span></span><br></pre></td></tr></table></figure>
<p><strong>然后，怎么解决？</strong><br>答案是使用箭头函数，箭头函数不会为<code>this</code>创建<code>context</code>，因此会引用外部的<code>context</code>，这是一个闭包。下面的代码就能正常工作了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Tyler'</span>,</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  languages: [<span class="string">'JavaScript'</span>, <span class="string">'Ruby'</span>, <span class="string">'Python'</span>],</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">const</span> hello = <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I know`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> langs = <span class="keyword">this</span>.languages.reduce(<span class="function">(<span class="params">str, lang, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="keyword">this</span>.languages.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;str&#125;</span> and <span class="subst">$&#123;lang&#125;</span>.`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;str&#125;</span> <span class="subst">$&#123;lang&#125;</span>,`</span></span><br><span class="line">    &#125;, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    alert(hello + langs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="window-绑定"><a href="#window-绑定" class="headerlink" title="window 绑定"></a>window 绑定</h4><p>当不满足前几种绑定时，那<code>this</code>就会绑定window（用于catch-all）。</p>
<p>如下代码，此情况<code>this</code>的引用对象就是window，因为window对象下没有age这个属性，所以undefined。如果定义了这个属性那就会输出这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Tyler'</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line">sayAge() <span class="comment">// My age is undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.age=<span class="number">27</span></span><br><span class="line">sayAge() <span class="comment">// My age is 27</span></span><br></pre></td></tr></table></figure>
<p>当然，如果你不想产生这种效果，不想让<code>this</code>绑定到window对象，那么你可以使用<code>use strict</code>声明来避免，window会认为<code>this</code>是undefined，如同下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.age = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge() <span class="comment">// TypeError: Cannot read property 'age' of undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="判断套路"><a href="#判断套路" class="headerlink" title="判断套路"></a>判断套路</h4><ol>
<li>检查函数要在哪里被调用</li>
<li><code>this</code>是否在箭头函数内部，如果是，那么<code>this</code>有可能词法绑定，引用父亲作用域的<code>this</code>（产生了闭包</li>
<li>函数是否使用了<code>new</code>创建对象，如果有，那么<code>this</code>引用这个创建的对象。</li>
<li>函数是否使用了<code>call,apply,bind</code>，如果有，那么<code>this</code>引用显示绑定的对象。</li>
<li>函数左侧有无“.”，如果有，那么<code>this</code>就引用这个对象。</li>
<li>你是否使用了<code>use strict</code>，如果有，那么<code>this</code>是<code>undefined</code></li>
<li><code>this</code>引用了<code>window</code>对象</li>
</ol>
<h2 id="相关话题"><a href="#相关话题" class="headerlink" title="相关话题"></a>相关话题</h2><h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><p>箭头函数没有在函数调用创建函数执行上下文的时候创建<code>this</code>对象。详情请看<a href="js-concept-7-scope-2.html">JavaScript 必知 33 个概念系列：执行上下文（栈帧）、作用域、闭包、this 之间的关系</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90eWxlcm1jZ2lubmlzLmNvbS90aGlzLWtleXdvcmQtY2FsbC1hcHBseS1iaW5kLWphdmFzY3JpcHQv" title="https://tylermcginnis.com/this-keyword-call-apply-bind-javascript/">Understanding the “this” keyword, call, apply, and bind in JavaScript<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：闭包</title>
    <url>/js-concept-21-closures.html</url>
    <content><![CDATA[<div class="note primary">
            <p>闭包是函数及其创建时保存的状态环境。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript中的闭包是区别于离散数学中的闭包。让我们仔细探讨一下JavaScript中的闭包吧。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><blockquote>
<p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.(MDN)</p>
</blockquote>
<p>也就是说，闭包是函数及其创建时保存的引用状态环境。</p>
<h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>例如<strong>Java</strong>允许定义私有方法，这样只允许类内的其他方法使用，无法通过类的实例访问。<br>有如下代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> privateCounter=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeBy</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.privateCounter+=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用JavaScript来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> counter = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 0</span></span><br><span class="line">counter.increment();</span><br><span class="line">counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 2</span></span><br><span class="line">counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 1</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包作用域链"><a href="#闭包作用域链" class="headerlink" title="闭包作用域链"></a>闭包作用域链</h3><p>关于作用域链可以查看以前的文章：<span class="exturl" data-url="aHR0cDovL2Jsb2cuc2NhcmJvcm91Z2hjb3JhbC50b3Bqcy1jb25jZXB0LTctc2NvcGUuaHRtbA==" title="http://blog.scarboroughcoral.topjs-concept-7-scope.html">JavaScript必知33个概念系列：作用域<i class="fa fa-external-link"></i></span></p>
<p>每个闭包的作用域分为三个：</p>
<ul>
<li>闭包自己的作用域</li>
<li>外部函数作用域</li>
<li>全局作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// global scope</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// outer functions scope</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// local scope</span></span><br><span class="line">        <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// log 20</span></span><br></pre></td></tr></table></figure>
<p>每个函数都能访问外部函数作用域和全局作用域，即每个函数都能够访问作用域链上游作用域的全部变量。</p>
<h3 id="闭包的典型错误问题：循环创建闭包"><a href="#闭包的典型错误问题：循环创建闭包" class="headerlink" title="闭包的典型错误问题：循环创建闭包"></a>闭包的典型错误问题：循环创建闭包</h3><p>如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"help"</span>&gt;</span>Helpful notes will appear here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure>
<p>以上执行结果就是总是弹出最后一项内容提示，因为<code>var</code>是函数作用域的，所有创建的闭包都是引用的同一个对象item。</p>
<p><strong>解决办法就是使用<code>let</code>或者是立即执行函数，<code>foreach</code>迭代也可以</strong></p>
<h3 id="闭包性能问题"><a href="#闭包性能问题" class="headerlink" title="闭包性能问题"></a>闭包性能问题</h3><ul>
<li>不必要的闭包会影响脚本效率，包括处理速度和内存消耗。</li>
</ul>
<p>比较下面两组代码：</p>
<figure class="highlight javascript"><figcaption><span>text1</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name.toString();</span><br><span class="line">  <span class="keyword">this</span>.message = message.toString();</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.getMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><figcaption><span>text2</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name.toString();</span><br><span class="line">  <span class="keyword">this</span>.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">MyObject.prototype.getMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>text1在构造函数内部创建了闭包，而且每次创建一个对象都会创建一个函数对象 。<br>text2使用原型定义函数，不同的对象只有一个函数对象副本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一些深入话题没有总结，目前水平还不够，to be continued。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9DbG9zdXJlcw==" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">Closures<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：作用域</title>
    <url>/js-concept-7-scope.html</url>
    <content><![CDATA[<div class="note primary">
            <p>函数作用域，块级作用域，词法作用域。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我对于作用域一直处于一种感性的认识，有问题也是凭感觉去看。今天就打破这面镜子，看看镜子后面到底是什么。</p>
<p>先说一下我现在的认知水平：<br>首先函数作用域我是知道的，函数体内部就是函数作用域；<br>然后块级作用域我大概知道，花括号内部？if、else、for这些？<br>最后词法作用域？没听过。。</p>
<p>接下来我们来探索一下这些术语（terminology）的语义吧。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域往往和变量挂钩，在谈作用域之前，我们先来看看声明变量的三种方法以及他们之间的区别。</p>
<h3 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p><strong>用<code>var</code>声明的对象是属于函数作用域（function scope）的，如果你不在函数作用域下声明，那这个变量就是<em>更高级函数作用域</em>或者全局的（global scope）。</strong></p>
<p>看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWidth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(width);</span><br><span class="line">&#125;</span><br><span class="line">width;</span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: width is not defined</span></span><br></pre></td></tr></table></figure>
<p>因为<code>width</code>是在函数作用域（<code>setWIdth</code>函数）下用<code>var</code>声明的，所以他属于函数作用域，因此全局作用域下访问不到<code>width</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">12</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> dogYears = age * <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`You are <span class="subst">$&#123;dogYears&#125;</span> dog years old!`</span>);</span><br><span class="line">&#125;</span><br><span class="line">dogYears;</span><br><span class="line"><span class="comment">// returns:</span></span><br><span class="line"><span class="number">700</span></span><br></pre></td></tr></table></figure>
<p>因为用<code>var</code>声明的变量<code>dogYears</code>不是在函数作用域下声明的，因此在本例中会当做全局作用域。</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><p><strong>用<code>let</code>和<code>const</code>声明的变量是属于块级作用域的，而不是函数作用域。</strong></p>
<p><strong>块级作用域就是大括号“{}”之间的部分。</strong></p>
<p>类似的下面这个例子，我用<code>let</code>代替<code>var</code>来声明<code>dogYears</code>变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">12</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> dogYears = age * <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`You are <span class="subst">$&#123;dogYears&#125;</span> dog years old!`</span>);</span><br><span class="line">&#125;</span><br><span class="line">dogYears;</span><br><span class="line"><span class="comment">// returns:</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: dogYears is not defined</span></span><br></pre></td></tr></table></figure>
<p>因为使用<code>let</code>定义<code>dogYears</code>变量，那么<code>dogYears</code>变量属于块级作用域，即if的作用域。</p>
<h3 id="函数作用域（function-scope）"><a href="#函数作用域（function-scope）" class="headerlink" title="函数作用域（function scope）"></a>函数作用域（function scope）</h3><blockquote>
<p>函数体内部叫函数作用域。</p>
</blockquote>
<ul>
<li>用<code>var</code>声明的对象是属于函数作用域（function scope）的，如果你不在函数作用域下声明，那这个变量就是<em>更高级函数作用域</em>或者全局的（global scope）</li>
</ul>
<h3 id="块级作用域（block-scope）"><a href="#块级作用域（block-scope）" class="headerlink" title="块级作用域（block scope）"></a>块级作用域（block scope）</h3><blockquote>
<p>大括号“{}”之间称为块级作用域，当然函数作用域也是块级作用域。</p>
</blockquote>
<ul>
<li>用<code>let</code>和<code>const</code>声明的变量是属于块级作用域的，而不是函数作用域。（<strong>实际上可以看做立即执行函数内部的<code>var</code></strong></li>
</ul>
<h3 id="词法作用域（lexical-scope）"><a href="#词法作用域（lexical-scope）" class="headerlink" title="词法作用域（lexical scope）"></a>词法作用域（lexical scope）</h3><blockquote>
<p>Variables in JavaScript are lexically scoped, so the static structure of a program determines the scope of a variable (it is not influenced by, say, where a function is called from).</p>
</blockquote>
<p>词法作用域就是可以通过源代码来看出哪个变量属于哪个作用域，不会根据函数被调用的上下文改变，词法和静态（static）可以看做是一样的。词法作用域根据声明变量的位置来确定该变量可被访问的位置。</p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Mozilla'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>
<p><code>displayName</code>中可以访问外部函数<code>makeFunc</code>的变量<code>name</code>，而<code>displayName</code>实际调用时<code>makeFunc</code>的栈帧已经弹出，此时却还能访问<code>name</code>。词法作用域是通过静态代码看的，和具体执行无关。这其实是闭包提供的作用。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote>
<p>当你在作用域S中访问父作用域的局部变量是可以的，而访问兄弟作用域的局部变量是不可以的。<strong>这可以通过作用域链来理解</strong></p>
</blockquote>
<ul>
<li>存在一个全局环境，里面存的是全局变量（函数）</li>
<li>环境里的函数条目会指向函数对象</li>
<li>函数对象通过内部的<code>[[Scope]]</code>属性来指向它的作用域</li>
<li>函数被调用时，会为此函数作用域创建一个环境，这个环境通过<code>outer</code>属性指向父环境</li>
<li>作用域会形成一条链</li>
</ul>
<p>如下图：</p>
<p><img src="/images/loading.gif" data-original="http://speakingjs.com/es5/images/spjs_2001.png" alt></p>
<p>函数执行栈是动态的，而作用域链可以看做静态的（或者说是词法的，Lexical）。</p>
<h2 id="相关话题"><a href="#相关话题" class="headerlink" title="相关话题"></a>相关话题</h2><h3 id="变量提升（变量声明提升，variables-declaration-hoisted）"><a href="#变量提升（变量声明提升，variables-declaration-hoisted）" class="headerlink" title="变量提升（变量声明提升，variables declaration hoisted）"></a>变量提升（变量声明提升，variables declaration hoisted）</h3><blockquote>
<p>JavaScript将变量的声明提升到该变量的直接作用域下的开始处，变量的赋值并不提升（执行上下文创建时已经为变量分配空间并赋值为<code>undefined</code>，这就好像是“变量提升”了）。函数定义也会进行提升，因此作用域下函数定义在前在后没多大区别。</p>
</blockquote>
<p><strong>仅对于<code>var</code>声明的变量进行提升，对<code>const</code>、<code>let</code>声明的变量不适用。</strong></p>
<p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);  <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">'abc'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);  <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>f()</code>的实现就好像如下定义一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);  <span class="comment">// undefined</span></span><br><span class="line">    bar = <span class="string">'abc'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);  <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于“var是函数作用域的”引起的问题和解决办法"><a href="#关于“var是函数作用域的”引起的问题和解决办法" class="headerlink" title="关于“var是函数作用域的”引起的问题和解决办法"></a>关于“<code>var</code>是函数作用域的”引起的问题和解决办法</h3><p>举个例子，如下代码，假如说你不想在if语句后面使用<code>tmp</code>变量或者说你有一个新的同名的<code>tmp</code>变量，那你如何解决这个问题呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = ...;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tmp still exists here</span></span><br><span class="line">    <span class="comment">// =&gt; not what we want</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一：使用<code>let</code>（因为<code>let</code>是块级作用域的</li>
<li>方法二：立即执行函数(<code>IIFE,Immediately Invoked Function Expression</code>)（利用<code>var</code>是函数作用域的，<code>ES5</code>时是一个常见的编程模式。<strong>但是效率比较低</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// open block</span></span><br><span class="line">            <span class="keyword">var</span> tmp = ...;</span><br><span class="line">            ...</span><br><span class="line">        &#125;());  <span class="comment">// close block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于“立即执行函数的问题”（立即执行函数表达式"><a href="#关于“立即执行函数的问题”（立即执行函数表达式" class="headerlink" title="关于“立即执行函数的问题”（立即执行函数表达式"></a>关于“立即执行函数的问题”（立即执行函数表达式</h3><h4 id="一个注意事项"><a href="#一个注意事项" class="headerlink" title="一个注意事项"></a>一个注意事项</h4><p>看个例子，如果第一个立即执行函数后面不加分号，那么第二个立即执行函数会当做参数。<strong>所以这种情况需要注意加分号</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;()) <span class="comment">// no semicolon</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h4 id="利用prefix-operators解决上述分号问题"><a href="#利用prefix-operators解决上述分号问题" class="headerlink" title="利用prefix operators解决上述分号问题"></a>利用<code>prefix operators</code>解决上述分号问题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// open IIFE</span></span><br><span class="line">    <span class="comment">// inside IIFE</span></span><br><span class="line">&#125;(); <span class="comment">// close IIFE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// open IIFE</span></span><br><span class="line">    <span class="comment">// inside IIFE</span></span><br><span class="line">&#125;(); <span class="comment">// close IIFE</span></span><br></pre></td></tr></table></figure>
<h4 id="如果函数定义已经处于一个表达式中，那么可以直接调用"><a href="#如果函数定义已经处于一个表达式中，那么可以直接调用" class="headerlink" title="如果函数定义已经处于一个表达式中，那么可以直接调用"></a>如果函数定义已经处于一个表达式中，那么可以直接调用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> File = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// open IIFE</span></span><br><span class="line">    <span class="keyword">var</span> UNTITLED = <span class="string">'Untitled'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">File</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name || UNTITLED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> File;</span><br><span class="line">&#125;(); <span class="comment">// close IIFE</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Bqb3NlcGhjYXJkaWxsby90aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLWZ1bmN0aW9uLWFuZC1ibG9jay1zY29wZS1pbi1qYXZhc2NyaXB0LTQyOTZiMjMyMmFiZQ==" title="https://medium.com/@josephcardillo/the-difference-between-function-and-block-scope-in-javascript-4296b2322abe">The Difference Between Function and Block Scope in JavaScript<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1HaE5BMHIxME1tQQ==" title="https://www.youtube.com/watch?v=GhNA0r10MmA">What the Heck is Lexical Scope? (JavaScript)<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3NwZWFraW5nanMuY29tL2VzNS9jaDE2Lmh0bWw=" title="http://speakingjs.com/es5/ch16.html">Chapter 16. Variables: Scopes, Environments, and Closures<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript必知33个概念系列：函数调用栈（执行上下文）</title>
    <url>/js-concept-1.html</url>
    <content><![CDATA[<div class="note primary">
            <p>JavaScript的执行上下文。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为看过CSAPP这本书，关于C语言的函数栈已经了解的比较透彻。实际上JavaScript的函数调用栈也是类似的。</p>
<p><img src="/images/loading.gif" data-original="/stackframe.png" alt></p>
<p>再来总结一下：</p>
<ul>
<li>一个函数被调用时，就会构造这个函数调用所需要的栈帧</li>
<li>栈帧内包含这个函数所使用的局部变量和函数调用结束后返回的地址。</li>
<li>函数调用结束后，该函数的栈帧会被弹出，即一些局部变量会失效。</li>
</ul>
<h2 id="JavaScript的函数调用栈（执行上下文）"><a href="#JavaScript的函数调用栈（执行上下文）" class="headerlink" title="JavaScript的函数调用栈（执行上下文）"></a>JavaScript的函数调用栈（执行上下文）</h2><p>一些关键点：</p>
<ol>
<li>JavaScript引擎是一个单线程解释器（是指针对单个JavaScript引擎线程来说，比如单个浏览器窗口），还包含堆和唯一的函数栈。</li>
<li>JavaScript代码从上向下执行（当然是同步代码），同一时刻只有一个函数在执行。</li>
<li>JavaScript异步代码（asynchronized code）的回调函数最终也会被时间循环加入到这个函数栈中来执行。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键的就是这么多，如果你想深入了解函数栈的机制，不仅仅是JavaScript，那推荐你去做CSAPP的<code>Bomb Lab</code>和<code>Attack Lab</code>。关键字搜“cmu cs213 csapp lab”。</p>
<p>我已经完成了这两个实验，<a href="http://blog.scarboroughcoral.top/tags/CSAPP-Lab/">链接</a></p>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>33 JS Concept</tag>
      </tags>
  </entry>
  <entry>
    <title>关于LeetCode题解</title>
    <url>/lc-solutions.html</url>
    <content><![CDATA[<div class="note primary">
            <p>LeetCode 小记的说明。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="LeetCode小记写在哪？"><a href="#LeetCode小记写在哪？" class="headerlink" title="LeetCode小记写在哪？"></a>LeetCode小记写在哪？</h2><p>如果一个题一篇文章的话感觉会很短小，而且会有很多文章，更新也不容易查看，所以我打算单独整一个页面总结这些知识点。</p>
<div class="note primary">
            <h3 id="笔者在GitHub新建了一个项目，使用docsify工具搭建："><a href="#笔者在GitHub新建了一个项目，使用docsify工具搭建：" class="headerlink" title="笔者在GitHub新建了一个项目，使用docsify工具搭建："></a>笔者在GitHub新建了一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvTm90ZXM=" title="https://github.com/ScarboroughCoral/Notes">项目<i class="fa fa-external-link"></i></span>，使用docsify工具搭建：</h3><p><span class="exturl" data-url="aHR0cDovL3NjYXJib3JvdWdoY29yYWwudG9wL05vdGVzLyMvbGM=" title="http://scarboroughcoral.top/Notes/#/lc">这是地址嘿嘿嘿<i class="fa fa-external-link"></i></span></p>
          </div>
<h2 id="会写什么"><a href="#会写什么" class="headerlink" title="会写什么"></a>会写什么</h2><p>由于时间比较有限，拿不出太长时间来特别详细的写，所以主要会写以下内容：</p>
<ul>
<li>思路关键点，简单题可能简单一提直接过。</li>
<li>题目复杂度分析</li>
<li>代码，可能并不是最优代码</li>
</ul>
<h2 id="不会写什么"><a href="#不会写什么" class="headerlink" title="不会写什么"></a>不会写什么</h2><ul>
<li>不会一步步详细写问题是怎么想出来的。</li>
<li>不会关联性的汇总一些相似的题目</li>
<li>等等，还有很多</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>A Tiny Shell——CSAPP之Shell Lab</title>
    <url>/csapp-lab-6.html</url>
    <content><![CDATA[<div class="note primary">
            <p>利用Linux信号实现一个简单的Shell。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很恶心，代码写完了，都过了。不过有的测试用例rtest卡了，认为是修改了，重下一遍，结果不小心覆盖了，git上传也不完整。。靠大脑cache来总结吧</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号类似于一种中断，或者可以称之为软件中断。先来总结一下关于异常控制流ECF（Exception Control Flow）的分类吧。</p>
<p>异常控制流，或者称之为异常，这是广义的异常，只要不是正常的逻辑控制流，就是异常。</p>
<p>异常分为同步异常和异步异常。异步异常就是中断（分为硬件中断和软件中断），同步异常就是狭义的异常（包括陷阱trap，错误fault，和终止abort）</p>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ol>
<li>同步的<ol>
<li>陷阱trap，有目的的。eg：system call</li>
<li>错误fault，无目的的，有可能恢复。eg：pagefault</li>
<li>终止abort，无目的的，不能恢复。eg：非法指令</li>
</ol>
</li>
<li>异步的<ol>
<li>硬件中断</li>
<li>软件中断<ol>
<li>信号</li>
<li>…</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="信号处理执行过程"><a href="#信号处理执行过程" class="headerlink" title="信号处理执行过程"></a>信号处理执行过程</h2><p>几个标志字：<br>pending：delivered信号，等待被处理<br>blocked：被阻塞的信号，可以加入到pending里，但不会被receive</p>
<p>信号处理分为几个阶段：</p>
<ol>
<li>deliver：放到pending里</li>
<li>receive：Handler处理</li>
</ol>
<p>信号处理过程：<br>假设内核已经从一个异常处理程序中返回并且要切换到进程P：</p>
<ol>
<li>内核计算进程P的信号状态：pending_unblocked_signals=pending&amp;~unblocked</li>
<li>如果pending_unblocked_signals为0则直接切换到进程P</li>
<li>如果不为0则就依次强制进程P处理信号，直到为0（信号处理可能被其他信号中断）</li>
</ol>
<h2 id="waitpid-pid-t-pid-int-statusp-int-options-函数详解"><a href="#waitpid-pid-t-pid-int-statusp-int-options-函数详解" class="headerlink" title="waitpid (pid_t pid, int *statusp, int options)函数详解"></a>waitpid (pid_t pid, int *statusp, int options)函数详解</h2><ol>
<li>pid&gt;0等待一个特定pid的进程，pid=-1，等待所有子进程，（还支持其他类型等待集合，比如Unix进程组，在此不做讨论）</li>
<li>status用于保存等待返回进程的状态</li>
<li>options有三个。WNOHANG——等待集合中没有进程终止则立即返回，WUNTRACED——挂起调用进程直到等待进程终止或停止，WCONTINUED——挂起调用进程直到等待进程终止或被停止的进程收到SIGCONT重新执行</li>
</ol>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><blockquote>
<p>写一下关键的地方吧。按照测试来写，具体能容可能由测试来展开。</p>
</blockquote>
<h3 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h3><p>CTRL+D退出，自带</p>
<h3 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h3><p>内置quit命令。<br>判断使用已定义好的builtin_cmd函数，匹配quit字符串返回1，不是内置则返回0<br>首先在eval函数里判断，如果是内置指令则单独执行，无需fork。单独执行时直接exit。</p>
<h3 id="test03"><a href="#test03" class="headerlink" title="test03"></a>test03</h3><p>运行一个前台进程。</p>
<p>这说明不是一个内置指令了，那就需要fork和execve</p>
<p>这时候需要注意几点：</p>
<ol>
<li>因为这时候要addjob，有可能会产生deletejob发生在addjob之前。所以要在exceve之前阻塞SIGCHLD信号来避免此问题发生。</li>
<li>利用parseline函数返回值来判断是前台还是后台，如果是前台，tsh需要挂起（<code>while(flag) suspend(&amp;mask)</code>）直到前台程序结束或停止。</li>
<li>判断前台程序结束使用一个标志位，在SIGCHLD Handler里waitpid时判断如果当前进程是fg的话就修改标志位<code>flag</code>。此时因为received一个SIGCHLD信号，<code>suspend()</code>函数会被触发结束挂起，此时发现循环条件不满足，这就取消挂起了。</li>
</ol>
<h3 id="test04"><a href="#test04" class="headerlink" title="test04"></a>test04</h3><p>运行一个后台进程。</p>
<p>与前台程序相反：</p>
<ol>
<li>通过parseline函数返回值判断是bg，则tsh无需挂起</li>
<li>与前台类似，exceve之前也要block SIGCHLD信号，并将job设为BG</li>
</ol>
<h3 id="test-05"><a href="#test-05" class="headerlink" title="test 05"></a>test 05</h3><p>运行多个后台进程，并使用jobs命令打印当前jobs</p>
<ol>
<li>jobs是个内置命令，在builtin_cmd函数里面匹配jobs字符串调用已经写好的listjobs函数并返回1</li>
</ol>
<h3 id="test06"><a href="#test06" class="headerlink" title="test06"></a>test06</h3><p>运行一个前台进程，发送一个SIGINT信号给此进程（按下CTRL+C</p>
<ol>
<li>首先需要tsh进程接受到SIGINT信号。tsh的SIGINT信号的处理程序源文件中已经给注册（signal）了，我们只需要填写完成信号处理函数就OK了</li>
<li>tsh接受到SIGINT信号，如果此时有前台进程则发送给前台进程及其后代进程（后续再说其后代进程的处理），发送使用kill函数，pid通过fgpid函数获得</li>
<li>此时前台进程会被SIGINT信号默认结束进程。这会deliver给tsh进程一个SIGCHLD信号，通过<code>WIFSIGNALED(status)</code>来判断此进程是否由信号终止的，status有waitpid获取（后续讲），这时就可以打印了，通过<code>WTERMSIG(status)</code>来获取引发终止的信号</li>
</ol>
<h3 id="test07"><a href="#test07" class="headerlink" title="test07"></a>test07</h3><p>确认只发送SIGINT信号给前台程序，因为我们通过fgpid获取的进程id，所以肯定是只发送信号给前台进程了。直接过</p>
<h3 id="test08"><a href="#test08" class="headerlink" title="test08"></a>test08</h3><p>发送一个SIGTSTP信号给前台程序。和SIGINT类似，不过有点区别</p>
<ol>
<li>tsh接受到SIGTSTP信号处理过程是一样的，发送给fgpid获取的进程。</li>
<li>SIGTSTP信号被子进程received之后，子进程默认停止。父进程被delivered一个SIGCHLD信号，在SIGCHLD Handler里需要使用<code>WIFSTOPPED(status)</code>函数来判断当前进程是否被停止，如果停止则设置state为ST，并打印。此时listjobs则会看到状态发生了改变</li>
</ol>
<h3 id="test09"><a href="#test09" class="headerlink" title="test09"></a>test09</h3><p>内置<code>bg %jid(or pid)</code>命令，作用是在后台运行一个已停止的进程。<br>和其他内置命令一样，不过需要额外解析jid或者pid，然后需要发送一个SIGCONT信号</p>
<ol>
<li>关于tsh进程发起<code>bg %jid</code>命令，tsh进程需要发送SIGCONT信号给对应的job进程，需要等待job进程接受到SIGCONT信号并开始执行，然后tsh进程SIGCHLD Handler处理。<blockquote>
<p>waitpid函数需要添加<strong>WCONTINUED</strong>的选项来拿到此进程。</p>
</blockquote>
</li>
<li>tsh在SIGCHLD Handler里需要将当前进程置为BG</li>
</ol>
<h3 id="test10"><a href="#test10" class="headerlink" title="test10"></a>test10</h3><p>内置<code>fg %jid(or pid)</code>命令，作用是在前台运行一个已停止的进程。</p>
<ol>
<li>和bg命令类似，需要解析jid和发送SIGCONT信号</li>
<li>fg需要将目标进程在前台执行，这就需要tsh进程挂起，和前台进程类似</li>
</ol>
<h3 id="test11"><a href="#test11" class="headerlink" title="test11"></a>test11</h3><p>发送SIGINT信号给前台进程组里的所有进程。</p>
<ol>
<li>默认情况下，fork的子进程是和父进程同一个进程组的，进程组由pgid唯一标识</li>
<li>前台进程组是由exceve执行的进程及其后代进程组成的，只需要对exceve进程设置gpid即可，通过<code>setgpid(pid,pgid)</code>函数来设置，pid=0则为当前进程设置，pgid=0则使用当前进程pid来作为pgid。我们使用当前进程pid作为pgid，后代进程和此进程是相同的pgid</li>
<li>使用kill(pid,signum)来发送信号，当pid&lt;0时则把pid的绝对值当做pgid，将signum对应的信号发送给pgid的所有进程中</li>
</ol>
<h3 id="test12"><a href="#test12" class="headerlink" title="test12"></a>test12</h3><p>发送SIGTSTP信号给前台进程组里的所有进程。和test11类似，不赘述</p>
<h3 id="test13"><a href="#test13" class="headerlink" title="test13"></a>test13</h3><p>发送SIGCONT信号给后台pid对应停止进程的进程组里的所有进程。和test11类似，不赘述</p>
<h3 id="test14"><a href="#test14" class="headerlink" title="test14"></a>test14</h3><p>简单错误处理，比如fg一个不存在的进程或进程组，或缺少参数。进行字符串匹配即可，不赘述。</p>
<h3 id="test15"><a href="#test15" class="headerlink" title="test15"></a>test15</h3><p>Putting it all together</p>
<p>这个出了点问题</p>
<ol>
<li><code>bg %1</code>没打印东西，而<code>jobs</code>命令后将<code>bg %1</code>的东西打印了。解决办法，输出缓冲区的内容没有输出到设备，使用fflush(stdout)函数。</li>
<li>tsh进程挂起标志位flag的设置，只需要在waitpid当前进程是FG进程并且停止<code>WIFSTOPPED(status)==1</code>或终止<code>WIFEXITED(status)==1</code>状态才结束挂起。</li>
</ol>
<h3 id="test16"><a href="#test16" class="headerlink" title="test16"></a>test16</h3><p>能够处理来自其他进程的信号，毫无疑问可以。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，结束了。本次实验主要是熟悉了信号的使用，包括如何定义信号处理函数，如何响应子进程状态的改变，如何同步信号引发的一些问题等。另外也大体了解了shell是个什么东西，6.828再见。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
        <tag>CSAPP Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>IEEE754实例——JS中的Number类型</title>
    <url>/ieee754-float-instance-js.html</url>
    <content><![CDATA[<div class="note primary">
            <p>用IEEE754标准具体看JS中的Number类型。</p>
          </div>
<a id="more"></a>
<hr>
<p>本文参考了MDN的js primitive type中的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9EYXRhX3N0cnVjdHVyZXMjUHJpbWl0aXZlX3ZhbHVlcw==" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Primitive_values">number type<i class="fa fa-external-link"></i></span>，想自己思考可以直接看。</p>
<p>首先JS使用的是64位IEEE754标准，根据标准，有1位符号位、11位指数和52位尾数。</p>
<p><img src="/images/loading.gif" data-original="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1571672841313&amp;di=e2e5d1348fca590fd1685521ca677dc6&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1405953990%2C784895530%26fm%3D214%26gp%3D0.jpg" alt="ieee754"></p>
<p>JS的Number type给定范围是($-(2^{53}-1),2^{53}-1$)，当然给定的是安全的整数范围。</p>
<p>让我们来看看为什么是这个范围。</p>
<p>根据IEEE754规定，对于规格化数，存储时省略了小数点前面的1，所以可以精确表示的范围是首位是1然后52个0，到首位是1然后52个1（此时指数值应该为52，暂不考虑偏移）；然后将指数值化为更小的指数，并且尾数越界部分置0，此时可假设尾数后移一位，这样可看做表示数的范围是从首位是0然后52个0，到首位是0然后52个1。</p>
<p>因此表示的范围就是如此。</p>
<p>JS中有两个常量<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>给出的正是能够安全表示的上下界。也有一个函数<code>Number.isSafeInteger()</code>用于判断某个数是否安全。对于这个界限之外的无法精确表示的只能粗略表示，<strong>毕竟尾数不够了</strong>。</p>
<p>对于在安全表示界限数之外的，JS给出了解决方案，即使用BigInt类型，可以使用构造函数创建实例或者加后缀n。<br>比如<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> big=<span class="number">2n</span>**<span class="number">70n</span>;<span class="comment">//1180591620717411303424n</span></span><br></pre></td></tr></table></figure></p>
<p>+/-Infinity和NaN表示也如同IEEE754标准一样，指数部分全1（考虑偏移）：尾数部分全0则Infinity，正负看符号；尾数部分非全0则NaN。</p>
<p>另外，JS也有两个常数表示能够表示的最大和最小数：<code>Number.MAX_VALUE</code>和<code>Number.MIN_VALUE</code>。其中最大数是比Infinity小点的数，它的二进制表示是指数除了最低一位是0其他全1，尾数全1；最小数则是最接近0的数，即指数全0（考虑偏移），尾数最低位为1其他全0，计算结果如图，偏移在上次<a href="float-think.html">浮点数博客</a>中讲过，即$\lfloor\frac{2^{EMax}-1}{2}\rfloor$，比如11位指数，中间数就是$\lfloor\frac{2^{11}-1}{2}\rfloor=1023$。。</p>
<p><img src="/images/loading.gif" data-original="/ieee754-float-instance-js/754-js.png" alt></p>
]]></content>
      <categories>
        <category>Front-End Development</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>A Cache Simulator——CSAPP 之 Cache Lab</title>
    <url>/csapp-lab-5.html</url>
    <content><![CDATA[<div class="note primary">
            <p>以软件的方式实现Cache。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/images/loading.gif" data-original="/csapp-lab-5/cache-simulator.png" alt="cache lab result"></p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>实现一个Cache模拟器。</p>
<div class="note info no-icon">
            <ol><li>输入：<ol><li>指定组数量</li><li>指定组内行数量</li><li>指定行内块大小</li><li>指定访存文件</li></ol></li><li>输出：<ol><li>命中数</li><li>未命中数</li><li>驱逐数</li></ol></li><li>算法：<ol><li>驱逐使用LRU算法</li></ol></li></ol>
          </div>
<p>其中，访存文件如下所示：</p>
<figure class="highlight bash"><figcaption><span>part of trans.trace</span></figcaption><table><tr><td class="code"><pre><span class="line">I  00400570,3</span><br><span class="line"> S 00600a98,4</span><br><span class="line">I  00400573,4</span><br><span class="line"> M 7ff000388,4</span><br><span class="line">I  00400577,4</span><br><span class="line"> L 7ff000388,4</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>Cache Line 数据结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid; <span class="comment">//valid bit</span></span><br><span class="line">    <span class="comment">// bool dirty;                   //if modified before</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tag;            <span class="comment">//tag bit for identifying the line in the group</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> last_used_time; <span class="comment">//last used time for LRU algorithm detection</span></span><br><span class="line">    <span class="comment">//data</span></span><br><span class="line"></span><br><span class="line">&#125; Line;</span><br></pre></td></tr></table></figure>
<ul>
<li>LRU驱逐算法：</li>
</ul>
<p>每行指定一个上次使用时间（<code>last_used_time</code>），当某次访存出现miss并且组内无空余行时，比较上次使用时间最早的行并驱逐。</p>
<ul>
<li>整体算法：</li>
</ul>
<div class="note info no-icon">
            <ol><li>获取参数：s、E、b、t</li><li>给cache分配内存</li><li>读取文件</li><li>解析每一行：<ol><li>获取非指令访存，获取访存地址，解析组索引、块偏移</li><li>Load、Store一次访存，Modify两次访存</li><li>每次访存查找Cache：<ol><li>找到内存块对应组</li><li>找组内是否有相同的标记，如果有则hit，结束查找；否则miss并下一步</li><li>找组内是否有空行，如果有则结束查找；否则需要eviction并下一步</li><li>找到组内上次使用时间最早的并驱逐，结束查找</li></ol></li></ol></li></ol>
          </div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><figcaption><span>csim.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cachelab.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> v_mode = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>, E = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *file = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// statistics number</span></span><br><span class="line"><span class="keyword">unsigned</span> hit_count = <span class="number">0</span>, miss_count = <span class="number">0</span>, eviction_count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOpt</span><span class="params">(<span class="keyword">bool</span> *v_mode, <span class="keyword">int</span> *s, <span class="keyword">int</span> *E, <span class="keyword">int</span> *b, <span class="keyword">char</span> **file, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid; <span class="comment">//valid bit</span></span><br><span class="line">    <span class="comment">// bool dirty;                   //if modified before</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tag;            <span class="comment">//tag bit for identifying the line in the group</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> last_used_time; <span class="comment">//last used time for LRU algorithm detection</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//data</span></span><br><span class="line"></span><br><span class="line">&#125; Line;</span><br><span class="line"></span><br><span class="line">Line **cache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load options</span></span><br><span class="line">    getOpt(&amp;v_mode, &amp;s, &amp;E, &amp;b, &amp;file, argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf("%d %d %d %d %s %d\n", v_mode, s, E, b, file, (-(1U)) &gt;&gt; 28);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// open the trace file</span></span><br><span class="line">    FILE *trace_file = fopen(file, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc the cache</span></span><br><span class="line">    <span class="keyword">int</span> S = <span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    cache = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line *) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line) * E);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the cache line</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[i][j].last_used_time = <span class="number">0</span>;</span><br><span class="line">            cache[i][j].tag = <span class="number">0</span>;</span><br><span class="line">            cache[i][j].valid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the trace file &amp; resolve it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="number">64</span>, trace_file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(buffer, <span class="string">" %c %lx,%d"</span>, &amp;type, &amp;addr, &amp;m_size);</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            access(addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">            access(addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">            access(addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the memory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache[i]);</span><br><span class="line">        cache[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">    cache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the trace file</span></span><br><span class="line">    fclose(trace_file);</span><br><span class="line"></span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the position</span></span><br><span class="line">    <span class="keyword">int</span> group = (address &gt;&gt; b)&amp;((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> tag = address &gt;&gt; (b + s);</span><br><span class="line">    <span class="comment">// int bias = address &amp; ((1 &lt;&lt; b) - 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// search for the tag</span></span><br><span class="line">    <span class="comment">// hit?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[group][i].tag == tag &amp;&amp; cache[group][i].valid == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hit_count++;</span><br><span class="line">            cache[group][i].last_used_time=++time;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// miss and any empty</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[group][i].valid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[group][i].valid = <span class="number">1</span>;</span><br><span class="line">            cache[group][i].last_used_time = ++time;</span><br><span class="line">            cache[group][i].tag = tag;</span><br><span class="line">            miss_count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// miss and no empty</span></span><br><span class="line">    eviction_count++;</span><br><span class="line">    miss_count++;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lru_time = <span class="number">-1U</span>L;</span><br><span class="line">    <span class="keyword">unsigned</span> line_index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[group][i].last_used_time &lt; lru_time)</span><br><span class="line">        &#123;</span><br><span class="line">            lru_time=cache[group][i].last_used_time;</span><br><span class="line">            line_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache[group][line_index].last_used_time=++time;</span><br><span class="line">    cache[group][line_index].tag=tag;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOpt</span><span class="params">(<span class="keyword">bool</span> *v_mode, <span class="keyword">int</span> *s, <span class="keyword">int</span> *E, <span class="keyword">int</span> *b, <span class="keyword">char</span> **file, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">"v::s:E:b:t:ma"</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">            *v_mode = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            *s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">            *E = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">            *b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            *file = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n\</span></span><br><span class="line"><span class="string">Options:\n\</span></span><br><span class="line"><span class="string">  -h         Print this help message.\n\</span></span><br><span class="line"><span class="string">  -v         Optional verbose flag.\n\</span></span><br><span class="line"><span class="string">  -s &lt;num&gt;   Number of set index bits.\n\</span></span><br><span class="line"><span class="string">  -E &lt;num&gt;   Number of lines per set.\n\</span></span><br><span class="line"><span class="string">  -b &lt;num&gt;   Number of block offset bits.\n\</span></span><br><span class="line"><span class="string">  -t &lt;file&gt;  Trace file.\n\</span></span><br><span class="line"><span class="string">\n\</span></span><br><span class="line"><span class="string">Examples:\n\</span></span><br><span class="line"><span class="string">  linux&gt;  %s -s 4 -E 1 -b 4 -t traces/yi.trace\n\</span></span><br><span class="line"><span class="string">  linux&gt;  %s -v -s 8 -E 2 -b 4 -t traces/yi.trace\n"</span>,</span><br><span class="line">                    argv[<span class="number">0</span>], argv[<span class="number">0</span>], argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
        <tag>CSAPP Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>丧心病狂的洗澡方式</title>
    <url>/bathing-thinking.html</url>
    <content><![CDATA[<div class="note primary">
            <p>少一点功利主义的追求，多一点不为什么的坚持。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我感觉我快疯了。去洗澡的时候都会想问题想的出神。</p>
<p>事情是这样的。某日，我去洗澡，因为正直小学期，正是炎热的时候，晚上洗澡的人特别多，于是排起了长长的队伍。然后我就想到了高并发问题，于是就刹不住车了，引起对计算机的一片思考，下文的思考是经过大学这几年沉淀下来的东西加上自己读的一些课外计算机读物所得的。</p>
<h2 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h2><p>澡堂外排起了长长的队伍，这让我首先想到的是高并发，这就像是双十一和六一八一样，澡堂就好比淘宝和京东的服务器，洗澡的人就是买家用户。</p>
<p>因为我们知道可以排队可以按照顺序来使自己洗澡，如果中途走了就得重新排队。这就像那些有高并发问题的<strong>消息中间件</strong>，消息都需要排队，如果消息队列满了那剩下的就丢了。</p>
<p>为什么会引起排队呢？有两点：一是澡堂可用的淋浴喷头太少，二是人们洗澡的时间太长。</p>
<p>那么解决办法就从这两点出发，即增加淋浴喷头或者提高人们洗澡的效率。</p>
<p>增加淋浴喷头很简单了，没有下文了，只能多修几个淋浴喷头来增加澡堂内同时洗澡的人数。这就像<strong>服务器的横向扩展</strong>，增加服务器的数量。</p>
<p>提高人们洗澡的效率就值得深究了，嘿嘿嘿。这也就是<strong>服务器的纵向扩展</strong>，提高服务器的性能。</p>
<p>那么怎么提高人们洗澡的效率，提高服务器的性能呢？</p>
<p>想象一下，怎么让人洗澡洗的快呢？</p>
<p>其一，使用先进的淋浴喷头，水大、温度调节能力好；人们使用方便的沐浴露、浴巾。这就像制造<strong>集成电路</strong>需要好的材料一般。</p>
<p>其二，分阶段加流水线操作。一个人正在涂抹洗发水或沐浴露的时候，淋浴喷头闲置，这是一用浪费，这时候应该让另一个人来冲洗。这就像<strong>CPU的分阶段流水线的指令处理</strong>。</p>
<p>其三，一个淋浴喷头上产生一个分叉，分出两个喷头来，一个水温适中偏凉适合洗头，一个水温适中偏热适合洗身体，可以减少调节水温的时间。这有点像服务器的横向扩展，不过不是，这是服务器内部性能的提高。</p>
<p>其四，排队队头处于澡堂内部。这样排队的队头的人可以看到澡堂内有人洗完了，可以快速加入洗澡人员的行列。这就像<strong>高速缓存</strong>，总比访问内存快一点。</p>
<p>其五，洗澡洗累了不能占用淋浴喷头，搓背搓得手酸了，这时候自己需要待在一旁休息，需要将淋浴喷头让与他人使用。这就像<strong>进程被异常中断</strong>挂起后保存自己的进程信息转而执行其他进程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然这种洗澡方式有点不人性了，甚至有点丧心病狂。不过就这样吧，将就着用吧，关于衣柜的<strong>加锁</strong>和<strong>解锁</strong>问题还没有涉及，以后有空再写。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>Prose and Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘检测</title>
    <url>/bmp-edge-dection.html</url>
    <content><![CDATA[<div class="note primary">
            <p>变化的变化率，用于描述变化的变化速度和方向。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="Forword"><a href="#Forword" class="headerlink" title="Forword"></a>Forword</h2><p>很长时间不写博客了，图像处理实验开始整体验收了，这两天爆肝，在做实验的同时认真写博客总结。确实感觉这门课学得不好（实际上感觉大学所有的课都学的不好，逃……），主要是因为数学知识不够牢固，而且一般的数学证明思维也忘得差不多了。</p>
<p>本系列文章（DIP，Digital Image Processing），用于记录总结数字图像处理课程的实验内容。目录请参考<a href="/tags/DIP/">DIP系列文章</a>。</p>
<div class="note warning no-icon">
            <p><strong>本次不展示代码，全部代码请查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">GitHub<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>这次实验内容是边缘检测，一开始的时候做了一部分了，是针对<code>prewitt</code>算子和<code>sobel</code>算子的，剩下<code>log</code>和<code>canny</code>方法还没做，canny选做。</p>
<ul>
<li>使用Prewitt算子实现边缘检测</li>
<li>使用Sobel算子实现边缘检测</li>
<li>使用LOG算子实现边缘检测</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><blockquote>
<p>用于检测图像中一些物体边缘的地方。比如无人机、自动驾驶障碍物检测等会使用到。</p>
</blockquote>
<p>主要方法有以下几种：</p>
<h3 id="Prewitt"><a href="#Prewitt" class="headerlink" title="Prewitt"></a>Prewitt</h3><blockquote>
<p>引入了平均因素，对噪声有抑制作用；操作简便。</p>
</blockquote>
<ul>
<li>垂直边缘检测算子</li>
</ul>
<p>$$<br>     \begin{bmatrix}<br>       -1&amp;0&amp;1\\<br>       -1&amp;0&amp;1\\<br>       -1&amp;0&amp;1<br>     \end{bmatrix}<br>$$</p>
<ul>
<li>水平边缘检测算子</li>
</ul>
<p>$$<br>       \begin{bmatrix}<br>         -1&amp;-1&amp;-1\\<br>         0&amp;0&amp;0\\<br>         1&amp;1&amp;1<br>       \end{bmatrix}<br>$$</p>
<h3 id="Sobel"><a href="#Sobel" class="headerlink" title="Sobel"></a>Sobel</h3><blockquote>
<p>引入了平均因素，增强了最近像素的影像，噪声抑制效果比Prewitt好。</p>
</blockquote>
<ul>
<li>垂直边缘检测算子</li>
</ul>
<p>$$<br>        \begin{bmatrix}<br>         -1&amp;0&amp;1\\<br>         -2&amp;0&amp;2\\<br>         -1&amp;0&amp;1<br>       \end{bmatrix}<br>$$</p>
<ul>
<li>水平边缘检测算子</li>
</ul>
<p>$$<br>        \begin{bmatrix}<br>         -1&amp;-2&amp;-1\\<br>         0&amp;0&amp;0\\<br>         1&amp;2&amp;1<br>       \end{bmatrix}<br>$$</p>
<h3 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h3><blockquote>
<p>该算子首先用高斯函数对图像作平滑滤波处理，然后才使用Laplacian算子检测边缘，因此克服了Laplacian算子抗噪声能力比较差的缺点，但是在抑制噪声的同时也可能将原有的比较尖锐的边缘也平滑掉了，造成这些尖锐边缘无法检被测到。</p>
</blockquote>
<p>$$<br>\begin{bmatrix}<br>    0&amp;0&amp;-1&amp;0&amp;0\\<br>    0&amp;-1&amp;-2&amp;-1&amp;0\\<br>    -1&amp;-2&amp;16&amp;-2&amp;-1\\<br>    0&amp;-1&amp;-2&amp;-1&amp;0\\<br>    0&amp;0&amp;-1&amp;0&amp;0<br>\end{bmatrix}<br>$$</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul>
<li>原图</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bmp-edge-dection/3-3.png" alt="3-3"></p>
<ul>
<li>Prewitt横纵叠加</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bmp-edge-dection/3-prewit.png" alt="3-prewit"></p>
<ul>
<li>Sobel纵横叠加</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bmp-edge-dection/3-sobel.png" alt="3-sobel"></p>
<ul>
<li>Log算子</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bmp-edge-dection/3-log.png" alt="3-log"></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>找儿子——《辐射4》：游戏评测日志</title>
    <url>/fallout4.html</url>
    <content><![CDATA[<div class="note primary">
            <p>一刷，很多姿势没有解锁。</p>
          </div>
<a id="more"></a>
<hr>
<div class="note info">
            <p>英文名：Fallout 4。</p><h3 id="Steam简介："><a href="#Steam简介：" class="headerlink" title="Steam简介："></a>Steam简介：</h3><p>Bethesda Game Studios, the award-winning creators of Fallout 3 and The Elder Scrolls V: Skyrim, welcome you to the world of Fallout 4 – their most ambitious game ever, and the next generation of open-world gaming.</p>
          </div>
<h3 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h3><p>3D 建模非常的真实，如同<code>给她爱five——GTA5</code>一般。从现代化城市到一片废墟，从普通人物、动物到变种人、变种动物和人造人，各种天气，各种手持兵器、枪支和机甲，还有各种建筑，这些建模都是非常出色的。</p>
<p><img src="/images/loading.gif" data-original="/fallout4/ScreenShot1.png" alt="ScreenShot1"></p>
<p>^图1: 某海湾旁边</p>
<p><img src="/images/loading.gif" data-original="/fallout4/ScreenShot2.png" alt="ScreenShot2"></p>
<p>^图2: 某人记忆探索</p>
<h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p>辐射4的故事背景烘托的很浓厚——2200年的美国。一开始一家人其乐融融，漂亮的妻子、1岁的儿子还有一个智能机器人快乐的生活着。不过好景不长，全国辐射危机即将爆发战争，一家人鉴定契约到某地下庇护所冰冻逃脱战争。然而这个过程并不顺利，人有旦夕祸福，天有不测风云，冰冻其间妻子被枪击中，儿子被劫，被冰冻的自己只有意识却无法挽救。主线剧情也由此揭开——找儿子！不过有一点比较捞，妻子死没死不知道就直接找儿子去了。其间围绕找儿子展开了一系列剧情，其间接触了一些势力，这些势力之间或者合作或者敌对。</p>
<p><img src="/images/loading.gif" data-original="/fallout4/ScreenShot3.png" alt="ScreenShot3"><br>^图3: 找到的儿子</p>
<h3 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h3><p>整体上来看是个大型<strong>FPS</strong>游戏，其中掺杂着<strong>RPG</strong>元素、建造基地的<strong>沙盒</strong>元素、朋友亲密度<strong>模拟养成</strong>元素等。游戏地图非常大，可以在不同已到达地区之间传送。开局一人一狗，中途也可以和<strong>NPC一起刷图</strong>，你的言行举止会影响和NPC的<strong>亲密度</strong>。自己可以对自己的基地进行建造各种设施。使用各种物品有可能受辐射影响造成<strong>最大生命值</strong>的减少。人物升级可以升级技能，这决定着你是向<strong>近战、步枪、狙击、管理</strong>等方向发展。</p>
<p><img src="/images/loading.gif" data-original="/fallout4/ScreenShot4.png" alt="ScreenShot4"><br>^图4: 基地建造</p>
<p><img src="/images/loading.gif" data-original="/fallout4/ScreenShot0.png" alt="ScreenShot0"><br>^图5: 一人一狗</p>
<h3 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h3><p>这个游戏难度还是比较大的（本人比较菜），可能是本人比较懒，所以没有体验一百种死法，后期直接开启了GOD模式。这是第一款Steam上入坑的RMB游，所以算是比较有感情吧。</p>
]]></content>
      <categories>
        <category>Game Review</category>
        <category>FPS</category>
      </categories>
      <tags>
        <tag>FPS</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 之 Arch Lab</title>
    <url>/csapp-lab-4.html</url>
    <content><![CDATA[<div class="note primary">
            <p>《深入理解计算机系统》之Architecture Lab。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次实验主要是对第四章处理器体系结构的测验，还有一部分第五章的内容。</p>
<h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28786838&auto=1&height=66"></iframe>


<h2 id="CSAPP-实验记录"><a href="#CSAPP-实验记录" class="headerlink" title="CSAPP 实验记录"></a>CSAPP 实验记录</h2><div class="note info">
            <p><strong><a href="/tags/CSAPP-Lab/">本系列文章</a>主要记录 CSAPP 3.0 的实验过程，所有实验记录文章请查看<a href="/tags/CSAPP-Lab/">这儿</a></strong></p>
          </div>
<p>快速开始请访问 <code>CSAPP</code> <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvM2UvbGFicy5odG1s" title="http://csapp.cs.cmu.edu/3e/labs.html">Lab<i class="fa fa-external-link"></i></span> 官网，本次实验记录是基于 CSAPP 3.0，实验日期始于：<code>2019-4-1</code></p>
<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>实验分为三部分，第一部分很简单，就是简单地考察一下汇编；第二部分是在hcl文件中添加iaddq指令的逻辑；第三部分是修改hcl和ncopy汇编文件使内存元素复制的速度尽可能达到最快。</p>
<h3 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h3><div class="note info no-icon">
            <p>目标：使用Y86-64汇编程序实现以下三个函数：</p>
          </div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Architecture Lab: Part A </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * High level specs for the functions that the students will rewrite</span></span><br><span class="line"><span class="comment"> * in Y86-64 assembly language</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin examples */</span></span><br><span class="line"><span class="comment">/* linked list element */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ELE</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *list_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum_list</span><span class="params">(list_ptr ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">	val += ls-&gt;val;</span><br><span class="line">	ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rsum_list - Recursive version of sum_list */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rsum_list</span><span class="params">(list_ptr ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ls)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">long</span> val = ls-&gt;val;</span><br><span class="line">	<span class="keyword">long</span> rest = rsum_list(ls-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> val + rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copy_block</span><span class="params">(<span class="keyword">long</span> *src, <span class="keyword">long</span> *dest, <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">long</span> val = *src++;</span><br><span class="line">	*dest++ = val;</span><br><span class="line">	result ^= val;</span><br><span class="line">	len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end examples */</span></span><br></pre></td></tr></table></figure>
<h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><div class="note info no-icon">
            <p>在hcl文件中添加iaddq指令的逻辑。</p>
          </div>
<h3 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h3><div class="note info no-icon">
            <p>修改hcl和ncopy汇编文件使内存元素复制的速度尽可能达到最快，即CPE（cycles per element）越来越小。</p><ul><li>修改hcl内容首先要添加iaddq的实现</li><li>降低CPI，即处理ret、jmp预测、加载使用冒险。ret没必要处理。</li><li>程序性能优化（3e第五章）</li></ul>
          </div>
<h2 id="实验前的归纳"><a href="#实验前的归纳" class="headerlink" title="实验前的归纳"></a>实验前的归纳</h2><p>概括一下这次实验用到的知识点。</p>
<p>首先是汇编相关的内容，通过第三章的学习，part A直接上手完成是没有问题的。<br>其次是hcl逻辑块的实现，这就需要对SEQ以及PIPE的实现及ISA有一定的了解。</p>
<h2 id="Arch-Lab"><a href="#Arch-Lab" class="headerlink" title="Arch Lab"></a>Arch Lab</h2><p>正式开始记录实验，Part C由于第五章内容还没有了解完全，所以准备后期二刷Part C。</p>
<h3 id="Part-A-1"><a href="#Part-A-1" class="headerlink" title="Part A"></a>Part A</h3><p>这一部分凭借汇编基础即可完成。不过还需要注意一下汇编的一些伪指令和格式问题。</p>
<ul>
<li>sum_list</li>
</ul>
<figure class="highlight x86asm"><figcaption><span>文件名：archlab/archlab-handout/sim/misc/sum.ys</span></figcaption><table><tr><td class="code"><pre><span class="line"># sum_list function coded by scarborough_coral</span><br><span class="line"></span><br><span class="line"><span class="meta">.pos</span> <span class="number">0</span></span><br><span class="line">	irmovq stack,%rsp</span><br><span class="line">	<span class="keyword">call</span> main</span><br><span class="line">	halt</span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line"><span class="meta">.align</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">ele1:</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0x00a</span></span><br><span class="line"><span class="meta">.quad</span> ele2</span><br><span class="line"><span class="symbol">ele2:</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0x0b0</span></span><br><span class="line"><span class="meta">.quad</span> ele3</span><br><span class="line"><span class="symbol">ele3:</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0xc00</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sum_list:</span></span><br><span class="line">	xorq %rax,%rax</span><br><span class="line">	</span><br><span class="line"><span class="symbol">loop_start:</span></span><br><span class="line">	andq %rdi,%rdi</span><br><span class="line">	<span class="keyword">je</span> loop_end</span><br><span class="line"></span><br><span class="line">	mrmovq <span class="number">0</span>(%rdi),%rsi</span><br><span class="line">	addq %rsi,%rax</span><br><span class="line">	mrmovq <span class="number">8</span>(%rdi),%rsi</span><br><span class="line">	rrmovq %rsi,%rdi	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">jmp</span> loop_start</span><br><span class="line"></span><br><span class="line"><span class="symbol">loop_end:</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">	irmovq ele1,%rdi</span><br><span class="line">	<span class="keyword">call</span> sum_list</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.pos</span> <span class="number">1024</span></span><br><span class="line"><span class="symbol">stack:</span></span><br></pre></td></tr></table></figure>
<ul>
<li>rsum_list</li>
</ul>
<figure class="highlight x86asm"><figcaption><span>文件名：archlab/archlab-handout/sim/misc/rsum.ys</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">.pos</span> <span class="number">0</span></span><br><span class="line">	irmovq stack,%rsp</span><br><span class="line">	<span class="keyword">call</span> main</span><br><span class="line">	halt</span><br><span class="line"></span><br><span class="line"><span class="meta">.align</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">ele1:</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0x00a</span></span><br><span class="line"><span class="meta">.quad</span> ele2</span><br><span class="line"><span class="symbol">ele2:</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0x0b0</span></span><br><span class="line"><span class="meta">.quad</span> ele3</span><br><span class="line"><span class="symbol">ele3:</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0xc00</span></span><br><span class="line"><span class="meta">.quad</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">rsum_list:</span></span><br><span class="line">	xorq %rax,%rax</span><br><span class="line">	andq %rdi,%rdi</span><br><span class="line">	<span class="keyword">jne</span> not_null</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="symbol">not_null:</span></span><br><span class="line">	mrmovq <span class="number">0</span>(%rdi),%rsi</span><br><span class="line">	pushq %rsi</span><br><span class="line">	mrmovq <span class="number">8</span>(%rdi),%rdi</span><br><span class="line">	<span class="keyword">call</span> rsum_list</span><br><span class="line">	popq %rsi</span><br><span class="line">	addq %rsi,%rax</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">	irmovq ele1,%rdi</span><br><span class="line">	<span class="keyword">call</span> rsum_list</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.pos</span> <span class="number">1024</span></span><br><span class="line"><span class="symbol">stack:</span></span><br></pre></td></tr></table></figure>
<ul>
<li>copy_block</li>
</ul>
<figure class="highlight x86asm"><figcaption><span>文件名：archlab/archlab-handout/sim/misc/copy.ys</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">.pos</span> <span class="number">0</span></span><br><span class="line">	irmovq stack,%rsp</span><br><span class="line">	<span class="keyword">call</span> main</span><br><span class="line">	halt</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.align</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">src:</span></span><br><span class="line"><span class="meta">	.quad</span> <span class="number">0x00a</span></span><br><span class="line"><span class="meta">	.quad</span> <span class="number">0x0b0</span></span><br><span class="line"><span class="meta">	.quad</span> <span class="number">0xc00</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">dest:</span></span><br><span class="line"><span class="meta">	.quad</span> <span class="number">0x111</span></span><br><span class="line"><span class="meta">	.quad</span> <span class="number">0x222</span></span><br><span class="line"><span class="meta">	.quad</span> <span class="number">0x333</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">copy_block:</span></span><br><span class="line">	xorq %rax,%rax</span><br><span class="line">	pushq %r12</span><br><span class="line">	pushq %r13</span><br><span class="line">	irmovq <span class="number">$1</span>,%r13</span><br><span class="line">	irmovq <span class="number">$8</span>,%r12</span><br><span class="line"><span class="symbol">loop_start:</span>	</span><br><span class="line">	andq %rdx,%rdx</span><br><span class="line">	<span class="keyword">je</span> loop_end</span><br><span class="line">	mrmovq (%rdi),%rcx</span><br><span class="line">	rmmovq %rcx,(%rsi)</span><br><span class="line">	addq %r12,%rdi</span><br><span class="line">	addq %r12,%rsi</span><br><span class="line">	xorq %rcx,%rax</span><br><span class="line">	subq %r13,%rdx</span><br><span class="line">	<span class="keyword">jmp</span> loop_start</span><br><span class="line"><span class="symbol">loop_end:</span></span><br><span class="line">	popq %r12</span><br><span class="line">	popq %r13</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">	irmovq src,%rdi</span><br><span class="line">	irmovq dest,%rsi</span><br><span class="line">	irmovq <span class="number">$3</span>,%rdx</span><br><span class="line">	<span class="keyword">call</span> copy_block</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">.pos</span> <span class="number">1024</span></span><br><span class="line"><span class="symbol">stack:</span></span><br></pre></td></tr></table></figure>
<h3 id="Part-B-1"><a href="#Part-B-1" class="headerlink" title="Part B"></a>Part B</h3><p>Part B 只需要按照writeup查看3e课本iaddq指令的阶段实现即可实现。</p>
<div class="note danger">
            <ol><li>可能会遇到找不到依赖库的问题，安装就行了</li><li>中途遇见了一个链接问题，是因为glibc版本太新，实验依赖的版本太过老旧导致一个<code>matherr</code>找不到问题，观察代码其他地方并没有用到，直接omit注释掉了。</li></ol>
          </div>
<p>修改内容如下图：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-4/seq.jpg" alt></p>
<p>hcl代码如下：</p>
<figure class="highlight vhdl"><figcaption><span>文件名：archlab/archlab-handout/sim/seq/seq-full.hcl</span></figcaption><table><tr><td class="code"><pre><span class="line">#<span class="comment">/* $begin seq-all-hcl */</span></span><br><span class="line">####################################################################</span><br><span class="line">#  HCL Description <span class="keyword">of</span> Control <span class="keyword">for</span> Single Cycle Y86-<span class="number">64</span> Processor SEQ   #</span><br><span class="line">#  Copyright (C) Randal E. Bryant, David R. O<span class="symbol">'Hallaron</span>, <span class="number">2010</span>       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">## Your task <span class="keyword">is</span> <span class="keyword">to</span> implement the iaddq instruction</span><br><span class="line">## The <span class="keyword">file</span> contains a declaration <span class="keyword">of</span> the icodes</span><br><span class="line">## <span class="keyword">for</span> iaddq (IIADDQ)</span><br><span class="line">## Your job <span class="keyword">is</span> <span class="keyword">to</span> add the rest <span class="keyword">of</span> the logic <span class="keyword">to</span> make it work</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    C Include<span class="symbol">'s</span>.  Don<span class="symbol">'t</span> alter these                               #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">quote '#include &lt;stdio.h&gt;'</span><br><span class="line">quote '#include <span class="string">"isa.h"</span>'</span><br><span class="line">quote '#include <span class="string">"sim.h"</span>'</span><br><span class="line">quote <span class="symbol">'int</span> sim_main(int argc, char *argv[]);'</span><br><span class="line">quote 'word_t gen_pc()&#123;return 0;&#125;'</span><br><span class="line">quote <span class="symbol">'int</span> main(int argc, char *argv[])'</span><br><span class="line">quote '  &#123;plusmode=0;return sim_main(argc,argv);&#125;'</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Declarations.  Do <span class="keyword">not</span> change/remove/delete any <span class="keyword">of</span> these       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">##### Symbolic representation <span class="keyword">of</span> Y86-<span class="number">64</span> Instruction Codes #############</span><br><span class="line">wordsig INOP 	<span class="symbol">'I_NOP</span>'</span><br><span class="line">wordsig IHALT	<span class="symbol">'I_HALT</span>'</span><br><span class="line">wordsig IRRMOVQ	<span class="symbol">'I_RRMOVQ</span>'</span><br><span class="line">wordsig IIRMOVQ	<span class="symbol">'I_IRMOVQ</span>'</span><br><span class="line">wordsig IRMMOVQ	<span class="symbol">'I_RMMOVQ</span>'</span><br><span class="line">wordsig IMRMOVQ	<span class="symbol">'I_MRMOVQ</span>'</span><br><span class="line">wordsig IOPQ	<span class="symbol">'I_ALU</span>'</span><br><span class="line">wordsig IJXX	<span class="symbol">'I_JMP</span>'</span><br><span class="line">wordsig ICALL	<span class="symbol">'I_CALL</span>'</span><br><span class="line">wordsig IRET	<span class="symbol">'I_RET</span>'</span><br><span class="line">wordsig IPUSHQ	<span class="symbol">'I_PUSHQ</span>'</span><br><span class="line">wordsig IPOPQ	<span class="symbol">'I_POPQ</span>'</span><br><span class="line"># Instruction code <span class="keyword">for</span> iaddq instruction</span><br><span class="line">wordsig IIADDQ	<span class="symbol">'I_IADDQ</span>'</span><br><span class="line"></span><br><span class="line">##### Symbolic represenations <span class="keyword">of</span> Y86-<span class="number">64</span> <span class="keyword">function</span> codes                  #####</span><br><span class="line">wordsig FNONE    <span class="symbol">'F_NONE</span>'        # <span class="keyword">Default</span> <span class="keyword">function</span> code</span><br><span class="line"></span><br><span class="line">##### Symbolic representation <span class="keyword">of</span> Y86-<span class="number">64</span> Registers referenced explicitly #####</span><br><span class="line">wordsig RRSP     <span class="symbol">'REG_RSP</span>'    	# Stack Pointer</span><br><span class="line">wordsig RNONE    <span class="symbol">'REG_NONE</span>'   	# Special value indicating <span class="string">"no register"</span></span><br><span class="line"></span><br><span class="line">##### ALU Functions referenced explicitly                            #####</span><br><span class="line">wordsig ALUADD	<span class="symbol">'A_ADD</span>'		# ALU should add its arguments</span><br><span class="line"></span><br><span class="line">##### Possible instruction status values                             #####</span><br><span class="line">wordsig SAOK	<span class="symbol">'STAT_AOK</span>'	# Normal execution</span><br><span class="line">wordsig SADR	<span class="symbol">'STAT_ADR</span>'	# Invalid memory address</span><br><span class="line">wordsig SINS	<span class="symbol">'STAT_INS</span>'	# Invalid instruction</span><br><span class="line">wordsig SHLT	<span class="symbol">'STAT_HLT</span>'	# Halt instruction encountered</span><br><span class="line"></span><br><span class="line">##### Signals that can be referenced by control logic ####################</span><br><span class="line"></span><br><span class="line">##### Fetch stage inputs		#####</span><br><span class="line">wordsig pc <span class="symbol">'pc</span>'				# Program counter</span><br><span class="line">##### Fetch stage computations		#####</span><br><span class="line">wordsig imem_icode <span class="symbol">'imem_icode</span>'		# icode field from instruction memory</span><br><span class="line">wordsig imem_ifun  <span class="symbol">'imem_ifun</span>' 		# ifun field from instruction memory</span><br><span class="line">wordsig icode	  <span class="symbol">'icode</span>'		# Instruction control code</span><br><span class="line">wordsig ifun	  <span class="symbol">'ifun</span>'		# Instruction <span class="keyword">function</span></span><br><span class="line">wordsig rA	  <span class="symbol">'ra</span>'			# rA field from instruction</span><br><span class="line">wordsig rB	  <span class="symbol">'rb</span>'			# rB field from instruction</span><br><span class="line">wordsig valC	  <span class="symbol">'valc</span>'		# <span class="keyword">Constant</span> from instruction</span><br><span class="line">wordsig valP	  <span class="symbol">'valp</span>'		# Address <span class="keyword">of</span> following instruction</span><br><span class="line">boolsig imem_error <span class="symbol">'imem_error</span>'		# <span class="literal">Error</span> <span class="keyword">signal</span> from instruction memory</span><br><span class="line">boolsig instr_valid <span class="symbol">'instr_valid</span>'	# <span class="keyword">Is</span> fetched instruction valid?</span><br><span class="line"></span><br><span class="line">##### Decode stage computations		#####</span><br><span class="line">wordsig valA	<span class="symbol">'vala</span>'			# Value from <span class="keyword">register</span> A <span class="keyword">port</span></span><br><span class="line">wordsig valB	<span class="symbol">'valb</span>'			# Value from <span class="keyword">register</span> B <span class="keyword">port</span></span><br><span class="line"></span><br><span class="line">##### Execute stage computations	#####</span><br><span class="line">wordsig valE	<span class="symbol">'vale</span>'			# Value computed by ALU</span><br><span class="line">boolsig Cnd	<span class="symbol">'cond</span>'			# Branch test</span><br><span class="line"></span><br><span class="line">##### Memory stage computations		#####</span><br><span class="line">wordsig valM	<span class="symbol">'valm</span>'			# Value read from memory</span><br><span class="line">boolsig dmem_error <span class="symbol">'dmem_error</span>'		# <span class="literal">Error</span> <span class="keyword">signal</span> from data memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Control <span class="keyword">Signal</span> Definitions.                                   #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line"># Determine instruction code</span><br><span class="line">word icode = [</span><br><span class="line">	imem_error: INOP;</span><br><span class="line">	<span class="number">1</span>: imem_icode;		# <span class="keyword">Default</span>: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine instruction <span class="keyword">function</span></span><br><span class="line">word ifun = [</span><br><span class="line">	imem_error: FNONE;</span><br><span class="line">	<span class="number">1</span>: imem_ifun;		# <span class="keyword">Default</span>: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bool instr_valid = icode <span class="keyword">in</span> </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	       IOPQ, IIADDQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?</span><br><span class="line">bool need_regids =</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ, IIADDQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a <span class="keyword">constant</span> word?</span><br><span class="line">bool need_valC =</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Decode Stage    ###################################</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the A source?</span><br><span class="line">word srcA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : rA;</span><br><span class="line">	icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE; # Don<span class="symbol">'t</span> need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the B source?</span><br><span class="line">word srcB = [</span><br><span class="line">	icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="symbol">'t</span> need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the E destination?</span><br><span class="line">word dstE = [</span><br><span class="line">	icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">	icode in &#123; IIRMOVQ, IOPQ, IIADDQ &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="symbol">'t</span> write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the M destination?</span><br><span class="line">word dstM = [</span><br><span class="line">	icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="symbol">'t</span> write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Execute Stage   ###################################</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> input A <span class="keyword">to</span> ALU</span><br><span class="line">word aluA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC;</span><br><span class="line">	icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don<span class="symbol">'t</span> need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> input B <span class="keyword">to</span> ALU</span><br><span class="line">word aluB = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, IIADDQ, ICALL, </span><br><span class="line">		      IPUSHQ, IRET, IPOPQ &#125; : valB;</span><br><span class="line">	icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don<span class="symbol">'t</span> need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU <span class="keyword">function</span></span><br><span class="line">word alufun = [</span><br><span class="line">	icode == IOPQ : ifun;</span><br><span class="line">	<span class="number">1</span> : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">bool set_cc = icode in &#123; IOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Memory Stage    ###################################</span><br><span class="line"></span><br><span class="line">## Set read control <span class="keyword">signal</span></span><br><span class="line">bool mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control <span class="keyword">signal</span></span><br><span class="line">bool mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> memory address</span><br><span class="line">word mem_addr = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">	icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">	# Other instructions don<span class="symbol">'t</span> need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> memory input data</span><br><span class="line">word mem_data = [</span><br><span class="line">	# Value from <span class="keyword">register</span></span><br><span class="line">	icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">	# <span class="keyword">Return</span> PC</span><br><span class="line">	icode == ICALL : valP;</span><br><span class="line">	# <span class="keyword">Default</span>: Don<span class="symbol">'t</span> write anything</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine instruction status</span><br><span class="line">word Stat = [</span><br><span class="line">	imem_error || dmem_error : SADR;</span><br><span class="line">	!instr_valid: SINS;</span><br><span class="line">	icode == IHALT : SHLT;</span><br><span class="line">	<span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Program Counter Update ############################</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at</span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">	# Call.  <span class="keyword">Use</span> instruction <span class="keyword">constant</span></span><br><span class="line">	icode == ICALL : valC;</span><br><span class="line">	# Taken branch.  <span class="keyword">Use</span> instruction <span class="keyword">constant</span></span><br><span class="line">	icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">	# Completion <span class="keyword">of</span> RET instruction.  <span class="keyword">Use</span> value from stack</span><br><span class="line">	icode == IRET : valM;</span><br><span class="line">	# <span class="keyword">Default</span>: <span class="keyword">Use</span> incremented PC</span><br><span class="line">	<span class="number">1</span> : valP;</span><br><span class="line">];</span><br><span class="line">#<span class="comment">/* $end seq-all-hcl */</span></span><br></pre></td></tr></table></figure>
<p>然后按照writeup跑测试，通过。</p>
<h3 id="Part-C-1"><a href="#Part-C-1" class="headerlink" title="Part C"></a>Part C</h3><p>Part C 的具体内容就是加速内存元素的拷贝问题。修改<code>ncopy.ys</code>和<code>pipe-full.hcl</code>代码使得CPE（cycles per element）尽可能小，即单个元素拷贝时间越少越好。</p>
<p>首先添加iaddq指令，原来是通过<code>irmovq</code>和<code>addq</code>来实现的，改为iaddq指令后起到很微弱的效果，并不能明显的减少CPE，如果你的irmovq指令在循环内部那就另说了，当然也不是最快。</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-4/pipe.jpg" alt></p>
<p>具体代码如下：</p>
<figure class="highlight vhdl"><figcaption><span>文件名：archlab/archlab-handout/sim/pipe/pipe-full.hcl</span></figcaption><table><tr><td class="code"><pre><span class="line">#<span class="comment">/* $begin pipe-all-hcl */</span></span><br><span class="line">####################################################################</span><br><span class="line">#    HCL Description <span class="keyword">of</span> Control <span class="keyword">for</span> Pipelined Y86-<span class="number">64</span> Processor     #</span><br><span class="line">#    Copyright (C) Randal E. Bryant, David R. O<span class="symbol">'Hallaron</span>, <span class="number">2014</span>     #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">## Your task <span class="keyword">is</span> <span class="keyword">to</span> implement the iaddq instruction</span><br><span class="line">## The <span class="keyword">file</span> contains a declaration <span class="keyword">of</span> the icodes</span><br><span class="line">## <span class="keyword">for</span> iaddq (IIADDQ)</span><br><span class="line">## Your job <span class="keyword">is</span> <span class="keyword">to</span> add the rest <span class="keyword">of</span> the logic <span class="keyword">to</span> make it work</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    C Include<span class="symbol">'s</span>.  Don<span class="symbol">'t</span> alter these                               #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">quote '#include &lt;stdio.h&gt;'</span><br><span class="line">quote '#include <span class="string">"isa.h"</span>'</span><br><span class="line">quote '#include <span class="string">"pipeline.h"</span>'</span><br><span class="line">quote '#include <span class="string">"stages.h"</span>'</span><br><span class="line">quote '#include <span class="string">"sim.h"</span>'</span><br><span class="line">quote <span class="symbol">'int</span> sim_main(int argc, char *argv[]);'</span><br><span class="line">quote 'int main(int argc, char *argv[])&#123;return sim_main(argc,argv);&#125;'</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Declarations.  Do <span class="keyword">not</span> change/remove/delete any <span class="keyword">of</span> these       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">##### Symbolic representation <span class="keyword">of</span> Y86-<span class="number">64</span> Instruction Codes #############</span><br><span class="line">wordsig INOP 	<span class="symbol">'I_NOP</span>'</span><br><span class="line">wordsig IHALT	<span class="symbol">'I_HALT</span>'</span><br><span class="line">wordsig IRRMOVQ	<span class="symbol">'I_RRMOVQ</span>'</span><br><span class="line">wordsig IIRMOVQ	<span class="symbol">'I_IRMOVQ</span>'</span><br><span class="line">wordsig IRMMOVQ	<span class="symbol">'I_RMMOVQ</span>'</span><br><span class="line">wordsig IMRMOVQ	<span class="symbol">'I_MRMOVQ</span>'</span><br><span class="line">wordsig IOPQ	<span class="symbol">'I_ALU</span>'</span><br><span class="line">wordsig IJXX	<span class="symbol">'I_JMP</span>'</span><br><span class="line">wordsig ICALL	<span class="symbol">'I_CALL</span>'</span><br><span class="line">wordsig IRET	<span class="symbol">'I_RET</span>'</span><br><span class="line">wordsig IPUSHQ	<span class="symbol">'I_PUSHQ</span>'</span><br><span class="line">wordsig IPOPQ	<span class="symbol">'I_POPQ</span>'</span><br><span class="line"># Instruction code <span class="keyword">for</span> iaddq instruction</span><br><span class="line">wordsig IIADDQ	<span class="symbol">'I_IADDQ</span>'</span><br><span class="line"></span><br><span class="line">##### Symbolic represenations <span class="keyword">of</span> Y86-<span class="number">64</span> <span class="keyword">function</span> codes            #####</span><br><span class="line">wordsig FNONE    <span class="symbol">'F_NONE</span>'        # <span class="keyword">Default</span> <span class="keyword">function</span> code</span><br><span class="line"></span><br><span class="line">##### Symbolic representation <span class="keyword">of</span> Y86-<span class="number">64</span> Registers referenced      #####</span><br><span class="line">wordsig RRSP     <span class="symbol">'REG_RSP</span>'    	     # Stack Pointer</span><br><span class="line">wordsig RNONE    <span class="symbol">'REG_NONE</span>'   	     # Special value indicating <span class="string">"no register"</span></span><br><span class="line"></span><br><span class="line">##### ALU Functions referenced explicitly ##########################</span><br><span class="line">wordsig ALUADD	<span class="symbol">'A_ADD</span>'		     # ALU should add its arguments</span><br><span class="line"></span><br><span class="line">##### Possible instruction status values                       #####</span><br><span class="line">wordsig SBUB	<span class="symbol">'STAT_BUB</span>'	# Bubble <span class="keyword">in</span> stage</span><br><span class="line">wordsig SAOK	<span class="symbol">'STAT_AOK</span>'	# Normal execution</span><br><span class="line">wordsig SADR	<span class="symbol">'STAT_ADR</span>'	# Invalid memory address</span><br><span class="line">wordsig SINS	<span class="symbol">'STAT_INS</span>'	# Invalid instruction</span><br><span class="line">wordsig SHLT	<span class="symbol">'STAT_HLT</span>'	# Halt instruction encountered</span><br><span class="line"></span><br><span class="line">##### Signals that can be referenced by control logic ##############</span><br><span class="line"></span><br><span class="line">##### Pipeline <span class="keyword">Register</span> F ##########################################</span><br><span class="line"></span><br><span class="line">wordsig F_predPC <span class="symbol">'pc_curr</span>-&gt;pc'	     # Predicted value <span class="keyword">of</span> PC</span><br><span class="line"></span><br><span class="line">##### Intermediate Values <span class="keyword">in</span> Fetch Stage ###########################</span><br><span class="line"></span><br><span class="line">wordsig imem_icode  <span class="symbol">'imem_icode</span>'      # icode field from instruction memory</span><br><span class="line">wordsig imem_ifun   <span class="symbol">'imem_ifun</span>'       # ifun  field from instruction memory</span><br><span class="line">wordsig f_icode	<span class="symbol">'if_id_next</span>-&gt;icode'  # (Possibly modified) instruction code</span><br><span class="line">wordsig f_ifun	<span class="symbol">'if_id_next</span>-&gt;ifun'   # Fetched instruction <span class="keyword">function</span></span><br><span class="line">wordsig f_valC	<span class="symbol">'if_id_next</span>-&gt;valc'   # <span class="keyword">Constant</span> data <span class="keyword">of</span> fetched instruction</span><br><span class="line">wordsig f_valP	<span class="symbol">'if_id_next</span>-&gt;valp'   # Address <span class="keyword">of</span> following instruction</span><br><span class="line">boolsig imem_error <span class="symbol">'imem_error</span>'	     # <span class="literal">Error</span> <span class="keyword">signal</span> from instruction memory</span><br><span class="line">boolsig instr_valid <span class="symbol">'instr_valid</span>'    # <span class="keyword">Is</span> fetched instruction valid?</span><br><span class="line"></span><br><span class="line">##### Pipeline <span class="keyword">Register</span> D ##########################################</span><br><span class="line">wordsig D_icode <span class="symbol">'if_id_curr</span>-&gt;icode'   # Instruction code</span><br><span class="line">wordsig D_rA <span class="symbol">'if_id_curr</span>-&gt;ra'	     # rA field from instruction</span><br><span class="line">wordsig D_rB <span class="symbol">'if_id_curr</span>-&gt;rb'	     # rB field from instruction</span><br><span class="line">wordsig D_valP <span class="symbol">'if_id_curr</span>-&gt;valp'     # Incremented PC</span><br><span class="line"></span><br><span class="line">##### Intermediate Values <span class="keyword">in</span> Decode Stage  #########################</span><br><span class="line"></span><br><span class="line">wordsig d_srcA	 <span class="symbol">'id_ex_next</span>-&gt;srca'  # srcA from decoded instruction</span><br><span class="line">wordsig d_srcB	 <span class="symbol">'id_ex_next</span>-&gt;srcb'  # srcB from decoded instruction</span><br><span class="line">wordsig d_rvalA <span class="symbol">'d_regvala</span>'	     # valA read from <span class="keyword">register</span> <span class="keyword">file</span></span><br><span class="line">wordsig d_rvalB <span class="symbol">'d_regvalb</span>'	     # valB read from <span class="keyword">register</span> <span class="keyword">file</span></span><br><span class="line"></span><br><span class="line">##### Pipeline <span class="keyword">Register</span> E ##########################################</span><br><span class="line">wordsig E_icode <span class="symbol">'id_ex_curr</span>-&gt;icode'   # Instruction code</span><br><span class="line">wordsig E_ifun  <span class="symbol">'id_ex_curr</span>-&gt;ifun'    # Instruction <span class="keyword">function</span></span><br><span class="line">wordsig E_valC  <span class="symbol">'id_ex_curr</span>-&gt;valc'    # <span class="keyword">Constant</span> data</span><br><span class="line">wordsig E_srcA  <span class="symbol">'id_ex_curr</span>-&gt;srca'    # Source A <span class="keyword">register</span> ID</span><br><span class="line">wordsig E_valA  <span class="symbol">'id_ex_curr</span>-&gt;vala'    # Source A value</span><br><span class="line">wordsig E_srcB  <span class="symbol">'id_ex_curr</span>-&gt;srcb'    # Source B <span class="keyword">register</span> ID</span><br><span class="line">wordsig E_valB  <span class="symbol">'id_ex_curr</span>-&gt;valb'    # Source B value</span><br><span class="line">wordsig E_dstE <span class="symbol">'id_ex_curr</span>-&gt;deste'    # Destination E <span class="keyword">register</span> ID</span><br><span class="line">wordsig E_dstM <span class="symbol">'id_ex_curr</span>-&gt;destm'    # Destination M <span class="keyword">register</span> ID</span><br><span class="line"></span><br><span class="line">##### Intermediate Values <span class="keyword">in</span> Execute Stage #########################</span><br><span class="line">wordsig e_valE <span class="symbol">'ex_mem_next</span>-&gt;vale'	# valE generated by ALU</span><br><span class="line">boolsig e_Cnd <span class="symbol">'ex_mem_next</span>-&gt;takebranch' # Does condition hold?</span><br><span class="line">wordsig e_dstE <span class="symbol">'ex_mem_next</span>-&gt;deste'      # dstE (possibly modified <span class="keyword">to</span> be RNONE)</span><br><span class="line"></span><br><span class="line">##### Pipeline <span class="keyword">Register</span> M                  #########################</span><br><span class="line">wordsig M_stat <span class="symbol">'ex_mem_curr</span>-&gt;status'     # Instruction status</span><br><span class="line">wordsig M_icode <span class="symbol">'ex_mem_curr</span>-&gt;icode'	# Instruction code</span><br><span class="line">wordsig M_ifun  <span class="symbol">'ex_mem_curr</span>-&gt;ifun'	# Instruction <span class="keyword">function</span></span><br><span class="line">wordsig M_valA  <span class="symbol">'ex_mem_curr</span>-&gt;vala'      # Source A value</span><br><span class="line">wordsig M_dstE <span class="symbol">'ex_mem_curr</span>-&gt;deste'	# Destination E <span class="keyword">register</span> ID</span><br><span class="line">wordsig M_valE  <span class="symbol">'ex_mem_curr</span>-&gt;vale'      # ALU E value</span><br><span class="line">wordsig M_dstM <span class="symbol">'ex_mem_curr</span>-&gt;destm'	# Destination M <span class="keyword">register</span> ID</span><br><span class="line">boolsig M_Cnd <span class="symbol">'ex_mem_curr</span>-&gt;takebranch'	# Condition flag</span><br><span class="line">boolsig dmem_error <span class="symbol">'dmem_error</span>'	        # <span class="literal">Error</span> <span class="keyword">signal</span> from instruction memory</span><br><span class="line"></span><br><span class="line">##### Intermediate Values <span class="keyword">in</span> Memory Stage ##########################</span><br><span class="line">wordsig m_valM <span class="symbol">'mem_wb_next</span>-&gt;valm'	# valM generated by memory</span><br><span class="line">wordsig m_stat <span class="symbol">'mem_wb_next</span>-&gt;status'	# stat (possibly modified <span class="keyword">to</span> be SADR)</span><br><span class="line"></span><br><span class="line">##### Pipeline <span class="keyword">Register</span> W ##########################################</span><br><span class="line">wordsig W_stat <span class="symbol">'mem_wb_curr</span>-&gt;status'     # Instruction status</span><br><span class="line">wordsig W_icode <span class="symbol">'mem_wb_curr</span>-&gt;icode'	# Instruction code</span><br><span class="line">wordsig W_dstE <span class="symbol">'mem_wb_curr</span>-&gt;deste'	# Destination E <span class="keyword">register</span> ID</span><br><span class="line">wordsig W_valE  <span class="symbol">'mem_wb_curr</span>-&gt;vale'      # ALU E value</span><br><span class="line">wordsig W_dstM <span class="symbol">'mem_wb_curr</span>-&gt;destm'	# Destination M <span class="keyword">register</span> ID</span><br><span class="line">wordsig W_valM  <span class="symbol">'mem_wb_curr</span>-&gt;valm'	# Memory M value</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Control <span class="keyword">Signal</span> Definitions.                                   #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at</span><br><span class="line">word f_pc = [</span><br><span class="line">	# Mispredicted branch.  Fetch at incremented PC</span><br><span class="line">	M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">	# Completion <span class="keyword">of</span> RET instruction</span><br><span class="line">	W_icode == IRET : W_valM;</span><br><span class="line">	# <span class="keyword">Default</span>: <span class="keyword">Use</span> predicted value <span class="keyword">of</span> PC</span><br><span class="line">	<span class="number">1</span> : F_predPC;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine icode <span class="keyword">of</span> fetched instruction</span><br><span class="line">word f_icode = [</span><br><span class="line">	imem_error : INOP;</span><br><span class="line">	<span class="number">1</span>: imem_icode;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine ifun</span><br><span class="line">word f_ifun = [</span><br><span class="line">	imem_error : FNONE;</span><br><span class="line">	<span class="number">1</span>: imem_ifun;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># <span class="keyword">Is</span> instruction valid?</span><br><span class="line">bool instr_valid = f_icode <span class="keyword">in</span> </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	  IOPQ, IIADDQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ &#125;;</span><br><span class="line"></span><br><span class="line"># Determine status code <span class="keyword">for</span> fetched instruction</span><br><span class="line">word f_stat = [</span><br><span class="line">	imem_error: SADR;</span><br><span class="line">	!instr_valid : SINS;</span><br><span class="line">	f_icode == IHALT : SHLT;</span><br><span class="line">	<span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?</span><br><span class="line">bool need_regids =</span><br><span class="line">	f_icode in &#123; IRRMOVQ, IOPQ, IIADDQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a <span class="keyword">constant</span> word?</span><br><span class="line">bool need_valC =</span><br><span class="line">	f_icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Predict <span class="keyword">next</span> value <span class="keyword">of</span> PC</span><br><span class="line">word f_predPC = [</span><br><span class="line">	f_icode in &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">	<span class="number">1</span> : f_valP;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Decode Stage ######################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the A source?</span><br><span class="line">word d_srcA = [</span><br><span class="line">	D_icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : D_rA;</span><br><span class="line">	D_icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE; # Don<span class="symbol">'t</span> need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the B source?</span><br><span class="line">word d_srcB = [</span><br><span class="line">	D_icode in &#123; IOPQ, IIADDQ, IRMMOVQ, IMRMOVQ  &#125; : D_rB;</span><br><span class="line">	D_icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="symbol">'t</span> need <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the E destination?</span><br><span class="line">word d_dstE = [</span><br><span class="line">	D_icode in &#123; IRRMOVQ, IIRMOVQ, IOPQ, IIADDQ &#125; : D_rB;</span><br><span class="line">	D_icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="symbol">'t</span> write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What <span class="keyword">register</span> should be used as the M destination?</span><br><span class="line">word d_dstM = [</span><br><span class="line">	D_icode in &#123; IMRMOVQ, IPOPQ &#125; : D_rA;</span><br><span class="line">	<span class="number">1</span> : RNONE;  # Don<span class="symbol">'t</span> write any <span class="keyword">register</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What should be the A value?</span><br><span class="line">## Forward into decode stage <span class="keyword">for</span> valA</span><br><span class="line">word d_valA = [</span><br><span class="line">	D_icode in &#123; ICALL, IJXX &#125; : D_valP; # Use incremented PC</span><br><span class="line">	d_srcA == e_dstE : e_valE;    # Forward valE from execute</span><br><span class="line">	d_srcA == M_dstM : m_valM;    # Forward valM from memory</span><br><span class="line">	d_srcA == M_dstE : M_valE;    # Forward valE from memory</span><br><span class="line">	d_srcA == W_dstM : W_valM;    # Forward valM from write back</span><br><span class="line">	d_srcA == W_dstE : W_valE;    # Forward valE from write back</span><br><span class="line">	<span class="number">1</span> : d_rvalA;  # <span class="keyword">Use</span> value read from <span class="keyword">register</span> <span class="keyword">file</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_valB = [</span><br><span class="line">	d_srcB == e_dstE : e_valE;    # Forward valE from execute</span><br><span class="line">	d_srcB == M_dstM : m_valM;    # Forward valM from memory</span><br><span class="line">	d_srcB == M_dstE : M_valE;    # Forward valE from memory</span><br><span class="line">	d_srcB == W_dstM : W_valM;    # Forward valM from write back</span><br><span class="line">	d_srcB == W_dstE : W_valE;    # Forward valE from write back</span><br><span class="line">	<span class="number">1</span> : d_rvalB;  # <span class="keyword">Use</span> value read from <span class="keyword">register</span> <span class="keyword">file</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Execute Stage #####################################</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> input A <span class="keyword">to</span> ALU</span><br><span class="line">word aluA = [</span><br><span class="line">	E_icode in &#123; IRRMOVQ, IOPQ &#125; : E_valA;</span><br><span class="line">	E_icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : E_valC;</span><br><span class="line">	E_icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	E_icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don<span class="symbol">'t</span> need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> input B <span class="keyword">to</span> ALU</span><br><span class="line">word aluB = [</span><br><span class="line">	E_icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, IIADDQ, ICALL, </span><br><span class="line">		     IPUSHQ, IRET, IPOPQ &#125; : E_valB;</span><br><span class="line">	E_icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don<span class="symbol">'t</span> need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU <span class="keyword">function</span></span><br><span class="line">word alufun = [</span><br><span class="line">	E_icode == IOPQ : E_ifun;</span><br><span class="line">	<span class="number">1</span> : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">bool set_cc = (E_icode == IOPQ||E_icode == IIADDQ) &amp;&amp;</span><br><span class="line">	# State changes only during normal operation</span><br><span class="line">	!m_stat in &#123; SADR, SINS, SHLT &#125; &amp;&amp; !W_stat in &#123; SADR, SINS, SHLT &#125;;</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Generate</span> valA <span class="keyword">in</span> execute stage</span><br><span class="line">word e_valA = E_valA;    # Pass valA through stage</span><br><span class="line"></span><br><span class="line">## Set dstE <span class="keyword">to</span> RNONE <span class="keyword">in</span> event <span class="keyword">of</span> <span class="keyword">not</span>-taken conditional move</span><br><span class="line">word e_dstE = [</span><br><span class="line">	E_icode == IRRMOVQ &amp;&amp; !e_Cnd : RNONE;</span><br><span class="line">	<span class="number">1</span> : E_dstE;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Memory Stage ######################################</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Select</span> memory address</span><br><span class="line">word mem_addr = [</span><br><span class="line">	M_icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : M_valE;</span><br><span class="line">	M_icode in &#123; IPOPQ, IRET &#125; : M_valA;</span><br><span class="line">	# Other instructions don<span class="symbol">'t</span> need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set read control <span class="keyword">signal</span></span><br><span class="line">bool mem_read = M_icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control <span class="keyword">signal</span></span><br><span class="line">bool mem_write = M_icode in &#123; IRMMOVQ, IPUSHQ, ICALL &#125;;</span><br><span class="line"></span><br><span class="line">#<span class="comment">/* $begin pipe-m_stat-hcl */</span></span><br><span class="line">## Update the status</span><br><span class="line">word m_stat = [</span><br><span class="line">	dmem_error : SADR;</span><br><span class="line">	<span class="number">1</span> : M_stat;</span><br><span class="line">];</span><br><span class="line">#<span class="comment">/* $end pipe-m_stat-hcl */</span></span><br><span class="line"></span><br><span class="line">## Set E <span class="keyword">port</span> <span class="keyword">register</span> ID</span><br><span class="line">word w_dstE = W_dstE;</span><br><span class="line"></span><br><span class="line">## Set E <span class="keyword">port</span> value</span><br><span class="line">word w_valE = W_valE;</span><br><span class="line"></span><br><span class="line">## Set M <span class="keyword">port</span> <span class="keyword">register</span> ID</span><br><span class="line">word w_dstM = W_dstM;</span><br><span class="line"></span><br><span class="line">## Set M <span class="keyword">port</span> value</span><br><span class="line">word w_valM = W_valM;</span><br><span class="line"></span><br><span class="line">## Update processor status</span><br><span class="line">word Stat = [</span><br><span class="line">	W_stat == SBUB : SAOK;</span><br><span class="line">	<span class="number">1</span> : W_stat;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Pipeline <span class="keyword">Register</span> Control #########################</span><br><span class="line"></span><br><span class="line"># Should I stall <span class="keyword">or</span> inject a bubble into Pipeline <span class="keyword">Register</span> F?</span><br><span class="line"># At most one <span class="keyword">of</span> these can be <span class="literal">true</span>.</span><br><span class="line">bool F_bubble = <span class="number">0</span>;</span><br><span class="line">bool F_stall =</span><br><span class="line">	# Conditions <span class="keyword">for</span> a load/<span class="keyword">use</span> hazard</span><br><span class="line">	E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">	 E_dstM in &#123; d_srcA, d_srcB &#125; ||</span><br><span class="line">	# Stalling at fetch <span class="keyword">while</span> ret passes through pipeline</span><br><span class="line">	IRET in &#123; D_icode, E_icode, M_icode &#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall <span class="keyword">or</span> inject a bubble into Pipeline <span class="keyword">Register</span> D?</span><br><span class="line"># At most one <span class="keyword">of</span> these can be <span class="literal">true</span>.</span><br><span class="line">bool D_stall = </span><br><span class="line">	# Conditions <span class="keyword">for</span> a load/<span class="keyword">use</span> hazard</span><br><span class="line">	E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">	 E_dstM in &#123; d_srcA, d_srcB &#125;;</span><br><span class="line"></span><br><span class="line">bool D_bubble =</span><br><span class="line">	# Mispredicted branch</span><br><span class="line">	(E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">	# Stalling at fetch <span class="keyword">while</span> ret passes through pipeline</span><br><span class="line">	# but <span class="keyword">not</span> condition <span class="keyword">for</span> a load/<span class="keyword">use</span> hazard</span><br><span class="line">	!(E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM in &#123; d_srcA, d_srcB &#125;) &amp;&amp;</span><br><span class="line">	  IRET in &#123; D_icode, E_icode, M_icode &#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall <span class="keyword">or</span> inject a bubble into Pipeline <span class="keyword">Register</span> E?</span><br><span class="line"># At most one <span class="keyword">of</span> these can be <span class="literal">true</span>.</span><br><span class="line">bool E_stall = <span class="number">0</span>;</span><br><span class="line">bool E_bubble =</span><br><span class="line">	# Mispredicted branch</span><br><span class="line">	(E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">	# Conditions <span class="keyword">for</span> a load/<span class="keyword">use</span> hazard</span><br><span class="line">	E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp;</span><br><span class="line">	 E_dstM in &#123; d_srcA, d_srcB&#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall <span class="keyword">or</span> inject a bubble into Pipeline <span class="keyword">Register</span> M?</span><br><span class="line"># At most one <span class="keyword">of</span> these can be <span class="literal">true</span>.</span><br><span class="line">bool M_stall = <span class="number">0</span>;</span><br><span class="line"># Start injecting bubbles as soon as exception passes through memory stage</span><br><span class="line">bool M_bubble = m_stat in &#123; SADR, SINS, SHLT &#125; || W_stat in &#123; SADR, SINS, SHLT &#125;;</span><br><span class="line"></span><br><span class="line"># Should I stall <span class="keyword">or</span> inject a bubble into Pipeline <span class="keyword">Register</span> W?</span><br><span class="line">bool W_stall = W_stat in &#123; SADR, SINS, SHLT &#125;;</span><br><span class="line">bool W_bubble = <span class="number">0</span>;</span><br><span class="line">#<span class="comment">/* $end pipe-all-hcl */</span></span><br></pre></td></tr></table></figure>
<p>然后修改ncopy.ys文件</p>
<h4 id="Version-1-0"><a href="#Version-1-0" class="headerlink" title="Version 1.0"></a>Version 1.0</h4><figure class="highlight x86asm"><figcaption><span>文件名：archlab/archlab-handout/sim/pipe/ncopy.ys</span></figcaption><table><tr><td class="code"><pre><span class="line">#/* $begin ncopy-ys */</span><br><span class="line">##################################################################</span><br><span class="line"># ncopy<span class="number">.</span>ys - Copy a src block of len words to dst.</span><br><span class="line"># Return the number of positive words (&gt;<span class="number">0</span>) contained <span class="keyword">in</span> src.</span><br><span class="line">#</span><br><span class="line"># Include your name <span class="keyword">and</span> ID here.</span><br><span class="line">#</span><br><span class="line"># Describe how <span class="keyword">and</span> why you modified the baseline code.</span><br><span class="line">#</span><br><span class="line">##################################################################</span><br><span class="line"># <span class="built_in">Do</span> <span class="keyword">not</span> modify this portion</span><br><span class="line"># Function prologue.</span><br><span class="line"># %rdi = src, %rsi = dst, %rdx = len</span><br><span class="line"><span class="symbol">ncopy:</span></span><br><span class="line"></span><br><span class="line">##################################################################</span><br><span class="line"># You can modify this portion</span><br><span class="line">	# <span class="keyword">Loop</span> header</span><br><span class="line">	xorq %rax,%rax		# count = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	andq %rdx,%rdx		# len &lt;= <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jle</span> Done		# if so, goto Done:</span><br><span class="line"></span><br><span class="line"><span class="symbol">Loop:</span>	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		# val &lt;= <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jle</span> Npos		# if so, goto Npos:</span><br><span class="line">	iaddq <span class="number">$1</span>, %rax		# count++</span><br><span class="line"><span class="symbol">Npos:</span>	</span><br><span class="line">	iaddq $-<span class="number">1</span>, %rdx		# len--</span><br><span class="line">	iaddq <span class="number">$8</span>, %rdi		# src++</span><br><span class="line">	iaddq <span class="number">$8</span>, %rsi		# dst++</span><br><span class="line">	andq %rdx,%rdx		# len &gt; <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jg</span> <span class="keyword">Loop</span>			# if so, goto <span class="keyword">Loop</span>:</span><br><span class="line">##################################################################</span><br><span class="line"># <span class="built_in">Do</span> <span class="keyword">not</span> modify the following <span class="meta">section</span> of code</span><br><span class="line"># Function epilogue.</span><br><span class="line"><span class="symbol">Done:</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">##################################################################</span><br><span class="line"># Keep the following label <span class="meta">at</span> the end of your function</span><br><span class="line"><span class="symbol">End:</span></span><br><span class="line">#/* $end ncopy-ys */</span><br></pre></td></tr></table></figure>
<p>然而还是0分。</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-4/result.png" alt></p>
<p>主要考虑还是要减少bubble，还有程序优化问题。</p>
<p>看完第五章再来二刷吧。</p>
<h4 id="Version-2-0"><a href="#Version-2-0" class="headerlink" title="Version 2.0"></a>Version 2.0</h4><p>结果：<br><img src="/images/loading.gif" data-original="/csapp-lab-4/result2.png" alt></p>
<p>所作修改：</p>
<ul>
<li>4x4循环展开，因为C=4，L=1</li>
<li>消除了一些load/use指令组合</li>
</ul>
<figure class="highlight x86asm"><figcaption><span>文件名：archlab/archlab-handout/sim/pipe/ncopy.ys</span></figcaption><table><tr><td class="code"><pre><span class="line">#/* $begin ncopy-ys */</span><br><span class="line">##################################################################</span><br><span class="line"># ncopy<span class="number">.</span>ys - Copy a src block of len words to dst.</span><br><span class="line"># Return the number of positive words (&gt;<span class="number">0</span>) contained <span class="keyword">in</span> src.</span><br><span class="line">#</span><br><span class="line"># Include your name <span class="keyword">and</span> ID here.</span><br><span class="line">#</span><br><span class="line"># Describe how <span class="keyword">and</span> why you modified the baseline code.</span><br><span class="line">#</span><br><span class="line">##################################################################</span><br><span class="line"># <span class="built_in">Do</span> <span class="keyword">not</span> modify this portion</span><br><span class="line"># Function prologue.</span><br><span class="line"># %rdi = src, %rsi = dst, %rdx = len</span><br><span class="line"><span class="symbol">ncopy:</span></span><br><span class="line"></span><br><span class="line">##################################################################</span><br><span class="line"># You can modify this portion</span><br><span class="line">	# <span class="keyword">Loop</span> header</span><br><span class="line">	xorq %rax,%rax		# count = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	andq %rdx,%rdx		# len &lt;= <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jle</span> Done		# if so, goto Done:</span><br><span class="line"></span><br><span class="line"><span class="symbol">testType:</span></span><br><span class="line">	irmovq <span class="number">$3</span>,%r8</span><br><span class="line">	andq %rdx, %r8</span><br><span class="line">	<span class="keyword">je</span> <span class="keyword">Loop</span></span><br><span class="line">	rrmovq %r8,%r11</span><br><span class="line">	irmovq <span class="number">$1</span>, %rcx</span><br><span class="line"><span class="symbol">originLoop:</span></span><br><span class="line">	mrmovq (%rdi), %r10</span><br><span class="line">	iaddq <span class="number">$8</span>, %rdi		# src++</span><br><span class="line">	andq %r10, %r10</span><br><span class="line">	rmmovq %r10, (%rsi)</span><br><span class="line">	<span class="keyword">jle</span> <span class="keyword">neg</span></span><br><span class="line">	iaddq <span class="number">$1</span>, %rax</span><br><span class="line"><span class="symbol">neg:</span></span><br><span class="line">	iaddq <span class="number">$8</span>, %rsi		# dst++</span><br><span class="line">	subq %rcx, %r8</span><br><span class="line">	<span class="keyword">jg</span> originLoop</span><br><span class="line">	subq %r11,%rdx		# len &gt; <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jle</span> Done</span><br><span class="line"><span class="symbol">Loop:</span>	</span><br><span class="line">	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	mrmovq <span class="number">8</span>(%rdi), %r11</span><br><span class="line">	mrmovq <span class="number">16</span>(%rdi), %r8</span><br><span class="line">	mrmovq <span class="number">24</span>(%rdi), %r9</span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	rmmovq %r11, <span class="number">8</span>(%rsi)</span><br><span class="line">	rmmovq %r8, <span class="number">16</span>(%rsi)</span><br><span class="line">	rmmovq %r9, <span class="number">24</span>(%rsi)</span><br><span class="line">	andq %r10, %r10		# val &lt;= <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jle</span> second		# if so,go next item:</span><br><span class="line">	iaddq <span class="number">$1</span>, %rax		# count++</span><br><span class="line"><span class="symbol">second:</span></span><br><span class="line">	andq %r11, %r11</span><br><span class="line">	<span class="keyword">jle</span> third</span><br><span class="line">	iaddq <span class="number">$1</span>, %rax</span><br><span class="line"><span class="symbol">third:</span></span><br><span class="line">	andq %r8, %r8</span><br><span class="line">	<span class="keyword">jle</span> forth</span><br><span class="line">	iaddq <span class="number">$1</span>, %rax</span><br><span class="line"><span class="symbol">forth:</span></span><br><span class="line">	andq %r9, %r9</span><br><span class="line">	<span class="keyword">jle</span> Npos</span><br><span class="line">	iaddq <span class="number">$1</span>, %rax</span><br><span class="line"><span class="symbol">Npos:</span>	</span><br><span class="line">	iaddq $-<span class="number">4</span>, %rdx		# len--</span><br><span class="line">	iaddq <span class="number">$32</span>, %rdi		# src++</span><br><span class="line">	iaddq <span class="number">$32</span>, %rsi		# dst++</span><br><span class="line">	andq %rdx,%rdx		# len &gt; <span class="number">0</span>?</span><br><span class="line">	<span class="keyword">jg</span> <span class="keyword">Loop</span>			# if so, goto <span class="keyword">Loop</span>:</span><br><span class="line">##################################################################</span><br><span class="line"># <span class="built_in">Do</span> <span class="keyword">not</span> modify the following <span class="meta">section</span> of code</span><br><span class="line"># Function epilogue.</span><br><span class="line"><span class="symbol">Done:</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">##################################################################</span><br><span class="line"># Keep the following label <span class="meta">at</span> the end of your function</span><br><span class="line"><span class="symbol">End:</span></span><br><span class="line">#/* $end ncopy-ys */</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>粗略的总结了一下。有问题请在评论区或者daovoice指正。</p>
<h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><ol>
<li>最近做问题不够专注，时间观念不够强，可能是太过松散了</li>
<li>。。。</li>
</ol>
<h3 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h3><ol>
<li>从阅读《编码》这本书中浅浅的了解了处理器体系结构，到csapp3e进一步了解</li>
<li>熟悉了ISA设计的基本方法，指令分类、分阶段、流水线、冒险问题、异常处理、性能评价等</li>
</ol>
<h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><ol>
<li>阅读第5章，二刷part C</li>
<li>使用番茄todo做好时间规划，并执行训练</li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
        <tag>CSAPP Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>阈值分割</title>
    <url>/threshold-segmentation.html</url>
    <content><![CDATA[<div class="note info">
            <p>图像基于阈值分割的二值化处理。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="note primary">
            <p><strong>全部代码请查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">GitHub<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<p>上次做了图像物体边缘检测，不过由于课程并没有讲完，只做了部分，待总结。这次做的是图像分割中的阈值分割。</p>
<p>阈值分割是一种图像分割方法，用于分割不同物体，比如说前景和背景的分割、图片中关键信息的提取（如下图，来自网络）。本次实验是针对8位灰度图的二值化处理。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/2649969-3af798de1b0b90a1.png?imageMogr2/auto-orient/" alt></p>
<div class="note primary no-icon">
            <p>数字图像处理全部实验博客总结请查看<a href="/tags/DIP/">扶桑树叶之DIP</a></p>
          </div>
<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>古风，善。</p>
<iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32432321&auto=1&height=66"></iframe>

<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><blockquote>
<p><strong>要求：在直方图上标记出计算出的阈值、生成二值化后的图像</strong></p>
</blockquote>
<ol>
<li>给定阈值T</li>
<li>双峰法（极小点阈值法）（选做——就是不做）</li>
<li>迭代阈值法</li>
<li>Otsu(大津算法)</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="0x01-先晒原图"><a href="#0x01-先晒原图" class="headerlink" title="0x01 先晒原图"></a>0x01 先晒原图</h3><ul>
<li>原图</li>
</ul>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/origin.png" alt></p>
<p>然后转换为8位灰度图，对8位灰度图进行二值化处理。</p>
<ul>
<li>转8位灰度图</li>
</ul>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/gray.png" alt></p>
<h3 id="0x02-人为观察直方图给定阈值T进行二值化"><a href="#0x02-人为观察直方图给定阈值T进行二值化" class="headerlink" title="0x02 人为观察直方图给定阈值T进行二值化"></a>0x02 人为观察直方图给定阈值T进行二值化</h3><p>最简单了，权当练手。<br>方法就是对8位灰度图每个像素进行如下处理：</p>
<ul>
<li>灰度大于T，灰度设为255</li>
<li>灰度小于T，灰度设为0</li>
</ul>
<p><strong><em>结果如下：</em></strong></p>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/threshold-seed.png" alt></p>
<p><strong><em>相应的直方图，灰色线条为所选的阈值，图像从下向上灰度增加</em></strong></p>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/threshold-histogram-seed.png" alt></p>
<p>这样看来是有一定问题的，并没有完全将前景和背景分割出来。</p>
<h3 id="0x03-使用迭代法进行二值化处理"><a href="#0x03-使用迭代法进行二值化处理" class="headerlink" title="0x03 使用迭代法进行二值化处理"></a>0x03 使用迭代法进行二值化处理</h3><div class="note warning">
            <p>该算法适用于背景和对象在图像中占据的面积相近的情况。</p>
          </div>
<p>算法思想：利用平均灰度作为指标，将图片分为低灰度和高灰度两部分，根据两部分平均灰度求原图“新平均灰度”并比较两个平均灰度，如果满足误差条件，即停止迭代。</p>
<p>具体步骤：</p>
<ol>
<li>选择图像灰度的中值（我选的是平均灰度）作为初始阈值$T_i=T_0$。</li>
<li>利用阈值Ti把图像分割成两部分区域，$R_1$和$R_2$，并计算其灰度均值$\mu_1$和$\mu_2$</li>
<li>计算新的阈值$T_{i+1}=\frac{1}{2}\times(\mu_1+\mu_2)$</li>
<li>重复步骤2、3，直到$T_{i+1}$和$T_i$的值差别小于某个给定值</li>
</ol>
<p><strong><em>结果如下：</em></strong></p>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/threshold-iteration.png" alt></p>
<p><strong><em>相应的直方图，灰色线条为所选的阈值，图像从下向上灰度增加</em></strong></p>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/threshold-histogram-iteration.png" alt></p>
<p>这样看来是有一定问题的，并没有完全将前景和背景分割出来。</p>
<h3 id="0x04-otsu大津算法"><a href="#0x04-otsu大津算法" class="headerlink" title="0x04 otsu大津算法"></a>0x04 otsu大津算法</h3><p>算法思想：针对二值化，将图片区域分为两类，根据两类的类间方差最大（或者类内方差最小）来进行分割。针对多类分割也是同理。当然我自己还没有完全搞懂为啥是这个情况，数学是硬伤，太菜了。</p>
<div class="note info">
            <p><strong>二值化类间方差公式</strong><br>类内方差的最小化与类间方差的最大化是一致的优化目标。</p><p>$$<br>\sigma^2=\omega_1\omega_2\times(\mu_1-\mu_2)^2<br>$$</p><ul><li>$\mu_1$和$\mu_2$分别是两个类的平均灰度</li><li>$\omega_1$和$\omega_2$分别是两个类的像素占比，即概率</li></ul>
          </div>
<p>具体步骤：</p>
<blockquote>
<p>采取类间方差最大的方法来进行二值化</p>
</blockquote>
<ol>
<li>初始化类间方差$\omega^2=0$</li>
<li>初始化阈值$i=1$</li>
<li>求得阈值$i$下的类间方差$\omega^2_i$</li>
<li>如果$\omega^2_i\gg\omega^2$则替换之</li>
<li>增加阈值$i=i+1$</li>
<li>重复3、4、5步</li>
</ol>
<p><strong><em>结果如下：</em></strong></p>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/threshold-otsu.png" alt></p>
<p><strong><em>相应的直方图，灰色线条为所选的阈值，图像从下向上灰度增加</em></strong></p>
<p><img src="/images/loading.gif" data-original="/threshold-segmentation/threshold-histogram-otsu.png" alt></p>
<p>效果较好，这也是为什么当前仍然使用这个算法的原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验对阈值分割有了一定的了解，针对二值化做了实验，使用了迭代和otsu两种算法进行二值化处理，学到了不少，但是其中的原理还是没有搞清楚，希望以后能有机会深入研究一下。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference &amp; Pointer in C(PP)</title>
    <url>/c-reference-pointer.html</url>
    <content><![CDATA[<div class="note info">
            <p>“Reference &amp; Pointer in C” expressed in English.</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="Forword"><a href="#Forword" class="headerlink" title="Forword"></a>Forword</h2><p>The reason why I write this blog article is just to understand the reference and pointer completely.Let’s have a look the underlying implementation of the reference and pointer.</p>
<h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><blockquote>
<p><strong><em>天净沙</em></strong> By <strong>骆集益/周志华</strong></p>
</blockquote>
<iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26344079&auto=1&height=66"></iframe>

<h2 id="In-one-word"><a href="#In-one-word" class="headerlink" title="In one word"></a>In one word</h2><div class="note primary">
            <p>Reference is the same as pointer in essence.Both are the address,and the differences between both are the using rules.</p>
          </div>
<h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p>There are some situations:</p>
<ul>
<li>Basic data type reference</li>
<li>Struct type reference</li>
<li>Class type reference</li>
<li>Class type pointer</li>
<li>About the segment</li>
</ul>
<p>We will talk it in the above way.</p>
<h3 id="0x01-Basic-data-type-reference"><a href="#0x01-Basic-data-type-reference" class="headerlink" title="0x01 Basic data type reference"></a>0x01 Basic data type reference</h3><p>There are two programs in this situation.</p>
<ul>
<li>Let’s see the reference and pointer in underlying assembly code :-)</li>
</ul>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/reference.png" alt></p>
<p>In this program,we can conclude these results:</p>
<ol>
<li><p>The local variables is saved in the address begining with <code>%rbp-0x24</code>(to increasing direction.).The <code>int</code> type variables cover 4 bytes and the <code>address</code> type variables cover 8 bytes.</p>
<ol>
<li>Variable <code>a</code> is saved at <code>%rbp-0x24</code></li>
<li>Variable <code>b</code> is saved at <code>%rbp-0x20</code></li>
<li>Variable <code>c</code> is saved at <code>%rbp-0x18</code></li>
<li>Variable <code>d</code> is saved at <code>%rbp-0x10</code> </li>
</ol>
</li>
<li><p><strong>The reference and the pointer both are address.</strong></p>
</li>
</ol>
<ul>
<li>Let’s see the instance of reference in calling functions.</li>
</ul>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/reference2.png" alt></p>
<p>We can conclude these results:</p>
<ol>
<li>Call-by-reference relays the parameters by their address.</li>
<li>We have known that we can call by value.Of course,the address is also a value.Thus,we can think that there is only call-by-value.</li>
</ol>
<h3 id="0x02-Struct-type-reference"><a href="#0x02-Struct-type-reference" class="headerlink" title="0x02 Struct type reference"></a>0x02 Struct type reference</h3><p>Let’s talk about reference in struct type variables.</p>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/reference-struct.png" alt></p>
<p>In this program,we can conclude that:</p>
<ol>
<li>The variables defined in the way - <code>T a;</code> - are all saved in the stack frame.</li>
<li>The reference of struct-type variables is also an address.</li>
</ol>
<h3 id="0x03-Class-type-reference"><a href="#0x03-Class-type-reference" class="headerlink" title="0x03 Class type reference"></a>0x03 Class type reference</h3><p>The class-type instance is the same as the struct.</p>
<p>It’s easy! You can jump it!</p>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/reference-class.png" alt></p>
<h3 id="0x04-Class-type-pointer"><a href="#0x04-Class-type-pointer" class="headerlink" title="0x04 Class type pointer"></a>0x04 Class type pointer</h3><p>Let’s have a look at the instance defined by <code>new</code>:</p>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/reference-class-new.png" alt></p>
<p>We can conclude that the pointer is just the address points to the heap somewhere.Of course,the address in the heap is undefined,because it’s dynamic and the assembly code is <code>objdump</code> by <code>gcc -c(Compile and assemble, but do not link)</code></p>
<h3 id="0x05-About-the-segment"><a href="#0x05-About-the-segment" class="headerlink" title="0x05 About the segment"></a>0x05 About the segment</h3><p>In the situation,I want to have a look at the global variables,but I don’t find it in the assembly code.It’s in the <strong>data segment</strong>!</p>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/reference.png" alt></p>
<p>Let’s retrospect the segment partition:</p>
<p><img src="/images/loading.gif" data-original="/c-reference-pointer/segment.jpg" alt></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In the article,we explore the underlying assembly code of reference and pointer,and we review the segment partition.Hope you can get a lot.</p>
<p>Have a nice day.<br>Bye!<br>-:)</p>
]]></content>
      <categories>
        <category>Back-End Development</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Express in English</tag>
      </tags>
  </entry>
  <entry>
    <title>About function pointer in C</title>
    <url>/c-function-pointer.html</url>
    <content><![CDATA[<div class="note primary">
            <p>“About C function pointer in C” expressed in English.</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="Forword"><a href="#Forword" class="headerlink" title="Forword"></a>Forword</h2><p>I have coded by using the functional programming in JavaScript and Java.I also have learned the C function pointer which can also be used to program functionally.However,I have seldom or never used it.The article will be writen to interpret the function pointer in C.</p>
<h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><blockquote>
<p><strong><em>Not dyed</em></strong> by <strong>He Tu</strong></p>
</blockquote>
<iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=533181327&auto=1&height=66"></iframe>

<h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p>There are two main themes in the part:</p>
<ul>
<li>C function pointer</li>
<li><em>left-value</em> &amp; <em>right-value</em></li>
</ul>
<h3 id="How-to-use-C-function-pointer"><a href="#How-to-use-C-function-pointer" class="headerlink" title="How to use C function pointer"></a>How to use C function pointer</h3><p>The function pointer can be declared in this way:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>In this way,we can declare a function pointer which points to a  class of functions using two <em>int</em> parameters and <em>int</em> return-values.</p>
<p>While in JavaScript,We need not be careful about it.</p>
<p>In the underlying architecture,the reasons why a function pointer can only point to a class functions which have the same parameters and return-value are as the following:</p>
<ul>
<li>the compiler need to ensure the number and type of parameters to allocate the memory space for it,and to perform the correct operation.</li>
<li>the compiler need to know the return-value type of the function.</li>
</ul>
<p>Thus,the function pointer must be designated the return-value type and the parameter type.It’s the same as the data pointer which has definite specification.</p>
<h3 id="An-example"><a href="#An-example" class="headerlink" title="An example"></a>An example</h3><p>We declare the function pointer which is as follows:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Then we define a function named <em>maximum</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then in the main-function,we use the function pointer in this way:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func_ptr p=&amp;maximum;<span class="comment">// '&amp;' can be ignored.</span></span><br><span class="line">    <span class="comment">//func_ptr p=max;</span></span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Maximum of four numbers is %d!\n"</span>,p(a,p(b,p(c,d))));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As what you think,the result is 4.</span></span><br></pre></td></tr></table></figure>
<h3 id="Write-callback-function-by-using-functional-programming-in-C"><a href="#Write-callback-function-by-using-functional-programming-in-C" class="headerlink" title="Write callback function by using functional programming in C"></a>Write callback function by using functional programming in C</h3><p>You maybe have used the callback function in C GUI programming such as <strong><em>Win32 API</em></strong> and <strong><em>MFC</em></strong>.But how does it make it? </p>
<p><strong><em>Callback</em></strong> can be implemented by using function pointer.And function pointer is always used as callback function.</p>
<p>We have declared the function pointer <code>func_ptr</code> before,and <code>maximum</code> function.Then we declare another function and implement a callback function:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,func_ptr max_min_func_ptr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do something here!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//As the following: revoke the callback function.</span></span><br><span class="line">    <span class="keyword">return</span> max_min_func_ptr(a,max_min_func_ptr(b,max_min_func_ptr(c,d)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func_ptr pmax = maximum;</span><br><span class="line">    func_ptr pmin = minimum;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Maximum of four numbers is %d!\n"</span>,max_min(a,b,c,d,pmax));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Minimum of four numbers is %d!\n"</span>,max_min(a,b,c,d,pmin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong><br><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">Maximum of four numbers is <span class="number">4</span>!</span><br><span class="line">Minimum of four numbers is <span class="number">1</span>!</span><br><span class="line">Press any key to continue . . .</span><br></pre></td></tr></table></figure></p>
<p>In this way,we use these two functions named <code>maximum</code> and <code>minimum</code> as the callback functions.</p>
<h3 id="What-is-left-value-and-right-value"><a href="#What-is-left-value-and-right-value" class="headerlink" title="What is left-value and right-value"></a>What is <em>left-value</em> and <em>right-value</em></h3><p>The crucial different between both in <strong><em>C++</em></strong>:</p>
<div class="note primary no-icon">
            <ul><li>left-value: Can get its address in the memory.<blockquote><p>int a,int a[2],char a,struct {} a,function a…</p></blockquote></li><li>right-value: Cannot get its address.<blockquote><p>2,3.1…</p></blockquote></li></ul>
          </div>
<p><strong>Instead of being assignable or not</strong></p>
<p>As before,we can conclude that <strong>the function designator</strong>(function name) is a <em>left-value</em>.Of course,that is a <em>left-value</em> in C++.<br>While in C,it’s neither a <em>left-value</em> nor a <em>right-value</em>.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this article,we are familiar with <em>c function point</em>,<em>callback</em> and <em>lr values</em>.</p>
<p>That’s all for the time being.Thanks for your reading!</p>
<p>See you later.</p>
]]></content>
      <categories>
        <category>Back-End Development</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Functional Programming</tag>
        <tag>Express in English</tag>
      </tags>
  </entry>
  <entry>
    <title>What kind of person am I</title>
    <url>/what-person-i-am.html</url>
    <content><![CDATA[<div class="note primary">
            <p>“What kind of person am I” expressed in English.</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>This is the first time for me to write an article in my blog site.There may be some errors in this article.One way or another,I will try my best to write it.</p>
<p>let’s start!</p>
<h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><blockquote>
<p>TVアニメ「とある科学の超電磁砲」OP1</p>
</blockquote>
<iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33913797&auto=1&height=66"></iframe>


<h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p>Come to the point,I will state what kind of person I am in the article.</p>
<div class="note success no-icon">
            <p><strong>I will state it in the following ways:</strong></p><ul><li>My Character</li><li>My Hobbies</li><li>My Skills</li></ul><p>That’s all for the time being.</p>
          </div>
<h3 id="My-Character"><a href="#My-Character" class="headerlink" title="My Character"></a>My Character</h3><p>No one can deny that everyone has advantages and disadvantages.Of course I has,too.</p>
<p>I am not a outgoing boy.Rather than say so, it’s better to say that I can’t express my points fluently which excludes the science such as cs(computer science),math and so on.</p>
<p>I am a boy of vanity.I am a tsundere boy.I don’t want to be a boy that couldn’t approach anyone’s greatness,so I study hard to be stronger.</p>
<h3 id="My-Hobbies"><a href="#My-Hobbies" class="headerlink" title="My Hobbies"></a>My Hobbies</h3><ul>
<li>Listen to music<blockquote>
<p>atique music</p>
</blockquote>
</li>
<li>Play games<blockquote>
<p>Large-scale single-player games.I have played <strong><em>Rise of the Tomb Raider</em></strong>,<strong><em>Tomb Raider</em></strong> which both are the one of the trilogy,and a game named <strong><em>Fallout 4</em></strong> on the <strong>steam platform</strong>.</p>
</blockquote>
</li>
<li>Exercise<blockquote>
<p>Exercise with my partners.</p>
</blockquote>
</li>
<li>Reading Books<blockquote>
<p>Internet novels and technology books.</p>
</blockquote>
</li>
<li>Watch animation<blockquote>
<p>Many kinds …</p>
</blockquote>
</li>
</ul>
<h3 id="My-Skills"><a href="#My-Skills" class="headerlink" title="My Skills"></a>My Skills</h3><ul>
<li>Coding</li>
<li>Coding</li>
<li>Coding</li>
<li>and so on…</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>That’s all for the time being.<br>Over!</p>
<p>It’s not easy for me to write the article.Next,the mission is regular practice.</p>
]]></content>
      <categories>
        <category>Prose and Essay</category>
      </categories>
      <tags>
        <tag>Prose and Essay</tag>
        <tag>Express in English</tag>
      </tags>
  </entry>
  <entry>
    <title>图像基本变换</title>
    <url>/dip-transformation.html</url>
    <content><![CDATA[<div class="note primary">
            <p>图像基本变换：缩放、平移、镜像、旋转、透视。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列文章（DIP，Digital Image Processing），用于记录总结数字图像处理课程的实验内容。目录请参考<a href="/tags/DIP/">DIP系列文章</a>。</p>
<div class="note warning no-icon">
            <p><strong>本次不展示代码，全部代码请查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">GitHub<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ol>
<li>图像缩放</li>
<li>图像平移</li>
<li>图像镜像</li>
<li>图像旋转</li>
<li>图像透视（选做就是不做）</li>
</ol>
<h2 id="原图（测试图像）"><a href="#原图（测试图像）" class="headerlink" title="原图（测试图像）"></a>原图（测试图像）</h2><p>仅对8位灰度图进行处理，RGB真彩色处理同理。</p>
<p><img src="/images/loading.gif" data-original="/dip-transformation/3-3.png" alt></p>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>空间域处理都是对每个像素进行处理，无非就是做一层映射而已。</p>
<p>利用后向映射进行变换，即<strong>根据转换后图像的像素位置确定转换前的像素位置，得到像素灰度值并赋值给转换后图像像素</strong>。</p>
<p><img src="/images/loading.gif" data-original="/dip-transformation/back.png" alt></p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>思路及效果如下：</p>
<h3 id="0x00-基本变量表"><a href="#0x00-基本变量表" class="headerlink" title="0x00 基本变量表"></a>0x00 基本变量表</h3><table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x_0 $</td>
<td style="text-align:center">原像素横坐标值</td>
</tr>
<tr>
<td style="text-align:center">$y_0 $</td>
<td style="text-align:center">原像素纵坐标值</td>
</tr>
<tr>
<td style="text-align:center">$x$</td>
<td style="text-align:center">转换后横坐标值</td>
</tr>
<tr>
<td style="text-align:center">$y$</td>
<td style="text-align:center">转换后纵坐标值</td>
</tr>
<tr>
<td style="text-align:center">$t_1$</td>
<td style="text-align:center">转换幅度值，放缩倍数、平移量等</td>
</tr>
<tr>
<td style="text-align:center">$t_2$</td>
<td style="text-align:center">转换幅度值，放缩倍数、平移量等</td>
</tr>
<tr>
<td style="text-align:center">$width $</td>
<td style="text-align:center">图像水平像素个数</td>
</tr>
<tr>
<td style="text-align:center">$height$</td>
<td style="text-align:center">图像垂直像素个数</td>
</tr>
<tr>
<td style="text-align:center">$\theta$</td>
<td style="text-align:center">顺时针旋转角度</td>
</tr>
</tbody>
</table>
<h3 id="0x01-图像缩放"><a href="#0x01-图像缩放" class="headerlink" title="0x01 图像缩放"></a>0x01 图像缩放</h3><p>转换矩阵：</p>
<p>$$\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>t_1 &amp; 0 &amp; 0 \\<br>0 &amp; t_2 &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<p>后向映射为：</p>
<p>$$\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>\frac{1}{t_1} &amp; 0 &amp; 0 \\<br>0 &amp; \frac{1}{t_2} &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<p>这样即可求得转换后图像当前坐标的灰度值为多少了。</p>
<blockquote>
<p>宽×3，高×4</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/dip-transformation/scale.png" alt></p>
<h3 id="0x02-图像平移"><a href="#0x02-图像平移" class="headerlink" title="0x02 图像平移"></a>0x02 图像平移</h3><blockquote>
<p>向左下平移</p>
</blockquote>
<p>转换矩阵：</p>
<p>$$\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; t_1 \\<br>0 &amp; 1 &amp; t_2 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<p>后向映射为：</p>
<p>$$\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; -t_1 \\<br>0 &amp; 1 &amp; -t_2 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<p><img src="/images/loading.gif" data-original="/dip-transformation/shift.png" alt></p>
<h3 id="0x03-图像镜像"><a href="#0x03-图像镜像" class="headerlink" title="0x03 图像镜像"></a>0x03 图像镜像</h3><p>只展示水平镜像，垂直同理。</p>
<p>转换矩阵：</p>
<p>$$\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>-1 &amp; 0 &amp; width \\<br>0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<p>后向映射为：</p>
<p>$$\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>-1 &amp; 0 &amp; width \\<br>0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<blockquote>
<p>水平镜像</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/dip-transformation/x-mirror.png" alt></p>
<blockquote>
<p>垂直镜像</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/dip-transformation/y-mirror.png" alt></p>
<h3 id="0x04-图像旋转"><a href="#0x04-图像旋转" class="headerlink" title="0x04 图像旋转"></a>0x04 图像旋转</h3><p>转换矩阵：</p>
<p>$$\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>\cos\theta &amp; \sin\theta &amp; 0 \\<br>-\sin\theta &amp; \cos\theta &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<p>后向映射为：</p>
<p>$$\left[<br>\begin{matrix}<br>x_0 \\<br>y_0 \\<br>1 \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>\cos\theta &amp; -\sin\theta &amp; 0 \\<br>\sin\theta &amp; \cos\theta &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x \\<br>y \\<br>1 \\<br>\end{matrix}<br>\right] $$</p>
<blockquote>
<p>顺时针旋转45°</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/dip-transformation/rotate.png" alt></p>
<h3 id="0x05-图像透视"><a href="#0x05-图像透视" class="headerlink" title="0x05 图像透视"></a>0x05 图像透视</h3><p>没做。</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul>
<li>未对RGB真彩色图像做变换，原理一样，懒得做</li>
<li>未做透视变换</li>
<li>未使用线性插值方法进行补像素灰度值</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验主要是熟悉图像的基本变换，如果文中有错误，欢迎在评论区指正。请继续关注<a href="/tags/DIP/">DIP，数字图像处理系列文章</a>！</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 之 Attack Lab</title>
    <url>/csapp-lab-3.html</url>
    <content><![CDATA[<div class="note primary">
            <p>《深入理解计算机系统》之Attack Lab。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始第三个实验——Attack Lab了！本次试验还是基于第三章《程序的机器级表示》。</p>
<h2 id="先来首歌Relax一下"><a href="#先来首歌Relax一下" class="headerlink" title="先来首歌Relax一下"></a>先来首歌Relax一下</h2><p>比较好听的一首古风歌，与《霓裳羽衣曲》一字之差。唐朝诗人白居易在元和年间见到当时宫廷里表演的《霓裳羽衣曲》时，舞者“不著人家俗衣服。虹裳霞帔步摇冠，钿缨累累佩珊珊。”此曲此词皆有其意境。</p>
<iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1295233186&auto=1&height=66"></iframe>

<h2 id="CSAPP-实验记录"><a href="#CSAPP-实验记录" class="headerlink" title="CSAPP 实验记录"></a>CSAPP 实验记录</h2><div class="note info">
            <p><strong><a href="/tags/CSAPP-Lab/">本系列文章</a>主要记录 CSAPP 3.0 的实验过程，所有实验记录文章请查看<a href="/tags/CSAPP-Lab/">这儿</a></strong></p>
          </div>
<p>快速开始请访问 <code>CSAPP</code> <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvM2UvbGFicy5odG1s" title="http://csapp.cs.cmu.edu/3e/labs.html">Lab<i class="fa fa-external-link"></i></span> 官网，本次实验记录是基于 CSAPP 3.0，实验日期始于：<code>2019-3-25</code></p>
<h2 id="实验开始前的归纳"><a href="#实验开始前的归纳" class="headerlink" title="实验开始前的归纳"></a>实验开始前的归纳</h2><h2 id="Attack-Lab"><a href="#Attack-Lab" class="headerlink" title="Attack Lab"></a>Attack Lab</h2><p>Attack分为两个部分，代码注入攻击和ROP（Return-Oriented Program）攻击，分别要对<strong>Ctarget</strong>程序和<strong>Rtarget</strong>程序进行攻击。</p>
<h3 id="Ctarget"><a href="#Ctarget" class="headerlink" title="Ctarget"></a>Ctarget</h3><p>针对于Ctarget程序的攻击，思路都是一样的：利用buffer溢出。首先利用buffer溢出修改callee的ret的返回位置，然后在ret位置可以注入代码进行操作，说的时髦一点就是攻击。</p>
<h4 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h4><p>每做一个实验就需要熟悉具体的操作流程，虽然比较浪费时间，但是这确实能够增加我们的视野，而且能让我们了解许多知识，比如：</p>
<ul>
<li>字节序，intel的字节序是小端法</li>
<li>代码注入不能为输入字符串的ASCII码，而是需要通过hex2raw方法输入原始字节序列</li>
</ul>
<p>方式：</p>
<ol>
<li>通过<strong>objdump</strong>或者<strong>gdb</strong>确定一些需要的值，比如说<strong>rsp</strong>的值或者是某个函数的位置。</li>
<li>编写注入代码，并用<strong>gcc</strong>汇编，用<strong>objdump</strong>获取指令及其编码</li>
<li>将这些编码通过<strong>hex2raw</strong>输出为原始字节序</li>
</ol>
<h4 id="Phase1"><a href="#Phase1" class="headerlink" title="# Phase1"></a># Phase1</h4><div class="note primary">
            <p><strong>目标：注入代码调用touch1函数。</strong></p>
          </div>
<p>第一个，只是练手的，take it easy…</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase1.png" alt></p>
<p>根据给出的test函数和touch1函数的代码，我们可以看出test函数并没有调用touch1函数，而是只调用了一个getbuf函数，这个函数就是获取输入的内容的，而getbuf函数允许最大输入0x28（十进制40）个字节。那么思路很明显了，只需要利用buffer溢出，修改ret的值就好了（因为栈内buffer的下面就是ret的返回地址了）。也就是说只需要输入40个字节任意字符+touch1的地址就好了。</p>
<p>结果如下：<br><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase1-success.png" alt></p>
<h4 id="Phase2"><a href="#Phase2" class="headerlink" title="# Phase2"></a># Phase2</h4><div class="note primary">
            <p><strong>目标：注入代码传参并调用touch2函数。</strong></p>
          </div>
<p>这个相对于第一个来说复杂了一点，要求你将cookie.txt文件里面的数值0x59b997fa作为参数调用touch2函数。</p>
<p>对于第一个phrase只需要直接输入字符串就行了，而第二个需要注入原始字节序代码了。</p>
<p>先说一下思路，因为需要传递参数，只需要传递一个，那就需要修改 <strong>%rdi</strong>寄存器的值，要想修改就必须用指令实现。我们需要做的就是写代码，注入，让程序跳转到我们注入代码的地方。</p>
<p>具体一点，思路如下：</p>
<p>因为一开始获取输入的都是getbuf函数，这一点和phrase1相同，这说明buffersize没变。所以我们还需要输入40个字节的字符和返回地址。我们要做的就是将返回地址修改为我们注入代码的地方，记为<strong>addr</strong>，我们需要将注入的代码放到哪里呢？buffer里完全够用，如果放到其他地方反而有可能造成segmentfault。从buffer首地址，也就是caller——getbuf函数一开始的rsp值开始注入我们的代码，这个rsp值也是我们需要跳转的值<strong>addr</strong>。</p>
<p>我们注入的代码有什么用？</p>
<ul>
<li>修改 <strong>%rdi</strong>的值为0x59b997fa</li>
<li>控制交给touch2，因为不能用jmp和call，所以只能用ret来实现。</li>
</ul>
<p>注入代码如下：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase2-insert.png" alt></p>
<p>然后需要做的事就是将这段汇编代码用<code>gcc -c xxx</code>来汇编，并用<code>objdump -d xxx</code>来查看汇编指令对应的字节序列了（如上图）。<br>得到字节序列之后还需要将他和buffer的其他部分还有我们注入代码的首地址放入。然后通过hex2raw程序将其按照原始字节序列输入。</p>
<p>结束！运行结果如下：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase2-success.png" alt></p>
<h4 id="Phase3"><a href="#Phase3" class="headerlink" title="# Phase3"></a># Phase3</h4><div class="note primary">
            <p><strong>目标：注入固定字符串ASCII码序列并传首地址作为参数然后调用touch3函数。</strong></p>
          </div>
<p>第三个和第二个差不多，只不过多了一点坑，同样是传递参数，只不过需要传一个字符串，而字符串需要自己保存，而且还有可能函数调用的过程中被其他数据覆盖。</p>
<p>我们先来思考一下需要哪些数据吧：</p>
<ul>
<li>cookie十六进制数的ASCII码值</li>
<li>getbuf申请内存后的rsp值</li>
<li>要存取ASCII码序列的地址</li>
<li>touch3地址</li>
</ul>
<p>其他的都好确定，存取ASCII码序列的地址无法确定，有可能你第一次尝试是错误的。主要是因为touch函数调用了hexmatch函数，而这个函数对缓冲区进行了修改。</p>
<p>截了一下图。</p>
<p><strong>执行hexmatch函数前：</strong></p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase3-rsp-old.png" alt></p>
<p><strong>执行hexmatch函数后：</strong></p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase3-rsp-new.png" alt></p>
<p>我们发现第三行（0x5561dc98）之前的大多数都被修改了，所以我们要把数据继续放到栈的更底部位置。也就是从0x5561dca4之后的位置开始。那就简单了。</p>
<p>展示一下栈结构：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/1553868529136.png" alt="1553868529136"></p>
<p>完事！</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/phrase3-success.png" alt></p>
<h3 id="Rtarget"><a href="#Rtarget" class="headerlink" title="Rtarget"></a>Rtarget</h3><p>下面开始ROP攻击，虽然需要利用buffer溢出来攻击，但是和代码注入攻击不同的是栈内的数据会不能当做指令来执行。所以需要使用一些程序中已经存在的代码区域的gadgets小工具来拼凑自己想要的指令序列。</p>
<h4 id="Phase4"><a href="#Phase4" class="headerlink" title="# Phase4"></a># Phase4</h4><p>第一弹，还是执行完getbuf函数就去执行touch2而不返回test函数。</p>
<div class="note primary">
            <p><strong>目标：利用gadget传参并调用touch2函数。</strong></p>
          </div>
<p>​    </p>
<p>因为无法执行栈中的指令，所以只能通过已有代码来拼凑，那要拼凑成什么，首先还是看数据：</p>
<ul>
<li><p>cookie值</p>
</li>
<li><p>touch2地址</p>
</li>
</ul>
<p>  我们需要将cookie值传入rdi寄存器中，而cookie值只能通过输入保存到栈中，所以可以通过gadget根据指令编码找到一个pop命令pop到rdi中。但是遗憾的是farm前半部分并没有找到这个命令，所以我们只能另寻他法。最后我们可以通过pop先pop到rax中，然后使用mov命令将rax的值传入rdi中。</p>
<p>  我用到的是这两个gadget：一个包含<code>pop %rax</code>命令，一个包含<code>mov %rax,%rdi</code>命令。</p>
<p>  <img src="/images/loading.gif" data-original="/csapp-lab-3/1553869869465.png" alt="1553869869465"></p>
<p>  好了rdi中已经存储的cookie值了，下一步就是跳转到touch2了。</p>
<p>  怎么跳转？很简单，如果此时栈顶的元素是touch2的地址，并且接下来执行一条ret指令就OK了。</p>
<p>所以说很简单了，栈结构如下：</p>
<p>因为无法执行栈内代码，所以buffer合法部分已经没用了。</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-3/1553870526705.png" alt="1553870526705"></p>
<h4 id="Phase5"><a href="#Phase5" class="headerlink" title="# Phase5"></a># Phase5</h4><p>选做等于不做，好吧，是自己太菜了。到此为止95′已经到手，没必要争这5′了。了解一下内存栈的模型和这两种攻击手段就好了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实验整体提升不是很大，不过了解了两种攻击手段。</p>
<h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><ul>
<li>自己还有些浮躁，有时静不下心来。</li>
<li>自己不应该有太多空闲时间，不然无所事事。</li>
<li>英语专业阅读水平有了一定的提高</li>
</ul>
<h3 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h3><ul>
<li>进一步了解了栈帧结构</li>
<li>了解了代码注入和ROP两种攻击手段，虽然现在已经很难适用了。</li>
</ul>
<h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><ul>
<li>养成阅读英语书籍和文档的习惯</li>
<li>做好日常规划</li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
        <tag>CSAPP Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>空间域滤波</title>
    <url>/spatial-filter.html</url>
    <content><![CDATA[<div class="note primary">
            <p>大漠孤烟直？长河落日圆！</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次的实验主要是对图像进行<strong>图像平滑</strong>处理，<strong>图像锐化</strong>也是类似的方法。</p>
<p>首先解决存惑已久的概念，什么是空间域？</p>
<div class="note info">
            <h3 id="图像增强方法"><a href="#图像增强方法" class="headerlink" title="图像增强方法"></a>图像增强方法</h3><p>图像增强方法分为两大类：<strong>空间域方法</strong>和<strong>频域方法</strong></p><ul><li>空间域”是指图像平面自身，这类方法是以对图像的像素直接处理为基础</li><li>“频域”处理技术是以修改图像的傅氏变换为基础（以后会总结）</li></ul>
          </div>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li>平均处理（基于模板卷积运算）</li>
<li>中值滤波<blockquote>
<p>说明：上述处理需要对边界点进行处理，2种方法</p>
</blockquote>
</li>
</ul>
<p>模板在<a href="digital-image-kernel-collection.html">DIP 中常见的核</a>一文中总结过，如果不清楚概念可以查看一下。</p>
<h3 id="任务解析"><a href="#任务解析" class="headerlink" title="任务解析"></a>任务解析</h3><p>两次实验都是为了进行图像平滑处理，主要目的是消除噪声或模糊图像，去除小的细节或弥合目标间的缝隙。</p>
<ul>
<li>平均处理（基于模板卷积运算），对图像每个像素进行模板内像素的平均化求值并更新中心像素。</li>
<li>中值滤波，对图像每个像素进行模板内像素的中位数求值并更新中心像素。</li>
<li>边缘处理，两种方法：不处理；扩充图像。</li>
</ul>
<h2 id="任务Start"><a href="#任务Start" class="headerlink" title="任务Start"></a>任务Start</h2><p>首先展示一下原图（因为需要找噪声比较明显的图像，所以没找到像素比较大的和attractive的 :cry:）：</p>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray1.png" alt></p>
<h3 id="平均处理"><a href="#平均处理" class="headerlink" title="平均处理"></a>平均处理</h3><p>比较常见的有两种平均处理核：</p>
<ul>
<li>第一种</li>
</ul>
<p>$$<br>    \frac{1}{9}\times<br>    \begin{bmatrix}<br>        1&amp;1&amp;1\\<br>        1&amp;1&amp;1\\<br>        1&amp;1&amp;1<br>    \end{bmatrix}<br>$$</p>
<ul>
<li>第二种</li>
</ul>
<p>$$<br>    \frac{1}{16}\times<br>    \begin{bmatrix}<br>       1&amp;2&amp;1\\<br>       2&amp;4&amp;2\\<br>       1&amp;2&amp;1<br>    \end{bmatrix}<br>$$</p>
<p>实现是采用的是第一种。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AverageProcessing</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">const</span> <span class="keyword">char</span> * output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BMFILEHEADER header;</span><br><span class="line">	INFOHEADER info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ** data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*));</span><br><span class="line">	RGBQUAD ** palette = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBQUAD*));</span><br><span class="line">	<span class="keyword">unsigned</span> pixelCounts = BMPReader8(src, &amp;header, &amp;info, palette, data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> **outData = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*));</span><br><span class="line"></span><br><span class="line">	*outData = <span class="built_in">malloc</span>(pixelCounts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; info.<span class="built_in">height</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; info.<span class="built_in">width</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> ||( i == info.<span class="built_in">height</span> - <span class="number">1</span>)|| j == <span class="number">0</span> || (j == info.<span class="built_in">width</span> - <span class="number">1</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				*(*outData + i * info.<span class="built_in">width</span> + j) = *(*data + i * info.<span class="built_in">width</span> + j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> newGray = *(*data + (i - <span class="number">1</span>) * info.<span class="built_in">width</span> + (j - <span class="number">1</span>)) +</span><br><span class="line">				*(*data + (i)* info.<span class="built_in">width</span> + (j - <span class="number">1</span>)) +</span><br><span class="line">				*(*data + (i + <span class="number">1</span>)* info.<span class="built_in">width</span> + (j - <span class="number">1</span>)) +</span><br><span class="line">				*(*data + (i - <span class="number">1</span>)* info.<span class="built_in">width</span> + (j)) +</span><br><span class="line">				*(*data + (i)* info.<span class="built_in">width</span> + (j)) +</span><br><span class="line">				*(*data + (i + <span class="number">1</span>)* info.<span class="built_in">width</span> + (j)) +</span><br><span class="line">				*(*data + (i - <span class="number">1</span>)* info.<span class="built_in">width</span> + (j + <span class="number">1</span>)) +</span><br><span class="line">				*(*data + (i)* info.<span class="built_in">width</span> + (j + <span class="number">1</span>)) +</span><br><span class="line">				*(*data + (i + <span class="number">1</span>)* info.<span class="built_in">width</span> + (j + <span class="number">1</span>));</span><br><span class="line">			newGray /= <span class="number">9</span>;</span><br><span class="line">			*(*outData + i * info.<span class="built_in">width</span>+j) = newGray;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BMPWriter8(output, &amp;header, &amp;info, palette, outData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>采用一次迭代和三次迭代，一次迭代可能效果不够明显，所以采用多次迭代。但是也会对原图的准确数据造成模糊。</p>
<ul>
<li>一次迭代运行结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray2.png" alt></p>
<ul>
<li>三次迭代运行结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray2-3.png" alt></p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MedianFiltering</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">const</span> <span class="keyword">char</span> * output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BMFILEHEADER header;</span><br><span class="line">	INFOHEADER info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ** data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*));</span><br><span class="line">	RGBQUAD ** palette = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBQUAD*));</span><br><span class="line">	<span class="keyword">unsigned</span> pixelCounts = BMPReader8(src, &amp;header, &amp;info, palette, data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> **outData = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*));</span><br><span class="line"></span><br><span class="line">	*outData = <span class="built_in">malloc</span>(pixelCounts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; info.<span class="built_in">height</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; info.<span class="built_in">width</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || (i == info.<span class="built_in">height</span> - <span class="number">1</span>) || j == <span class="number">0</span> || (j == info.<span class="built_in">width</span> - <span class="number">1</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				*(*outData + i * info.<span class="built_in">width</span> + j) = *(*data + i * info.<span class="built_in">width</span> + j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> newGrays[] = &#123; *(*data + (i - <span class="number">1</span>) * info.<span class="built_in">width</span> + (j - <span class="number">1</span>)) ,</span><br><span class="line">				*(*data + (i)* info.<span class="built_in">width</span> + (j - <span class="number">1</span>)) ,</span><br><span class="line">				*(*data + (i + <span class="number">1</span>)* info.<span class="built_in">width</span> + (j - <span class="number">1</span>)) ,</span><br><span class="line">				*(*data + (i - <span class="number">1</span>)* info.<span class="built_in">width</span> + (j)) ,</span><br><span class="line">				*(*data + (i)* info.<span class="built_in">width</span> + (j)) ,</span><br><span class="line">				*(*data + (i + <span class="number">1</span>)* info.<span class="built_in">width</span> + (j)) ,</span><br><span class="line">				*(*data + (i - <span class="number">1</span>)* info.<span class="built_in">width</span> + (j + <span class="number">1</span>)) ,</span><br><span class="line">				*(*data + (i)* info.<span class="built_in">width</span> + (j + <span class="number">1</span>)) ,</span><br><span class="line">				*(*data + (i + <span class="number">1</span>)* info.<span class="built_in">width</span> + (j + <span class="number">1</span>)) &#125;;</span><br><span class="line">			quicksort(newGrays, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">			<span class="keyword">int</span> newGray = newGrays[<span class="number">4</span>];</span><br><span class="line">			*(*outData + i * info.<span class="built_in">width</span> + j) = newGray;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BMPWriter8(output, &amp;header, &amp;info, palette, outData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p>与均值处理类似，中值处理也分别采用1次和3次迭代。</p>
<ul>
<li>一次迭代运行结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray3.png" alt></p>
<ul>
<li>三次迭代运行结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray3-3.png" alt></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>整体看一下效果，可以打开一个图进行左右切换对比。</p>
<ul>
<li>原图</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray1.png" alt></p>
<ul>
<li>平均处理（一次处理）</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray2.png" alt></p>
<ul>
<li>平均处理（三次迭代）</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray2-3.png" alt></p>
<ul>
<li>中值滤波（一次处理）</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray3.png" alt></p>
<ul>
<li>中值滤波（三次迭代）</li>
</ul>
<p><img src="/images/loading.gif" data-original="/spatial-filter/gray3-3.png" alt></p>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><p>很明显，中值滤波处理方法更优。平均处理方法在模糊噪声的同时也一定程度的模糊的关键像素，会产生新的灰度值；而中值滤波只会选取已有的灰度值进行取值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note primary">
            <p><strong>全部代码请查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">GitHub<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<p>本次实验相对比较简单，主要是因为前几天对一些BMP文件的处理做了一定的封装，把精力放到图像处理上来。图像锐化的内容也和本次实验类似，只是去了不同的“核”来处理。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>并发和并行的概念与应用</title>
    <url>/concurrency-parallelism.html</url>
    <content><![CDATA[<div class="note primary">
            <p>一句话说并发的目的：我们想让计算机做的更多，运行的更快。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你对以下概念存有疑惑，那么你很适合读这篇总结性文章：</p>
<ul>
<li>并发、并行</li>
<li>处理器、CPU、核</li>
<li>线程级并发、指令级并行、单指令&amp;多指令并行</li>
</ul>
<p>整理的可能不够详细，若想进一步了解，请参考CSAPP3.0 P17-P19。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>驱动数字计算机进步的两个需求是<strong>想要计算机做得更多</strong>、<strong>想让计算机运行的更快</strong>，相关的两个术语便是<em>并行</em>和<em>并发</em>。（这两个术语有好几种说法，不过是一个代称而已，理解真正的意思就好了。）</p>
</blockquote>
<div class="note success no-icon">
            <h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>是一个通用的概念，指一个同时具有多个活动的系统具有的特性。</p>
          </div>
<div class="note success no-icon">
            <h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>指的是用并发来使系统运行得更快。</p>
          </div>
<h2 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h2><blockquote>
<p>构建在进程的抽象上。</p>
</blockquote>
<h3 id="处理器分类"><a href="#处理器分类" class="headerlink" title="处理器分类"></a>处理器分类</h3><p><img src="/images/loading.gif" data-original="/concurrency-parallelism/solver-class.png" alt></p>
<h4 id="单处理器"><a href="#单处理器" class="headerlink" title="单处理器"></a>单处理器</h4><div class="note info no-icon">
            <p>真正的单CPU、单线程，处理器同一时刻只能执行一个线程。它的并发是模拟出来的，是通过进程间快速切换实现的。</p><ul><li>不惜切换上下文浪费资源来实现模拟并发是为了缩短前台程序响应时间，能够同时运行多个程序，提高用户体验。</li></ul>
          </div>
<h4 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h4><blockquote>
<p>多处理器包含<strong><em>多核处理器</em></strong>和<strong><em>超线程处理器</em></strong>。</p>
</blockquote>
<div class="note info">
            <p>随着多核处理器和超线程的出现，使得多处理器变得常见。</p>
          </div>
<h5 id="0x01-多核处理器"><a href="#0x01-多核处理器" class="headerlink" title="0x01 多核处理器"></a>0x01 多核处理器</h5><blockquote>
<p><strong>“核”正是指的CPU</strong>。</p>
</blockquote>
<div class="note info no-icon">
            <p>多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上。</p><blockquote><p>以下是一个典型的多核处理器</p></blockquote><ul><li>每一个CPU（即“核”）可以执行一个线程</li><li>每个核都有自己的L1和L2级Cache</li><li>L1级Cache分为两个部分，一个保存最近取到的指令，一个存放数据</li><li>所有核共享L3级Cache</li></ul><p><img src="/images/loading.gif" data-original="/concurrency-parallelism/multikernel.png" alt></p>
          </div>
<h5 id="0x02-超线程处理器"><a href="#0x02-超线程处理器" class="headerlink" title="0x02 超线程处理器"></a>0x02 超线程处理器</h5><div class="note info no-icon">
            <p>有时称为<strong>同时多线程</strong>，是一项允许一个CPU多个控制流（线程）的技术。</p><ul><li>涉及CPU某些硬件的多个备份，比如程序计数器（PC或IP）和寄存器文件</li><li>常规处理器需要20000个时钟周期做不同线程间的转换，而超线程处理器可以在单个线程决定执行哪个线程（当一个线程处于“慢”状态，比如等待数据从内存装到Cache中时，可以选择处于“快”状态的线程先执行）</li></ul>
          </div>
<h5 id="0x03-Intel-Core-i7-的四核八线程指什么？"><a href="#0x03-Intel-Core-i7-的四核八线程指什么？" class="headerlink" title="0x03 Intel Core i7 的四核八线程指什么？"></a>0x03 Intel Core i7 的四核八线程指什么？</h5><div class="note info no-icon">
            <p>即将4个CPU（也就是“核”）集成到一个集成电路芯片上，每个CPU允许控制2个控制流（线程）</p>
          </div>
<h2 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h2><blockquote>
<p>构建在较低的抽象层次上。</p>
</blockquote>
<div class="note info">
            <p>现代处理器可以同时执行多条指令的属性称为指令级并行。</p><ul><li>1978年Intel8086，需要多个（通常是3~10个）时钟周期来执行一条指令。</li><li>现代处理器可以达到每个时钟周期处理2~4条指令，但每个指令周转时间需要20个时钟周期或更长。主要是因为处理器使用了一些技巧可以同时处理多达100条指令。</li></ul>
          </div>
<h2 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h2><blockquote>
<p>构建在最低层次上。</p>
</blockquote>
<div class="note info">
            <p>许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行的操作，这种方式称为单指令、多数据，即SIMD并行（Single Instruction Multiple Data）</p><ul><li>例如，较新的几代Intel和AMD处理器都具有并行地对8位点精度浮点数（C语言的float）做加法的指令</li></ul>
          </div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章用于回顾（retrospect）和总结，避免遗忘。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 之 Bomb Lab</title>
    <url>/csapp-lab-2.html</url>
    <content><![CDATA[<div class="note default">
            <p>脑越用越灵，手越用越巧。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没想到这BombLab果然有趣。一开始实验的时候还是有点困难的，主要是对GDB调试和一些知识点不够熟悉。虽然前面两个问题都有借鉴别人的方法。但是后面四个难度最大的真的是独立完成，完成的瞬间成就感不言而喻，达到climax。可能主要是对汇编有一点底子所以实验相对比较容易。</p>
<h2 id="CSAPP-实验记录"><a href="#CSAPP-实验记录" class="headerlink" title="CSAPP 实验记录"></a>CSAPP 实验记录</h2><div class="note info">
            <p><strong><a href="/tags/CSAPP-Lab/">本系列文章</a>主要记录 CSAPP 3.0 的实验过程，所有实验记录文章请查看<a href="/tags/CSAPP-Lab/">这儿</a></strong></p>
          </div>
<p>快速开始请访问 <code>CSAPP</code> <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvM2UvbGFicy5odG1s" title="http://csapp.cs.cmu.edu/3e/labs.html">Lab<i class="fa fa-external-link"></i></span> 官网，本次实验记录是基于 CSAPP 3.0，实验日期始于：<code>2019-3-18</code></p>
<h2 id="实验开始前的归纳"><a href="#实验开始前的归纳" class="headerlink" title="实验开始前的归纳"></a>实验开始前的归纳</h2><div class="note primary">
            <p>这个实验首先要求对汇编有一定的掌握，所以在此就不列举汇编的相关内容了。个人感觉用到最重要也是想要入手必须要具备的知识：<strong>一是学会使用反汇编及调试工具，二是了解函数调用的栈帧</strong>。</p>
          </div>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>想要了解栈帧的结构？我们还是先来回顾（review）以下有哪些和函数栈相关的寄存器吧。（这儿并没有包含浮点寄存器）</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/registers.png" alt></p>
<ul>
<li>所谓调用者保存，就是可以让被调用者（自身不作为另一个调用者）随意使用，也是为了自己用到的数据不被覆盖。</li>
<li>所谓被调用者保存，恰恰与调用者保存相反。</li>
<li>函数调用一般参数传递（非浮点）前6个参数存于寄存器，剩下的参数<strong>按照函数定义从右向左压栈</strong>。</li>
<li>栈指针指向函数栈栈顶。</li>
<li><span class="label primary">%rax</span>用于保存函数调用返回值。</li>
</ul>
<p>了解了这些寄存器，我们再来看看栈帧的结构</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/stackframe.png" alt></p>
<p>就拿函数P的栈帧来说，从栈底到栈顶的方向分别存储以下内容：</p>
<ul>
<li>被保存的寄存器</li>
<li>局部变量（<code>sub $0x18,%rsp</code>）</li>
<li>如果调用其他函数参数多于6，便有参数构造区</li>
<li>调用其他函数时需要将返回地址压栈</li>
</ul>
<h3 id="工具使用方法"><a href="#工具使用方法" class="headerlink" title="工具使用方法"></a>工具使用方法</h3><h4 id="CGDB"><a href="#CGDB" class="headerlink" title="CGDB"></a>CGDB</h4><p>跟随<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTI2OTUxNA==" title="https://zhuanlan.zhihu.com/p/31269514">孟佬<i class="fa fa-external-link"></i></span>用的CGDB，<span class="exturl" data-url="aHR0cHM6Ly9jZ2RiLmdpdGh1Yi5pby8=" title="https://cgdb.github.io/">官网<i class="fa fa-external-link"></i></span>及<span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvM2UvZG9jcy9nZGJub3Rlcy14ODYtNjQucGRm" title="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">gdb使用方式<i class="fa fa-external-link"></i></span>，以下是CGDB运行缺省截图。</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/cgdb.png" alt></p>
<h2 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h2><p>BombLab家喻户晓，个人感觉之所以这个实验这么有名，主要有三点：</p>
<ul>
<li>一是作为配套实验能够真正的训练学到的程序机器级表示的内容；</li>
<li>二是必不可少的一部分——实验的有趣性；</li>
<li>三是能够加强我们的调试程序的能力，终身受益（前提你是程序员:smile:）。</li>
</ul>
<h3 id="一开始"><a href="#一开始" class="headerlink" title="一开始"></a>一开始</h3><p>好了开始真正的实验部分了。</p>
<p>首先我们使用如下命令来开始调试<code>bomb</code>可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgdb bomb</span><br></pre></td></tr></table></figure>
<p>就会看到如下界面：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/bomb.png" alt></p>
<p>这是给我们的主程序，里面主要是炸弹程序的初始化，以及这些炸弹的输入以及输入检测。</p>
<p>在CGDB模式下我们可以使用<code>:set disasm</code>命令将主程序以汇编形式展示，当然使用<code>:set nodisasm</code>就会返回原来的样子。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><div class="note success no-icon">
            <p>所有炸弹拆除的思路都很简单，就是设断点，并一步步调试，找到跳转到<code>explode_bomb</code>的跳转命令，结合逻辑和寄存器的值进行判断如何避免跳转引发爆炸。</p>
          </div>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>在GDB模式下，使用<code>run</code>命令开启调试。通过输入重定向的方法避免多次输入：<code>run &lt; in.txt</code></p>
<h4 id="设断点"><a href="#设断点" class="headerlink" title="设断点"></a>设断点</h4><p>在GDB模式下，使用<code>break 行号</code>打断点</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>设置断点后，具体参照GDB手册进行调试。</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>比如想要破解Phrase1这个炸弹，需要执行以下步骤：</p>
<ul>
<li>设置调用函数断点（<code>phrase_1(input)</code>处）</li>
<li>运行至断点处并调试（<code>stepi</code>+<code>nexti</code>+<code>finish</code>+<code>continue</code>等命令）</li>
<li>进入函数内部进一步观察（使用<code>print</code>+<code>x</code>等命令）</li>
<li>分析代码得出答案</li>
</ul>
<h3 id="Phrase-Before"><a href="#Phrase-Before" class="headerlink" title="#Phrase Before"></a>#Phrase Before</h3><p>如果你是第一次做实验的话，这一步你一定要知道：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase1-input.png" alt></p>
<p>这六个炸弹都是都是通过一个<code>read_line</code>函数从输入流（不管是标准输入还是文件输入重定向）中读取的，返回值为<code>input</code>，对应于<code>%rax</code>寄存器（存放的一个输入字符串的首地址）。我们看到将<code>%rax</code>寄存器的内容转移到<code>%rdi</code>寄存器里了，我们知道寄存器<code>%rdi</code>用于存放调用函数时的第一个参数。接下来就调用炸弹函数了。</p>
<p><strong>再强调一遍，所有的炸弹函数的第一个参数<code>%rdi</code>都是我们输入的字符串的首地址。</strong></p>
<h3 id="Phrase-1"><a href="#Phrase-1" class="headerlink" title="#Phrase 1"></a>#Phrase 1</h3><p>第一个炸弹的汇编代码如下所示：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase1.png" alt></p>
<p>第一个算是一个入门的，主要是想让你熟悉一下BombLab的流程。</p>
<p>我们输入的字符串首地址在<code>%rdi</code>中；</p>
<p>②行申请了8个字节的栈空间；</p>
<p>③行将一个立即数（一看就是一个地址）存放到<code>%esi</code>寄存器（这是第二个参数）</p>
<p>④行调用了一个函数，如果你想快速通过的话不用看内部实现，是比较两个字符串是否相同。（内部比较就不说了，一个一个比较字符而已）</p>
<p>⑤行使用test命令（同<code>and</code>命令，不修改目标对象的值）来测试<code>%eax</code>中的值是否为0，如果为0则跳过引爆炸弹的函数。</p>
<p>很简单了，使用<code>x/s 0x402400</code>按字符串输出这个地址存储的内容（这个可能是我在比较字符串的函数内输出的 :smile: ）：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase1-inputstr.png" alt></p>
<p>第一弹，拆除完毕！</p>
<h3 id="Phrase-2"><a href="#Phrase-2" class="headerlink" title="#Phrase 2"></a>#Phrase 2</h3><p>第二弹，来吧勇士！（好吧，感觉有点中二。）</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase2.png" alt></p>
<p>嗯，映入我们眼前的是一个<code>&lt;read_six_numbers&gt;</code>函数，一猜也是让我们输入6个数字:</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase2-readnum.png" alt></p>
<p>然后我们查看一下这个函数内部，发现里面又调用了<code>sscanf</code>这个函数（功能是从一个字符串中读取一定格式的数据，和<code>scanf</code>一样，除了<code>scanf</code>是从标准输入流中读取）。参数顺序分别是，待读取内容的字符串、用于格式读取的格式化字符串，还有各个变量读取后存放的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format [, argument ] ... )</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们查看<code>&lt;read_six_number&gt;</code>中参数构造如下：</p>
<ul>
<li><code>%rdi</code>，输入传入的字符串首地址</li>
<li><code>%rsi</code>，由<code>0x4025c3</code>地址的字符串决定，不出意料果然是<code>%d %d %d %d %d %d</code></li>
<li><code>%rdx</code>，由<code>%rsi</code>给出，<code>%rsi</code>又由<code>phrase2</code>的<code>%rsp</code>给出，所以<code>phrase2</code>中的<code>%rsp</code>地址处存放<code>sscanf</code>中第一个输入的值</li>
<li><code>%rcx</code>，<code>phrase2</code>中的<code>%rsp+0x4</code>处存放第二个值</li>
<li><code>%r8</code>，<code>phrase2</code>中的<code>%rsp+0x8</code>存放第三个值</li>
<li><code>%r9</code>，<code>phrase2</code>中的<code>%rsp+0xc</code>存放第四个值</li>
<li>第五个、第六个值所在的地址需要通过压栈传参，由栈帧压栈顺序是从右向左压栈，可知，<code>phrase2</code>中的<code>%rsp+0x10</code>存放第五个值、<code>phrase2</code>中的<code>%rsp+0x14</code>存放第六个值。</li>
</ul>
<p>好了，知道输入的值都到哪儿去了，这样就简单了许多了，然后再看<code>phrase2</code>函数：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase2.png" alt></p>
<p>首先看<strong>&lt;+14&gt;</strong>处，第一个数必须是1，不是炸弹就爆炸。</p>
<p>不是就跳到<strong>&lt;+52&gt;</strong>处，然后<strong>&lt;+27&gt;</strong>到<strong>&lt;+52&gt;</strong>构成一个循环，意思是比较后一个数必须是前一个数的两倍。</p>
<p>那答案就出来了：<code>1 2 4 8 16 32</code></p>
<h3 id="Phrase-3"><a href="#Phrase-3" class="headerlink" title="#Phrase 3"></a>#Phrase 3</h3><p>好了，兄嘚，第三炮！</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase3.png" alt></p>
<p>输入还是<code>sscanf</code>函数，同理，<code>%rdi</code>是我们输入的，<code>%rsi</code>是<code>format</code>打印一下看是<code>%d %d</code>，需要两个地址存放，分别是<code>%rdx</code>和<code>%rcx</code>，对应于<code>%rsp+0x8</code>和<code>%rsp+0xc</code>。输入完成后，查看返回值<code>%eax</code>必须大于1，两个输入必然是最满足要求的。满足之后，我们来到了<strong>&lt;+39&gt;</strong>的位置，我们比较第一个输入值<code>x</code>和7，如果第一个<code>x</code>大于7则爆炸，所以<code>x</code>是&lt;=7的。</p>
<p>接下来将x值放入<code>%eax</code>寄存器，然后通过间接跳转跳转到<code>0x402470+8*%eax</code>地址所存储的地址。我们可以看到这个跳转目标和输入有关的。然后我们可以输出相应的地址，发现跳转的地址刚好是修改<code>%eax</code>的地方，最终<code>%eax</code>都要和第二个数<code>y</code>（<code>%rsp+0xc</code>地址存储的值）相等。</p>
<p>就比如说x为0，则跳转到<code>0x402470</code>的地址中存储的地址（<strong>&lt;+57&gt;</strong>的位置），将<code>%eax</code>修改为0xcf（十进制207），然后跳转到<strong>&lt;+123&gt;</strong>处比较0xcf和<code>y</code>值，相等才不会爆炸。所以结果可以输入<code>0 207</code>。</p>
<p>答案还有好几个，不一一列举了！</p>
<h3 id="Phrase-4"><a href="#Phrase-4" class="headerlink" title="#Phrase 4"></a>#Phrase 4</h3><p>第四弹！</p>
<p>主要考察递归函数调用（当然你也可以避过这个问题！）</p>
<p>先看主要部分代码：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase4.png" alt></p>
<p>通过这个程序我们可以分析出，除了输入函数和爆炸函数之外，还调用了一个<code>func4</code> 函数。输入的是两个数字，存于<code>%rsp+0x8</code>和<code>%rsp+0xc</code>处。我们还可以分析出，<strong>调用这个函数之后返回值<code>%eax</code>必须为0，而且第二个输入的数必须为0。</strong></p>
<p>我们再看传入的参数：</p>
<ul>
<li><code>%rdi</code>：第一个数，记作x</li>
<li><code>%rsi</code>：0</li>
<li><code>%rdx</code>：0xe，即14</li>
<li><code>%rcx</code>：第二个数，记作y。不确定会不会用到，看到下面的代码很显然没用使用到，直接被覆盖了。</li>
</ul>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase4-func.png" alt></p>
<p>查看代码，如果你进入了递归是太恶心了，不过也可以分析，好像要求输入x值必须满足是一个数列的元素。那么如何避免递归，看<strong>&lt;+22&gt;</strong>行，可以分析出此时<code>%ecx</code>的值为7，如果<code>%edi</code>也就是x值如果&gt;=7的话，那就会跳转到<strong>&lt;+36&gt;</strong>，此时将<code>%eax</code>置位0（满足返回值为0），然后再比较刚比较的<code>%edi</code>和<code>%ecx</code>，如果<code>%edi</code>&lt;=7的话就结束。所以最终x=7满足条件。</p>
<p>所以很简单的答案，<code>7 0</code>。递归的值没仔细考虑，实在是递归太难调试了，可能是自己没掌握到方法。很遗憾。</p>
<h3 id="Phrase-5"><a href="#Phrase-5" class="headerlink" title="#Phrase 5"></a>#Phrase 5</h3><p>第五发！</p>
<p>这个也比较有趣，主要是涉及到了ASCII码，感觉真的是在破译代码，解除炸弹！</p>
<p>下面就是代码：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase5.png" alt></p>
<p>首先我们看到了<code>%fs</code>寄存器，这是用于存储<code>当前活动线程的TEB结构</code>地址的一个寄存器，和解题无关，可以不用在意。</p>
<p>首先输入的字符串地址在<code>%rdi</code>中，然后调用<code>string_length</code>函数，可以看电脑返回值<code>%eax</code>必须为6，也就是输入的字符串长度必须为6。</p>
<p>接下来的一段程序主要是以下作用：</p>
<ul>
<li>取6个ASCII码低4位，记作<code>low4[i]</code>。</li>
<li>将<code>low4[i]</code>作为偏移量和常量A（0x4024b0）相加作为地址取得改地址存储的字符<code>character[i]</code></li>
<li>将这一系列字符<code>character</code>分别存于<code>%rsp+0x10</code>到<code>%rsp+0x15</code></li>
<li>调用<code>strings_not_equal</code>比较这些字符和存于<strong>0x40245e</strong>的字符串（flyers）是否相等，相等则结束</li>
</ul>
<p>那么很简单了！</p>
<p>常量A地址开始存储的是什么字符？（忘了截图了……），是<code>maduiersnfotvbyl</code>共16个。我们找到<code>flyers</code>这六个字符的相对偏移地址用16进制表示分别为<code>9fe567</code>，然后据此查找ASCII码查看低四位相同的字符（答案不固定，我找到的是<code>ionufg</code>）。</p>
<p>完事！</p>
<h3 id="Phrase-6"><a href="#Phrase-6" class="headerlink" title="#Phrase 6"></a>#Phrase 6</h3><p>最后一弹，是有点难度的，一定要找一个比较好的环境做，需要大约2个小时的时间。争取一次性完成。</p>
<p>这一弹主要是考察循环了，循环炒鸡多有木有！另外还需要知道链表的结构。</p>
<p>由于代码太多，就不一一写了，主要是写一下代码的作用。</p>
<p>代码如下：</p>
<p>首先是第一部分：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase6-1.png" alt></p>
<p>首先读入了6个数字，分别放入了<code>%rsp+0x0、%rsp+0x4、%rsp+0x8、%rsp+0xc、%rsp+0x10、%rsp+0x14</code></p>
<p>这是第一个大循环，<strong>&lt;+32&gt;</strong>到<strong>&lt;+93&gt;</strong>行，内嵌一个小循环<strong>&lt;+65&gt;</strong>到<strong>&lt;+87&gt;</strong>行。大循环中部分的作用是确定每个数必须&lt;=6；小循环的作用是确定第<code>i</code>个数不和第<code>i+1</code>~第<code>6</code>个数相同（也就是输入的所有数字不能有相同的）。</p>
<p>接下来再看剩下的部分：</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase6-2.png" alt="2"></p>
<p>首先有个循环<strong>&lt;+103&gt;</strong>到<strong>&lt;+121&gt;</strong>，主要作用就是令<code>a[i]=7-a[i],i=1,2,3,4,5,6</code>，就是将存于栈中的数（也是你输入的数）进行对7求补并保存回原位置。</p>
<p>接下来又有一个大循环<strong>&lt;+130&gt;</strong>到<strong>&lt;+181&gt;</strong>部分，里面嵌入了一个小循环<strong>&lt;+130&gt;</strong>到<strong>&lt;+139&gt;</strong>。主要作用是访问一个链表，链表的首地址为<code>0x6032d0</code>，针对输入的第<code>i</code>个数，按照<code>a[i]</code>的值获取链表第<code>a[i]</code>个节点，并把节点首地址放入<code>%rsp+0x20+0x0</code>~到<code>%rsp+0x20+0x28</code>刚好是6个节点。</p>
<p>然后下面一段代码，又是一个循环<strong>&lt;+235&gt;</strong>到<strong>&lt;+257&gt;</strong>，主要是说明<code>%rsp+0x20+0x0</code>~到<code>%rsp+0x20+0x28</code>存储的链表节点值必须是递减的。</p>
<p>下面打印的是这六个节点的值和指向下一个节点的地址。</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/phrase6-linklist.png" alt></p>
<p>找到了各节点的值，我们就可以排序得到节点标号的排序，节点标号的排序恰恰是输入6个数字对7求补的值，然后再对7求补即可得到结果<code>4 3 2 1 6 5</code>。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>完成的一瞬家很爽！秀一下结果！</p>
<p><img src="/images/loading.gif" data-original="/csapp-lab-2/success.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实验真的是收货颇丰，一是完成了大名鼎鼎的bomblab，二是切切实实的学到了新东西。</p>
<h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><ul>
<li>相对于上次实验，感觉动手能力变强了</li>
<li>自己有一些浮躁</li>
<li>实验时有时走神，（主要是没有草稿时是这样的，没草稿直接看是很难看出答案的。。我太菜。）</li>
</ul>
<h3 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h3><ul>
<li>学会了GDB的使用方法，对调试又有了一定的认识</li>
<li>彻底理解了栈帧的设计</li>
<li>熟悉了一些常用寄存器的用途</li>
<li>熟悉了AT&amp;T x86-64汇编指令</li>
</ul>
<h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><ol>
<li>实验时要草稿纸，好记性不如烂笔头</li>
<li>静下心来，莫浮躁，循序渐进。</li>
<li>阅读英文书籍，增强英语环境下的学习能力</li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
        <tag>CSAPP Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>DIP中常见的核</title>
    <url>/digital-image-kernel-collection.html</url>
    <content><![CDATA[<div class="note default">
            <p>一二三四五，六七八九十。</p>
          </div>
<a id="more"></a>
<hr>
<div class="note default">
            <p><strong>文章暂未完成</strong></p>
          </div>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>DIP（Digital Image Processing）中的核可以看做是一个模具，可以作用于每个像素。每种核作用图像后会得到不同的结果，本文主要是记录一些常见的“核”</p>
<p>视频见<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1pekR1NXpkampZQQ==" title="https://www.youtube.com/watch?v=izDu5zdjjYA">YOUTOBE<i class="fa fa-external-link"></i></span></p>
<div class="note info">
            <h2 id="核是什么"><a href="#核是什么" class="headerlink" title="核是什么"></a>核是什么</h2><p>核可以看做是一个模具，也叫做模板，有时也称算子。模板操作是数字图像处理中常用的一种邻域运算方式，主要有卷积和相关两种，可以实现图像平滑、图像锐化、边缘检测等功能。</p><ul><li>核常用矩阵表示。可以是一幅图像、一个滤波器或一个窗口，定义了参与运算的中心元素和邻域元素的相对位置及相关系数。卷积时常采用3×3或者5×5大小。</li><li>模板的中心元素（或称原点）表示将要处理的元素， 一般取模板中心点，也可根据需要选取非中心点。</li></ul>
          </div>
<h2 id="常见的核"><a href="#常见的核" class="headerlink" title="常见的核"></a>常见的核</h2><div class="note primary">
            <h3 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h3>
          </div>
<h4 id="邻域平均滤波"><a href="#邻域平均滤波" class="headerlink" title="邻域平均滤波"></a>邻域平均滤波</h4><blockquote>
<p>邻域平均法是一种线性低通滤波器。<strong>可滤除一定的噪声。</strong></p>
</blockquote>
<ul>
<li>第一种</li>
</ul>
<p>$$<br>    \frac{1}{9}\times<br>    \begin{bmatrix}<br>        1&amp;1&amp;1\\<br>        1&amp;1&amp;1\\<br>        1&amp;1&amp;1<br>    \end{bmatrix}<br>$$</p>
<ul>
<li>第二种</li>
</ul>
<p>$$<br>    \frac{1}{16}\times<br>    \begin{bmatrix}<br>       1&amp;2&amp;1\\<br>       2&amp;4&amp;2\\<br>       1&amp;2&amp;1<br>    \end{bmatrix}<br>$$</p>
<h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><blockquote>
<p>是一种非线性滤波，<strong>找出核内的中位数当做结果</strong>。</p>
</blockquote>
<p>$$<br>       Midian(<br>           \begin{bmatrix}<br>             a&amp;b&amp;c\\<br>             d&amp;e&amp;f\\<br>             g&amp;h&amp;i<br>           \end{bmatrix})<br>$$</p>
<div class="note primary">
            <h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3>
          </div>
<blockquote>
<p>用于检测图像中一些物体边缘的地方。比如无人机、自动驾驶障碍物检测等会使用到。</p>
</blockquote>
<p>主要方法有以下几种：</p>
<h4 id="Prewitt"><a href="#Prewitt" class="headerlink" title="Prewitt"></a>Prewitt</h4><blockquote>
<p>引入了平均因素，对噪声有抑制作用；操作简便。</p>
</blockquote>
<ul>
<li>垂直边缘检测算子</li>
</ul>
<p>$$<br>           \begin{bmatrix}<br>             -1&amp;0&amp;1\\<br>             -1&amp;0&amp;1\\<br>             -1&amp;0&amp;1<br>           \end{bmatrix}<br>$$</p>
<ul>
<li>水平边缘检测算子</li>
</ul>
<p>$$<br>           \begin{bmatrix}<br>             -1&amp;-1&amp;-1\\<br>             0&amp;0&amp;0\\<br>             1&amp;1&amp;1<br>           \end{bmatrix}<br>$$</p>
<h4 id="Sobel"><a href="#Sobel" class="headerlink" title="Sobel"></a>Sobel</h4><blockquote>
<p>引入了平均因素，增强了最近像素的影像，噪声抑制效果比Prewitt好。</p>
</blockquote>
<ul>
<li>垂直边缘检测算子</li>
</ul>
<p>$$<br>           \begin{bmatrix}<br>             -1&amp;0&amp;1\\<br>             -2&amp;0&amp;2\\<br>             -1&amp;0&amp;1<br>           \end{bmatrix}<br>$$</p>
<ul>
<li>水平边缘检测算子</li>
</ul>
<p>$$<br>           \begin{bmatrix}<br>             -1&amp;-2&amp;-1\\<br>             0&amp;0&amp;0\\<br>             1&amp;2&amp;1<br>           \end{bmatrix}<br>$$</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图处理</title>
    <url>/grayscale-histogram-resolver.html</url>
    <content><![CDATA[<div class="note default">
            <p>就像望远镜之于天文学，计算机科学不仅仅是计算机。—— Edsger Dijkstra</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解了BMP文件的格式，下面就开始真正的进行图像处理了，首先是图像增强，本文主要写灰度直方图和根据灰度直方图均衡化8位灰度图</p>
<h2 id="直方图统计"><a href="#直方图统计" class="headerlink" title="直方图统计"></a>直方图统计</h2><h3 id="什么是灰度直方图"><a href="#什么是灰度直方图" class="headerlink" title="什么是灰度直方图"></a>什么是灰度直方图</h3><p>灰度直方图用于显示图片各像素灰度的分布情况，即各个灰度级有多少个像素点。</p>
<h3 id="直方图的作用"><a href="#直方图的作用" class="headerlink" title="直方图的作用"></a>直方图的作用</h3><p>能够看到直方图的灰度分布，以观测图像的各类属性，比如图像偏亮还是偏暗，图像灰度是否集中等。</p>
<p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/1552526052073.png" alt="1552526052073"></p>
<h3 id="如何获得直方图"><a href="#如何获得直方图" class="headerlink" title="如何获得直方图"></a>如何获得直方图</h3><blockquote>
<p>用C语言手撸BMP图片真是shxt。。</p>
</blockquote>
<ol>
<li>24位真彩色需要计算得到8位灰度图</li>
<li>统计各灰度级像素个数</li>
<li>计算各灰度级概率密度</li>
<li>获得直方图</li>
</ol>
<h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><h3 id="什么是直方图均衡化"><a href="#什么是直方图均衡化" class="headerlink" title="什么是直方图均衡化"></a>什么是直方图均衡化</h3><p><strong>直方图均衡化</strong>是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUJFJUU1JTgzJThGJUU1JUE0JTg0JUU3JTkwJTg2" title="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86">图像处理<i class="fa fa-external-link"></i></span>领域中利用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUJFJUU1JTgzJThG" title="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F">图像<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlCJUI0JUU2JTk2JUI5JUU1JTlCJUJF" title="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE">直方图<i class="fa fa-external-link"></i></span>对<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThEJUU2JUFGJTk0JUU1JUJBJUE2" title="https://zh.wikipedia.org/wiki/%E5%B0%8D%E6%AF%94%E5%BA%A6">对比度<i class="fa fa-external-link"></i></span>进行调整的方法。</p>
<h3 id="为什么要均衡化"><a href="#为什么要均衡化" class="headerlink" title="为什么要均衡化"></a>为什么要均衡化</h3><blockquote>
<p>摘自<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlCJUI0JUU2JTk2JUI5JUU1JTlCJUJFJUU1JTlEJTg3JUU4JUExJUExJUU1JThDJTk2" title="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96">维基百科<i class="fa fa-external-link"></i></span></p>
</blockquote>
<p>这种方法通常用来增加许多图像的全局对比度，尤其是当图像的有用数据的对比度相当接近的时候。通过这种方法，亮度可以更好地在直方图上分布。这样就可以用于增强局部的对比度而不影响整体的对比度，直方图均衡化通过有效地扩展常用的亮度来实现这种功能。</p>
<p>这种方法对于背景和前景都太亮或者太暗的图像非常有用，这种方法尤其是可以带来X光图像中更好的骨骼结构显示以及曝光过度或者曝光不足照片中更好的细节。这种方法的一个主要优势是它是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大。这种方法的一个缺点是它对处理的数据不加选择，它可能会增加背景噪声的对比度并且降低有用信号的对比度。</p>
<h3 id="如何均衡化"><a href="#如何均衡化" class="headerlink" title="如何均衡化"></a>如何均衡化</h3><div class="note primary">
            <p><strong>本例使用灰度<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI0JUFGJUU3JUE3JUFGJUU1JTg4JTg2JUU1JUI4JTgzJUU1JTg3JUJEJUU2JTk1JUIw" title="https://zh.wikipedia.org/wiki/%E7%B4%AF%E7%A7%AF%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0">累积分布函数<i class="fa fa-external-link"></i></span>均衡化</strong></p>
          </div>
<ol>
<li>得到原图灰度级概率分布函数$P_r$（离散的）</li>
<li>计算原图灰度级累计分布函数（Cumulative distribution function，CDF）S</li>
<li>通过CDF和原图灰度级取近似得到新的灰度级</li>
</ol>
<p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/1552461156688.png" alt="1552461156688"></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote>
<p>版权问题请联系，侵删！</p>
</blockquote>
<h3 id="24位真彩色（原图）"><a href="#24位真彩色（原图）" class="headerlink" title="24位真彩色（原图）"></a>24位真彩色（原图）</h3><p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/1.png" alt></p>
<h3 id="8位灰度图（转化后的8位灰度图）"><a href="#8位灰度图（转化后的8位灰度图）" class="headerlink" title="8位灰度图（转化后的8位灰度图）"></a>8位灰度图（转化后的8位灰度图）</h3><p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/2.png" alt></p>
<h3 id="均衡化8位灰度图（根据8位灰度图均衡化后的灰度图）"><a href="#均衡化8位灰度图（根据8位灰度图均衡化后的灰度图）" class="headerlink" title="均衡化8位灰度图（根据8位灰度图均衡化后的灰度图）"></a>均衡化8位灰度图（根据8位灰度图均衡化后的灰度图）</h3><p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/3.png" alt></p>
<h3 id="未均衡化8位灰度图的统计直方图"><a href="#未均衡化8位灰度图的统计直方图" class="headerlink" title="未均衡化8位灰度图的统计直方图"></a>未均衡化8位灰度图的统计直方图</h3><p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/4.png" alt></p>
<h3 id="均衡化8位灰度图的统计直方图"><a href="#均衡化8位灰度图的统计直方图" class="headerlink" title="均衡化8位灰度图的统计直方图"></a>均衡化8位灰度图的统计直方图</h3><p><img src="/images/loading.gif" data-original="/grayscale-histogram-resolver/5.png" alt></p>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>未考虑24位真彩色的均衡化处理。</p>
<blockquote>
<p>实际上，对彩色分量rgb分别做均衡化，会产生奇异的点，图像不和谐。一般采用的是用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFNMJUU1JTkyJThDSFNWJUU4JTg5JUIyJUU1JUJEJUE5JUU3JUE5JUJBJUU5JTk3JUI0" title="https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">HSL和HSV色彩空间<i class="fa fa-external-link"></i></span>进行亮度的均衡即可。（摘自<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlCJUI0JUU2JTk2JUI5JUU1JTlCJUJFJUU1JTlEJTg3JUU4JUExJUExJUU1JThDJTk2" title="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96">维基百科<i class="fa fa-external-link"></i></span>）</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="note primary">
            <p><strong>全部代码请查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">GitHub<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BMPHelper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HistogramStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 24位真彩色转8位灰度</span></span><br><span class="line"></span><br><span class="line">	BMP24To8Gray(<span class="string">"1.bmp"</span>, <span class="string">"2.bmp"</span>);</span><br><span class="line"></span><br><span class="line">	BMFILEHEADER header;</span><br><span class="line">	INFOHEADER info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ** data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBITEM*));</span><br><span class="line">	RGBQUAD ** palette = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBQUAD*));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> pixelCounts = BMPReader8(<span class="string">"2.bmp"</span>, &amp;header, &amp;info, palette, data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> histogram[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">double</span> grayscaleDistribution[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">double</span> cumulativeDistribution[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//8位灰度统计</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pixelCounts; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		histogram[*(*data+i)]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		grayscaleDistribution[i] = histogram[i] * <span class="number">1.0</span> / pixelCounts;</span><br><span class="line">		<span class="comment">//求cdf</span></span><br><span class="line">		<span class="keyword">if</span> (i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cumulativeDistribution[i] = grayscaleDistribution[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cumulativeDistribution[i] = cumulativeDistribution[i - <span class="number">1</span>] + grayscaleDistribution[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">/*	if (grayscaleDistribution[i] * 100.0 &lt;0.01)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			continue;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		printf("灰度级【%3d】统计像素概率：%4.2f%%\n", i, grayscaleDistribution[i]*100);*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pixelCounts; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> newGray = (<span class="keyword">int</span>)(cumulativeDistribution[*(*data + i)] * (L<span class="number">-1</span>) + <span class="number">0.5</span>);</span><br><span class="line">		*(*data + i) = newGray;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> histogramLatest[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">double</span> grayscaleDistributionLatest[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pixelCounts; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		histogramLatest[*(*data + i)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		grayscaleDistributionLatest[i] = histogramLatest[i] * <span class="number">1.0</span> / pixelCounts;</span><br><span class="line">	&#125;</span><br><span class="line">	BMPWriter8(<span class="string">"3.bmp"</span>, &amp;header, &amp;info, palette, data);</span><br><span class="line">	outputGrayscaleHistogram(<span class="string">"4.bmp"</span>, grayscaleDistribution, &amp;info);</span><br><span class="line">	outputGrayscaleHistogram(<span class="string">"5.bmp"</span>, grayscaleDistributionLatest, &amp;info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f\n"</span>, cumulativeDistribution[L - <span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//BMPWriter("histogramout.bmp", &amp;header, &amp;info, palette, data);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>5G会带来哪些技术发展</title>
    <url>/5g-technology-advent.html</url>
    <content><![CDATA[<div class="note primary">
            <p>网速已不是桎梏，那桎梏在哪里？</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>5G会带来哪些技术发展？这个问题在看到华为1月13日深圳首测5G新闻时便在思考。和别人交流时也不经意间挑起了这个话题，想借此机会写一写。当然这仅代表个人看法，很有可能有些观点是不对的，也欢迎大家在评论区共同探讨。</p>
<h2 id="5G有什么新特性"><a href="#5G有什么新特性" class="headerlink" title="5G有什么新特性"></a>5G有什么新特性</h2><p>我们知道3G、4G，那5G就是下一代（next generation）移动通信技术了。</p>
<p>可能会对某些名词很陌生，不过一些比较值得我们关心的特性还是比较清楚的。</p>
<p>1月14日央视新闻公众号发表了一篇文章<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TVRJME1EVTNORFl3TVE9PSZhbXA7bWlkPTI2NTY3MzE1OTgmYW1wO2lkeD0xJmFtcDtzbj03MmJiNzM0MDc2YTc1NzgxMzU1ZTYwN2JmOTJlZTEzOCZhbXA7Y2hrc209N2E2MDdjMjg0ZDE3ZjUzZTZkNDYxNTFiM2NjMTMyOTg0MzIyYmFiNjBkY2FjODVhMzY3YTMwMDlmYzZlMGNhNzEwZWEyOTA5NDI3MyZhbXA7bXBzaGFyZT0xJmFtcDtzY2VuZT0yMyZhbXA7c3JjaWQ9MDExNDBXczcwb01tbEl3M0daeTcxWHVwI3Jk" title="https://mp.weixin.qq.com/s?__biz=MTI0MDU3NDYwMQ==&amp;mid=2656731598&amp;idx=1&amp;sn=72bb734076a75781355e607bf92ee138&amp;chksm=7a607c284d17f53e6d46151b3cc132984322bab60dcac85a367a3009fc6e0ca710ea29094273&amp;mpshare=1&amp;scene=23&amp;srcid=01140Ws70oMmlIw3GZy71Xup#rd">《比Wi-Fi快60多倍，比高清清晰4倍！5G+4K，是时候“种草”了！》<i class="fa fa-external-link"></i></span>。值得我们关注的就是网速。</p>
<h3 id="速度有多快"><a href="#速度有多快" class="headerlink" title="速度有多快"></a>速度有多快</h3><p>5G理论速率峰值达10Gb/s，1.25GB/s，<strong>50GB的游戏1分钟之内下完</strong>。当然这只是理论上的峰值，一般是低于峰值的，需要考虑信号强弱和网络拥塞等情况。</p>
<p>相对应的，现在用的比较多的是如下几种媒介：</p>
<ul>
<li>家用千兆带宽（并不常见），理论速率峰值1Gb/s，0.125GB/s，<strong>50GB的游戏需下载近10分钟</strong>。</li>
<li>主流手机连Wi-Fi理论速率峰值150Mb/s，18.75MB/s，<strong>50G游戏下载近1小时</strong></li>
<li>家庭常用100M宽带，理论速率峰值100Mb/s，12.5MB/s，<strong>50G游戏下载1-2小时</strong></li>
<li>4G网络，理论速率峰值同家用100M宽带</li>
</ul>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>由于物理波段的限制，也将会与其他通信技术并用，包含长距离的其他传统电信波段。</p>
<h2 id="带来的技术发展——云硬盘（实现真正的存储器层次结构最后一层）"><a href="#带来的技术发展——云硬盘（实现真正的存储器层次结构最后一层）" class="headerlink" title="带来的技术发展——云硬盘（实现真正的存储器层次结构最后一层）"></a>带来的技术发展——云硬盘（实现真正的存储器层次结构最后一层）</h2><p>这是我想到的第一条，而且应该是应用更为大众化的。而且不仅仅是云硬盘，与之相连的<strong>一系列云服务</strong>都会大量使用，因为网速不再是瓶颈，<strong>云服务和本地服务几乎没有差距</strong>，而且云服务计算可能更为迅速。能观看高质量视频、VR视频等都是网速加快直接导致的结果，在此不谈。</p>
<p>为什么是云硬盘呢？</p>
<p>谈到硬盘，这就想到了去年买iPad2018，32GB本地存储存存文档还可以，小电影能存得了几部？（兄嘚，评论区借一部说话？ :smile:）</p>
<p>最终说动我自己下定决心的就是想到了存储器层次结构（本地存储不够，那就百度云呗。按局部性原理需求换入换出）</p>
<p>存储器层次结构：</p>
<p><img src="/images/loading.gif" data-original="/5g-technology-advent/1552395582880.png" alt></p>
<p>5G时代的到来，打破了网速的桎梏，这不就是实现了真正的<strong>存储器层次结构</strong>的最后一层吗？</p>
<div class="note info">
            <p>这一系列与云硬盘相关的技术的有哪些？</p><ul><li>云硬盘，当做本地磁盘的大众使用</li><li>云应用<ul><li>简单的Webapp、小程序的大型化</li><li>Native APP和PC APP的云应用化，需要一套解决方案来解决云端和本地的换入换出问题（是直接传输已安装的二进制+配置文件还是每次都需要安装？）</li><li>云游戏，这既包含NativeAPP还有PC端还有各种平台的云游戏。这不最近腾讯出了个云游戏服务平台<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBM05UWXpPRFl6TWc9PSZhbXA7bWlkPTI2NTM1ODAxNDgmYW1wO2lkeD0xJmFtcDtzbj0xNGIxYTYwMjkxOGJiMzc2ZGZhNTNhMzY5MjUyYmI0MyZhbXA7Y2hrc209ODRiM2I5NzNiM2M0MzA2NTU3OTY4ZDJhZGZlMDYyMDZkMmQ0ZmM0OTUyYjgzYzdjOGI1ZmJhZmRmMDc1MTNiN2FkNzczYzg4YWQ3NCZhbXA7bXBzaGFyZT0xJmFtcDtzY2VuZT0yMyZhbXA7c3JjaWQ9I3Jk" title="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653580148&amp;idx=1&amp;sn=14b1a602918bb376dfa53a369252bb43&amp;chksm=84b3b973b3c4306557968d2adfe06206d2d4fc4952b83c7c8b5fbafdf07513b7ad773c88ad74&amp;mpshare=1&amp;scene=23&amp;srcid=#rd">CMatrix<i class="fa fa-external-link"></i></span></li></ul></li><li>好吧，暂时想不出来还有啥了</li></ul>
          </div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到一开始的问题：网速已不是桎梏，那桎梏在哪里？硬件和软件，网络协议能不能有更好的更快速的更安全的算法；硬件能不能更快一点。</p>
<p>第一次写这种主观性的技术文章，可能有些逻辑和文章结构可能不够严谨。如果有什么好的建议请在评论区和右下角DAOVoice联系。多谢！</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Technology</tag>
        <tag>5G</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的字节对齐</title>
    <url>/byte-alignment.html</url>
    <content><![CDATA[<div class="note default">
            <p>凡事皆有因，刨根问底，追求极致。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="bitmap-resolver.html">BMP文件处理（C语言实现）</a>一文中说到文件头的自定义结构体会引起“字节对齐效应”，进而造成文件读取属性错位，严重造成读取错误。这篇文章主要回顾总结一下字节对齐问题。内容总结自《深入理解计算机系统》。</p>
<h2 id="什么是字节对齐"><a href="#什么是字节对齐" class="headerlink" title="什么是字节对齐"></a>什么是字节对齐</h2><p>许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K（通常是2，4，8）的倍数。</p>
<div class="note info">
            <p><strong><em>无论是否对齐，x86-64硬件都能正常工作。不过Intel还是建议要对齐数据以提高内存系统的性能。</em></strong></p>
          </div>
<h2 id="字节对齐有什么好处"><a href="#字节对齐有什么好处" class="headerlink" title="字节对齐有什么好处"></a>字节对齐有什么好处</h2><p>字节对齐有一些隐含的好处：</p>
<ul>
<li>简化形成处理器和内存系统之间的硬件设计。</li>
<li>提高内存系统的效率<ul>
<li>例如一个处理器总是从内存中读取8个字节，那么地址必须为8的倍数。比如说double类型，如果地址为8的倍数只需要读取1次就能获得，否则可能需要执行两次内存访问，因为数据放到了两个8字节内存块中。</li>
</ul>
</li>
</ul>
<h2 id="字节对齐原则"><a href="#字节对齐原则" class="headerlink" title="字节对齐原则"></a>字节对齐原则</h2><div class="note primary">
            <p><strong><em>任何K字节大小的基本对象的地址必须是K的倍数。，“对于结构体，结构体的地址是结构体内最大元素大小的整数倍，结构体的大小是结构体内最大元素字节大小的整数倍”。</em></strong></p>
          </div>
<h3 id="一些基础数据类型的对齐方式"><a href="#一些基础数据类型的对齐方式" class="headerlink" title="一些基础数据类型的对齐方式"></a>一些基础数据类型的对齐方式</h3><p>一些常见的基本类型根据字节对齐原则获得的对齐地址方式如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">K</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">short</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">int,float</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">long,double,char*</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：这些类型都是在x86-64位某些特定机下的64位模式运行时对齐方式。</p>
</blockquote>
<p>确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐。</p>
<p>比如我的电脑是x86-64位机，但是针对VS有x86和x64两种模式。这有不同的结果：</p>
<ol>
<li><p><strong>x86</strong></p>
<p><img src="/images/loading.gif" data-original="/byte-alignment/x86-size.png" alt></p>
</li>
<li><p><strong>x64</strong></p>
</li>
</ol>
<p><img src="/images/loading.gif" data-original="/byte-alignment/x64-size.png" alt></p>
<div class="note danger">
            <p>于是类型所占字节大小不同，所以K值不同。不管类型大小为多少个字节，只要根据字节对齐原则就可以了。</p>
          </div>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><h3 id="汇编命令"><a href="#汇编命令" class="headerlink" title="汇编命令"></a>汇编命令</h3><p>编译器在汇编代码中放入命令，指明全局数据所需的对齐。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.align 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该命令保证了它后面的变量的起始地址是8的倍数。</p>
</blockquote>
<h3 id="结构体的字节对齐"><a href="#结构体的字节对齐" class="headerlink" title="结构体的字节对齐"></a>结构体的字节对齐</h3><ol>
<li>eg-1</li>
</ol>
<p>编译器会对包含结构体的代码内部需要的字段插入间隙，以满足对其要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>int和char的大小分别是4个字节、1个字节。假设编译器用最小的9字节分配，画出来是这样的：</p>
<p><img src="/images/loading.gif" data-original="/byte-alignment/1552037289894.png" alt="1552037289894"></p>
<blockquote>
<p>这样int变量i和j是无法同时满足对齐原则的。</p>
</blockquote>
<p>取而代之，编译器在字段c和j之间插入一个3字节的间隙（蓝色部分）。</p>
<p><img src="/images/loading.gif" data-original="/byte-alignment/1552037549973.png" alt="1552037549973"></p>
<div class="note danger">
            <p>此外，编译器必须保证任何 <code>Struct S1 *</code> 类型的指针p都满足4字节对齐。这样保证了首元素（变量i）是4字节对齐，而且内部变量也都是4字节对齐了。</p>
          </div>
<ol start="2">
<li>eg-2</li>
</ol>
<p>对于结构体数组，编译器可能会在结构体末尾进行填充来满足其对齐要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果用最小的9字节分配，很明显只要保证结构体初始地址是4字节倍数就可满足对齐要求。</p>
<p>但是针对结构数组，有连续的元素，9字节分配就无法保证字节对齐要求了，如下声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> <span class="title">d</span>[4];</span></span><br></pre></td></tr></table></figure>
<p>这就需要编译器对结构体末尾进行填充。当然最后3个字节是浪费的空间。如下图：</p>
<p><img src="/images/loading.gif" data-original="/byte-alignment/1552038354295.png" alt="1552038354295"></p>
<h2 id="强制对齐"><a href="#强制对齐" class="headerlink" title="强制对齐"></a>强制对齐</h2><p>如果数据没有对齐，某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，就无法正确执行。</p>
<div class="note primary">
            <p>任何针对x68-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须满足16字节对齐。</p>
          </div>
<p>这个要求的后果：</p>
<ol>
<li>任何内存分配函数（alloca、malloc、calloc或realloc）生成的块的起始地址都必须是16的倍数。</li>
<li>大多数函数栈帧的边界都必须是16的倍数。</li>
</ol>
<p>不过较近版本的x86-64处理器实现了AVX多媒体指令。除了提供SSE指令的超集，支持AVX的指令并没有强制性的对齐要求。</p>
<h2 id="如何避免字节对齐引发的问题"><a href="#如何避免字节对齐引发的问题" class="headerlink" title="如何避免字节对齐引发的问题"></a>如何避免字节对齐引发的问题</h2><p>另谈！待续……</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面向位级的理解是很有必要的，比如这次BMP文件的读写，读写文件头自定义数据结构而没有用Windows.h里的宏定义，这引发的问题就是对字节对齐这个概念还不够敏感。所以基础不牢，地动山摇；原理不解，实践何解？</p>
]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>BMP文件的特殊宽度处理及字节对齐问题</title>
    <url>/bitmap-resolver-rectify.html</url>
    <content><![CDATA[<div class="note default">
            <p>所见所观，皆为虚幻。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="bitmap-resolver.html">BMP文件处理（C语言实现）</a>这篇文章中说到了两个不足之处：</p>
<ul>
<li>文件头的字节对齐问题</li>
<li>BMP文件的特殊宽度处理问题</li>
</ul>
<p>对于字节对齐，可以查看<a href="byte-alignment.html">计算机的字节对齐</a>这篇文章。本篇文章主要写对BMP文件的特殊宽度处理。</p>
<h2 id="文件头的字节对齐问题"><a href="#文件头的字节对齐问题" class="headerlink" title="文件头的字节对齐问题"></a>文件头的字节对齐问题</h2><p>上次文章中写到的BMP文件头的结构体是下文中代码块这样的，结合字节对齐规则，<strong>“K大小的基本数据类型的地址必须是K的倍数”，“对于结构体，结构体的地址是结构体内最大元素字节大小的整数倍，结构体的大小是结构体内最大元素字节大小的整数倍”。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapFileHeader</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> type[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> resvered1[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> reserved2[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> offset;</span><br><span class="line">&#125; BMFILEHEADER;</span><br></pre></td></tr></table></figure>
<p>但是，实际要求BMP文件头大小必须是14，而针对以上结构体进行<code>sizeof()</code>运算得到的数值是<strong>16</strong>。结果显然是错误的，错误原因如下所示：</p>
<ol>
<li>结构体大小必须是结构体内最大元素字节大小的整数倍（最大的是unsigned，4字节）（<em>所以肯定不是</em>14）。</li>
<li>结构体的地址是结构体内最大元素字节大小的整数倍，在此假设一个结构体首地址是0</li>
</ol>
<p>下图便是划分图：</p>
<p><img src="/images/loading.gif" data-original="/bitmap-resolver-rectify/1552183022513.png" alt="1552183022513"></p>
<p>对于char数组而言，并无特殊字节对齐要求，但是对于unsigned类型，需要首地址为4的倍数。因此在type字段后面的两个字节需要填充。</p>
<p>这样，结构体的大小为最大元素大小4的倍数，结构体的地址是最大元素字节的整数倍。所以结果总大小为16。</p>
<p>那么应该怎么写呢？需要14个字节的大小的BMP文件头。为了简单起见，我是这么写的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapFileHeader</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> type[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> size[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> resvered1[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> reserved2[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> offset[<span class="number">4</span>];</span><br><span class="line">&#125; BMFILEHEADER;</span><br></pre></td></tr></table></figure>
<p>因为都是元素都是char类型的，所以不需要刻意的字节对齐。但是虽然简单了，数据访问是个问题。比如想访问offset这个应该为int类型的字段应该如何访问？在此感谢<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYW1leWluZw==" title="https://github.com/Blameying">XBlame<i class="fa fa-external-link"></i></span>的指导。写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">int</span> *)offset;</span><br></pre></td></tr></table></figure>
<p>首先将<code>char*</code>类型转换为<code>int*</code>，然后通过<code>*</code>来索引，得到的就是一个int值。</p>
<p>相对应的，你想获取size字段，就需要使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">int</span> *)size;</span><br></pre></td></tr></table></figure>
<h2 id="BMP文件的特殊宽度处理"><a href="#BMP文件的特殊宽度处理" class="headerlink" title="BMP文件的特殊宽度处理"></a>BMP文件的特殊宽度处理</h2><p><a href="bitmap-resolver.html">BMP文件处理（C语言实现）</a>这篇文章中说到BMP的宽度字节数规定必须为4的倍数，文章中的代码读取BMP宽度字节数为非4倍数并且不为3的倍数时（是3倍但不是4倍时，不会造成像素偏移），会造成像素偏移问题，效果如下：</p>
<blockquote>
<p>大图没有保留，只剩小的测试图了，不过效果就是有线条（RGB像素字节错位所致）</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/bitmap-resolver-rectify/n4xout.png" alt></p>
<p>根据测试，BMP的宽度字节数不是4的倍数时，也有特别情况，这种情况下我的程序也能处理。为什么呢？</p>
<p>BMP的宽度字节规定必须为4的倍数，在宽度字节数不为4的倍数时，就需要补齐。这说明补齐字节数有可能是0、1、2、3这几个数中的一个（0的时候宽度字节数是4的倍数）。如果需要补齐的字节数为3，这就是特殊情况，每行补齐三个字节数，顺序读取并没有导致RGB的字节错位。相反的，如果补齐字节数为1或者2，这样每一行都会多于1个或者2个字节，顺序读取就会造成RGB字节错位，而且是周期性的（补齐字节为1或2，则3行显示一行正确像素），所以显示图片能够看出原来的样子，但是有线条。如果字节全部错乱就完全不像原图了。</p>
<p>那么解决方法是什么？</p>
<blockquote>
<p>遇到补齐的字节跳过。</p>
</blockquote>
<p>那么问题来了，如何知道每行补齐的字节数和实际？</p>
<p>获取信息头里面的sizeImage字段（指的是图像实际用到的字节数，包含补齐），用它除以高度得到的是每行的字节数realWidth（包含补齐字节）。用realWidth整除每个像素所含字节数3，得到实际像素数；realWidth对3取余，得到补齐字节数。</p>
<p>在读取的时候每行只需要跳过最终的补齐字节，输出时输出补齐字节即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> offset = *(<span class="keyword">int</span> *)(header.offset);</span><br><span class="line"><span class="keyword">unsigned</span> realWidth = info.sizeImage / info.height;</span><br><span class="line"><span class="keyword">unsigned</span> rowPixelNumber = realWidth / <span class="keyword">sizeof</span>(RGBITEM);</span><br><span class="line"><span class="keyword">unsigned</span> remanentByteOfRow = realWidth % <span class="keyword">sizeof</span>(RGBITEM);</span><br><span class="line"><span class="keyword">unsigned</span> pixelCounts = rowPixelNumber * info.height;</span><br><span class="line">fseek(fp, offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RGBITEM *pitem = (RGBITEM *)<span class="built_in">malloc</span>(pixelCounts*<span class="keyword">sizeof</span>(RGBITEM));</span><br><span class="line"><span class="comment">//char *garbage = (char *)malloc(remanentByteOfRow);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; info.height; i++)</span><br><span class="line">&#123;</span><br><span class="line">    RGBITEM * currentAddr = pitem + i * rowPixelNumber;</span><br><span class="line">    fread(currentAddr, <span class="keyword">sizeof</span>(RGBITEM), rowPixelNumber, fp);</span><br><span class="line">    <span class="comment">//fread(garbage, remanentByteOfRow, 1, fp);</span></span><br><span class="line">    fseek(fp, remanentByteOfRow, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转为8位灰度图"><a href="#转为8位灰度图" class="headerlink" title="转为8位灰度图"></a>转为8位灰度图</h2><p>在上篇文章中展示的灰度图是用24位真彩色位图模拟的，就是将RGB三个字节都设为通过RGB求得的一个灰度值，这样无疑就每3个字节浪费2个字节，结果是输出的位图8位灰度图大小比24模拟灰度图会小$\frac{2}{3}$。</p>
<p>那么将24位真彩色（RGB）位图转换为8位灰度图需要修改那些属性呢？</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>图像数据$RGB24位真彩色\to8位灰度$</li>
<li>调色板数据添加，每个单位1个字节</li>
<li>文件头<ol>
<li>文件大小</li>
<li>偏移量</li>
</ol>
</li>
<li>信息头<ol start="2">
<li>颜色位数</li>
<li>图像实际所用字节数</li>
</ol>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BMP24To8Gray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * from, <span class="keyword">const</span> <span class="keyword">char</span> * to)</span> </span>&#123;</span><br><span class="line">	BMFILEHEADER fromHeader;</span><br><span class="line">	INFOHEADER fromInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RGBITEM ** fromData = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBITEM*));</span><br><span class="line">	RGBQUAD ** fromPalette = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBQUAD*));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fromPixelNumber = BMPReader(from, &amp;fromHeader, &amp;fromInfo, fromPalette, fromData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	BMFILEHEADER toHeader = fromHeader;</span><br><span class="line">	INFOHEADER toInfo = fromInfo;</span><br><span class="line">	<span class="comment">// set info</span></span><br><span class="line">	toInfo.colorCount = <span class="number">8</span>;</span><br><span class="line">	toInfo.infoHeaderSize = <span class="number">40</span>;</span><br><span class="line">	toInfo.planes = <span class="number">1</span>;</span><br><span class="line">	toInfo.sizeImage = (toInfo.width+<span class="number">3</span>)/<span class="number">4</span>*<span class="number">4</span>*toInfo.height;</span><br><span class="line">	toInfo.colorUsed = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RGBQUAD ** toPalette = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RGBQUAD*));</span><br><span class="line">	*toPalette = <span class="built_in">malloc</span>(<span class="number">256</span> * <span class="keyword">sizeof</span>(RGBQUAD));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		((*toPalette) + i)-&gt;r = ((*toPalette) + i)-&gt;b = ((*toPalette) + i)-&gt;g = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> **toData = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> *));</span><br><span class="line">	*toData = <span class="built_in">malloc</span>(fromPixelNumber);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; fromPixelNumber; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*(*toData+i)= ((*fromData + i)-&gt;r * <span class="number">299</span> + (*fromData + i)-&gt;g * <span class="number">587</span> + (*fromData + i)-&gt;b * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*(<span class="keyword">unsigned</span> *)toHeader.offset = <span class="keyword">sizeof</span>(toHeader) + <span class="keyword">sizeof</span>(toInfo) + <span class="number">256</span> * <span class="keyword">sizeof</span>(RGBQUAD);</span><br><span class="line">	*(<span class="keyword">unsigned</span> *)toHeader.size = toHeader.offset + toInfo.sizeImage;</span><br><span class="line"></span><br><span class="line">	BMPWriter8(to, &amp;toHeader, &amp;toInfo, toPalette, toData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="note primary">
            <p><strong>全部代码请查看[GitHub](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">https://github.com/ScarboroughCoral/DIPModule<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BMP.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BMPResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE * fp = fopen(<span class="string">"width.bmp"</span>, <span class="string">"rb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BMFILEHEADER header;</span><br><span class="line">	INFOHEADER info;</span><br><span class="line">	</span><br><span class="line">	fread(&amp;header, <span class="number">14</span>, <span class="number">1</span>, fp);</span><br><span class="line">	fread(&amp;info, <span class="keyword">sizeof</span>(INFOHEADER), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//RGBQUAD * prgbquad = (RGBQUAD *)malloc(info.colorUsed * sizeof(RGBQUAD));</span></span><br><span class="line">	<span class="comment">//fread(prgbquad, sizeof(RGBQUAD), info.colorUsed, fp);</span></span><br><span class="line">	<span class="keyword">unsigned</span> offset = *(<span class="keyword">int</span> *)(header.offset);</span><br><span class="line">	<span class="keyword">unsigned</span> realWidth = info.sizeImage / info.height;</span><br><span class="line">	<span class="keyword">unsigned</span> rowPixelNumber = realWidth / <span class="keyword">sizeof</span>(RGBITEM);</span><br><span class="line">	<span class="keyword">unsigned</span> remanentByteOfRow = realWidth % <span class="keyword">sizeof</span>(RGBITEM);</span><br><span class="line">	<span class="keyword">unsigned</span> pixelCounts = rowPixelNumber * info.height;</span><br><span class="line">	fseek(fp, offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RGBITEM *pitem = (RGBITEM *)<span class="built_in">malloc</span>(pixelCounts*<span class="keyword">sizeof</span>(RGBITEM));</span><br><span class="line">	<span class="keyword">char</span> *garbage = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(remanentByteOfRow);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; info.height; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		RGBITEM * currentAddr = pitem + i * rowPixelNumber;</span><br><span class="line">		fread(currentAddr, <span class="keyword">sizeof</span>(RGBITEM), rowPixelNumber, fp);</span><br><span class="line">		fread(garbage, remanentByteOfRow, <span class="number">1</span>, fp);</span><br><span class="line">		<span class="comment">//fseek(fp, remanentByteOfRow, SEEK_CUR);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改单色</span></span><br><span class="line">	<span class="comment">//for (size_t i = 0; i &lt; pixelCounts; i++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	//printf("%p-%p\n", pitem,pitem+1);</span></span><br><span class="line">	<span class="comment">//	//(pitem+i)-&gt;r = 0;</span></span><br><span class="line">	<span class="comment">//	(pitem + i)-&gt;g = 0;</span></span><br><span class="line">	<span class="comment">//	(pitem + i)-&gt;b = 0;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//灰度化</span></span><br><span class="line">	<span class="keyword">int</span> gray;</span><br><span class="line">	<span class="comment">/*for (size_t i = 0; i &lt; pixelCounts; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		gray = ((pitem + i)-&gt;r * 299 + (pitem + i)-&gt;g * 587 + (pitem + i)-&gt;b * 114 + 500) / 1000;</span></span><br><span class="line"><span class="comment">		(pitem + i)-&gt;r = gray;</span></span><br><span class="line"><span class="comment">		(pitem + i)-&gt;g = gray;</span></span><br><span class="line"><span class="comment">		(pitem + i)-&gt;b = gray;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//灰度图反色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pixelCounts; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		gray = ((pitem + i)-&gt;r * <span class="number">299</span> + (pitem + i)-&gt;g * <span class="number">587</span> + (pitem + i)-&gt;b * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span>;</span><br><span class="line">		(pitem + i)-&gt;r = <span class="number">255</span> - gray;</span><br><span class="line">		(pitem + i)-&gt;g = <span class="number">255</span> - gray;</span><br><span class="line">		(pitem + i)-&gt;b = <span class="number">255</span> - gray;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> * result = <span class="string">"result.bmp"</span>;</span><br><span class="line">	FILE * rp = fopen(result, <span class="string">"wb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (rp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fwrite(&amp;header, <span class="number">14</span>, <span class="number">1</span>, rp);</span><br><span class="line">	fwrite(&amp;info, <span class="keyword">sizeof</span>(INFOHEADER), <span class="number">1</span>, rp);</span><br><span class="line">	fseek(rp, offset, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//fwrite(prgbquad, sizeof(RGBQUAD), info.colorUsed, rp);</span></span><br><span class="line">	<span class="comment">//fwrite(pitem, sizeof(RGBITEM), info.sizeImage / 3, rp)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; info.height; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fwrite(pitem+i*rowPixelNumber, <span class="keyword">sizeof</span>(RGBITEM), rowPixelNumber, rp);</span><br><span class="line">		fwrite(garbage, remanentByteOfRow, <span class="number">1</span>, rp);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Output singleColor.bmp  successfully!\n"</span>);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	fclose(rp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>BMP文件处理（C语言实现）</title>
    <url>/bitmap-resolver.html</url>
    <content><![CDATA[<div class="note default">
            <p>模拟信号到数字信号是一个神奇的过程。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列文章（DIP，Digital Image Processing），用于记录总结数字图像处理课程的实验内容。目录请参考<a href="/tags/DIP/">DIP系列文章</a></p>
<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ol>
<li>24位图像对R,G,B三个分量进行分离，产生3幅新的图像</li>
<li>24位彩色图像灰度化</li>
<li>对8位灰度图进行反色</li>
</ol>
<h2 id="原图（测试图像）"><a href="#原图（测试图像）" class="headerlink" title="原图（测试图像）"></a>原图（测试图像）</h2><p>找了一个便于观察的图像：</p>
<p><img src="/images/loading.gif" data-original="/bitmap-resolver/origin.png" alt></p>
<h2 id="思路与步骤"><a href="#思路与步骤" class="headerlink" title="思路与步骤"></a>思路与步骤</h2><p>整体思路如下：</p>
<ol>
<li>读取图像文件属性与图形数据内容</li>
<li>图像文件属性与图形数据处理<ol>
<li>对R,G,B三个分量进行分离，需要将无关分量置0</li>
<li>灰度化需要利用RGB转灰度公式进行转换</li>
<li>对灰度图进行255求补运算</li>
</ol>
</li>
<li>将处理后的数据输出到目标图像文件</li>
</ol>
<h2 id="BMP图像文件格式"><a href="#BMP图像文件格式" class="headerlink" title="BMP图像文件格式"></a>BMP图像文件格式</h2><p>BMP图像文件由四部分构成：</p>
<ol>
<li>位图文件头</li>
<li>位图信息头</li>
<li>调色板</li>
<li>实际位图数据</li>
</ol>
<p>以下是各部分的详细属性：</p>
<h3 id="位图文件头"><a href="#位图文件头" class="headerlink" title="位图文件头"></a>位图文件头</h3><table>
<thead>
<tr>
<th style="text-align:center">属性含义（按读取顺序描述）</th>
<th style="text-align:center">所占空间大小（单位字节，byte）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件类型，必须是“BM”</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">文件大小，包含文件头的大小</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">保留字</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">保留字</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">从文件头到实际位图数据的偏移字节数</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<h3 id="位图信息头"><a href="#位图信息头" class="headerlink" title="位图信息头"></a>位图信息头</h3><table>
<thead>
<tr>
<th style="text-align:center">属性含义（按读取顺序描述）</th>
<th style="text-align:center">所占空间大小（单位字节，byte）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">该结构的长度，为40</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">图像宽度</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">图像高度</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">位平面数，必须为1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">颜色位数：1为二值，4为16色，8为256色，24为真彩色</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">是否压缩：指定位图是否压缩，有效的值为BI_RGB，BI_RLE8，BI_RLE4，BI_BITFIELDS(都是一些Windows定义好的常量)。要说明的是，Windows位图可以采用RLE4，和RLE8的压缩格式，但用的不多。我们今后所讨论的只有第一种不压缩的情况，即biCompression为BI_RGB的情况。</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">实际位图数据占用的字节数：【实际位图数据占用的字节数】=【图像宽度】’ × 【图像高度】。上述公式中的【图像宽度】’必须是4的整倍数(所以不是【图像宽度】，而是【图像宽度】’，表示大于或等于【图像宽度】的，最接近4的整倍数。举个例子，如果【图像宽度】=240，则【图像宽度】’=240；如果【图像宽度】=241，【图像宽度】’=244)。</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">目标设备水平分辨率</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">目标设备垂直分辨率</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">实际使用的颜色数：如果该值为零，则用到的颜色数为2的【颜色位数】次方种。</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">图像中重要的颜色数</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<h3 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h3><p>可选项，只在需要调色板的情况下出现。</p>
<p>调色板实际上是一个数组， 共有【实际使用的颜色数】个元素。数组中每个元素的类型是一个如下的结构，每个占4个字节，其定义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性含义（按读取顺序描述）</th>
<th style="text-align:center">所占空间大小（单位字节，byte）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">该颜色的蓝色分量</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">该颜色的绿色分量</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">该颜色的红色分量</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">保留值</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h3 id="实际位图数据"><a href="#实际位图数据" class="headerlink" title="实际位图数据"></a>实际位图数据</h3><p>共有位图信息头中所示属性中的【实际位图数据占用的字节数】个字节，每3个字节构成一组RGB真彩色像素，所以共有$【实际位图数据占用的字节数/3】$个字节。</p>
<h2 id="详细实现思路"><a href="#详细实现思路" class="headerlink" title="详细实现思路"></a>详细实现思路</h2><h3 id="RGB分离"><a href="#RGB分离" class="headerlink" title="RGB分离"></a>RGB分离</h3><ul>
<li>实现</li>
</ul>
<p>只需要将每个RGB像素中的不同分量置0即可，如下代码就是得到分离R分量的方法，最终输出图片只有红色分量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; itemCounts; i++)<span class="comment">//itemCounts：像素总数</span></span><br><span class="line">&#123;</span><br><span class="line">	(pitem + i)-&gt;g = <span class="number">0</span>;<span class="comment">//pitem：某个像素</span></span><br><span class="line">	(pitem + i)-&gt;b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bitmap-resolver/rdivision.png" alt></p>
<h3 id="RGB转灰色图"><a href="#RGB转灰色图" class="headerlink" title="RGB转灰色图"></a>RGB转灰色图</h3><ul>
<li>实现</li>
</ul>
<p>采用如下公式转换：<br>$$<br>Gray = R\times0.299 + G\times0.587 + B\times0.114<br>$$<br>如下代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; itemCounts; i++)</span><br><span class="line">&#123;</span><br><span class="line">	gray = ((pitem + i)-&gt;r * <span class="number">299</span> + (pitem + i)-&gt;g * <span class="number">587</span> + (pitem + i)-&gt;b * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span>;</span><br><span class="line">	(pitem + i)-&gt;r = gray;</span><br><span class="line">	(pitem + i)-&gt;g = gray;</span><br><span class="line">	(pitem + i)-&gt;b = gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bitmap-resolver/grey.png" alt></p>
<h3 id="灰度图反色"><a href="#灰度图反色" class="headerlink" title="灰度图反色"></a>灰度图反色</h3><ul>
<li>实现</li>
</ul>
<p>将灰度对255求补即可，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; itemCounts; i++)</span><br><span class="line">&#123;</span><br><span class="line">	gray = ((pitem + i)-&gt;r * <span class="number">299</span> + (pitem + i)-&gt;g * <span class="number">587</span> + (pitem + i)-&gt;b * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span>;</span><br><span class="line">	(pitem + i)-&gt;r = <span class="number">255</span>-gray;</span><br><span class="line">	(pitem + i)-&gt;g = <span class="number">255</span>-gray;</span><br><span class="line">	(pitem + i)-&gt;b = <span class="number">255</span>-gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<p><img src="/images/loading.gif" data-original="/bitmap-resolver/degrey.png" alt></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="note primary">
            <p><strong>全部代码请查看[GitHub](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvRElQTW9kdWxl" title="https://github.com/ScarboroughCoral/DIPModule">https://github.com/ScarboroughCoral/DIPModule<i class="fa fa-external-link"></i></span></strong></p>
          </div>
<div class="note warning">
            <h3 id="纠正"><a href="#纠正" class="headerlink" title="纠正"></a>纠正</h3><p>本程序是不完全版本，或者说是错误版本。有以下两点不足：</p><ul><li>未对图像宽度非4倍数进行特殊处理。</li><li>本文只对灰度图只做了24位模拟，没有转化为8位灰度图。</li><li>文件头的字节对齐问题，相关文章<a href="byte-alignment.html">计算机的字节对齐</a></li></ul><p>修正版本请查看<a href="bitmap-resolver-rectify.html">BMP文件的特殊宽度处理及字节对齐问题</a></p>
          </div>
<p>所有代码如下：</p>
<div class="note info">
            <h3 id="Main-c"><a href="#Main-c" class="headerlink" title="Main.c"></a>Main.c</h3>
          </div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BMP.h"</span></span></span><br><span class="line"><span class="comment">//#include &lt;Windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	FILE * fp = fopen(<span class="string">"test.bmp"</span>,<span class="string">"rb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BMFILEHEADER header;</span><br><span class="line">	INFOHEADER info;</span><br><span class="line">	fread(&amp;header, <span class="keyword">sizeof</span>(header),<span class="number">1</span>,fp);</span><br><span class="line">	fread(&amp;info, <span class="keyword">sizeof</span>(info), <span class="number">1</span>, fp);</span><br><span class="line">	RGBQUAD * prgbquad = (RGBQUAD *)<span class="built_in">malloc</span>(info.colorUsed*<span class="keyword">sizeof</span>(RGBQUAD));</span><br><span class="line">	fread(prgbquad, <span class="keyword">sizeof</span>(RGBQUAD), info.colorUsed, fp);</span><br><span class="line">	<span class="comment">//fseek(fp, header.offset, 0);</span></span><br><span class="line">	RGBITEM *pitem = (RGBITEM *)<span class="built_in">malloc</span>(info.sizeImage);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> itemCounts = info.sizeImage / (<span class="keyword">unsigned</span>)<span class="number">3</span>;</span><br><span class="line">	fread(pitem, <span class="keyword">sizeof</span>(RGBITEM), itemCounts, fp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改单色</span></span><br><span class="line">	<span class="comment">//for (size_t i = 0; i &lt; itemCounts; i++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	//printf("%d\n", pitem-&gt;r);</span></span><br><span class="line">	<span class="comment">//	(pitem+i)-&gt;r = 0;</span></span><br><span class="line">	<span class="comment">//	//(pitem+i)-&gt;g = 0;</span></span><br><span class="line">	<span class="comment">//	(pitem + i)-&gt;b = 0;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//灰度化</span></span><br><span class="line">	<span class="keyword">int</span> gray;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; itemCounts; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		gray = ((pitem + i)-&gt;r * <span class="number">299</span> + (pitem + i)-&gt;g * <span class="number">587</span> + (pitem + i)-&gt;b * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span>;</span><br><span class="line">		(pitem + i)-&gt;r = gray;</span><br><span class="line">		(pitem + i)-&gt;g = gray;</span><br><span class="line">		(pitem + i)-&gt;b = gray;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//灰度图反色</span></span><br><span class="line">	<span class="comment">/*for (size_t i = 0; i &lt; itemCounts; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		gray = ((pitem + i)-&gt;r * 299 + (pitem + i)-&gt;g * 587 + (pitem + i)-&gt;b * 114 + 500) / 1000;</span></span><br><span class="line"><span class="comment">		(pitem + i)-&gt;r = 255-gray;</span></span><br><span class="line"><span class="comment">		(pitem + i)-&gt;g = 255-gray;</span></span><br><span class="line"><span class="comment">		(pitem + i)-&gt;b = 255-gray;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> * result = <span class="string">"singleColor.bmp"</span>;</span><br><span class="line">	FILE * rp = fopen(result, <span class="string">"wb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (rp==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fwrite(&amp;header, <span class="keyword">sizeof</span>(header), <span class="number">1</span>, rp);</span><br><span class="line">	fwrite(&amp;info, <span class="keyword">sizeof</span>(info), <span class="number">1</span>, rp);</span><br><span class="line">	<span class="comment">//fseek(rp, header.offset, 0);</span></span><br><span class="line">	fwrite(prgbquad, <span class="keyword">sizeof</span>(RGBQUAD), info.colorUsed, rp);</span><br><span class="line">	fwrite(pitem, <span class="keyword">sizeof</span>(RGBITEM), info.sizeImage / <span class="number">3</span>, rp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Output singleColor.bmp  successfully!\n"</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <h3 id="BMP-h"><a href="#BMP-h" class="headerlink" title="BMP.h"></a>BMP.h</h3>
          </div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BMP.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapFileHeader</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> type[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> resvered1[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> reserved2[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> offset;</span><br><span class="line">&#125; BMFILEHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rgb</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> r;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> g;</span><br><span class="line">&#125;RGBITEM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitMapInfoHeader</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> infoHeaderSize;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> width;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> height;</span><br><span class="line">	<span class="keyword">unsigned</span> short planes;</span><br><span class="line">	<span class="keyword">unsigned</span> short colorCount;</span><br><span class="line">	<span class="keyword">unsigned</span> isCompressed;</span><br><span class="line">	<span class="keyword">unsigned</span> sizeImage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> xPelsPerMeter;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> yPelsPerMeter;</span><br><span class="line">	<span class="keyword">unsigned</span> colorUsed;</span><br><span class="line">	<span class="keyword">unsigned</span> colorImportant;</span><br><span class="line">&#125;INFOHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RGBQUAD</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> g;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> r;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> reserved;</span><br><span class="line"></span><br><span class="line">&#125;RGBQUAD ;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码简单，关键在于知识点的掌握。请继续关注<a href="/tags/DIP/">DIP，数字图像处理系列文章</a>！</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Computer Graphics</tag>
        <tag>DIP</tag>
      </tags>
  </entry>
  <entry>
    <title>有关计算机浮点数的思考。</title>
    <url>/float-think.html</url>
    <content><![CDATA[<div class="note warning">
            <p>计算机的浮点数只能近似表示一些非常精确的数。</p>
          </div>
<a id="more"></a>
<hr>
<p>本篇文章是对<span class="label primary">阮一峰</span>的<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTAvMDYvaWVlZV9mbG9hdGluZy1wb2ludF9yZXByZXNlbnRhdGlvbi5odG1s" title="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》<i class="fa fa-external-link"></i></span>的思考过程。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来是想对CSAPP的的信息表示的浮点数表示做一下总结的，不过写了几百字后放弃了，主要是对浮点数还不够了解。不过看过阮一峰大神的文章之后，不禁大叹一声。这篇文章就想总结一下自己对浮点数的理解。</p>
<h2 id="由一个题目说起"><a href="#由一个题目说起" class="headerlink" title="由一个题目说起"></a>由一个题目说起</h2><p>有一道C语言的练习题，是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> num=<span class="number">9</span>; <span class="comment">/* num是整型变量，设为9 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">float</span>* pFloat=&amp;num; <span class="comment">/* pFloat表示num的内存地址，但是设为浮点数 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"num的值为：%d\n"</span>,num); <span class="comment">/* 显示num的整型值 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"*pFloat的值为：%f\n"</span>,*pFloat); <span class="comment">/* 显示num的浮点值 */</span></span><br><span class="line"></span><br><span class="line">　　*pFloat=<span class="number">9.0</span>; <span class="comment">/* 将num的值改为浮点数 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"num的值为：%d\n"</span>,num); <span class="comment">/* 显示num的整型值 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"*pFloat的值为：%f\n"</span>,*pFloat); <span class="comment">/* 显示num的浮点值 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">coral@xx:~/workspace/csapp$ ./<span class="built_in">float</span></span><br><span class="line">num的值为：9</span><br><span class="line">*pFloat的值为：0.000000</span><br><span class="line">num的值为：1091567616</span><br><span class="line">*pFloat的值为：9.000000</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行，直接输出num的值，这个毫无疑问是对的。</li>
<li>第二行，输出为什么为0？<blockquote>
<p>float和int类型的变量存储空间都是4个字节。令一个float类型的指针指向num的地址，然后通过<code>*float</code> 的方式访问，会将num地址内存储的内容以4字节浮点数解析。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第三行，输出为什么是一个类似乱码的数值？</p>
<blockquote>
<p>将原来num变量的内容通过float类型的指针采取<code>*float</code>的方式赋值为9.0，然而输出的时候按照int的方式输出，所以解析错误，出现乱码。</p>
</blockquote>
</li>
<li><p>第四行，这个就没有疑问了</p>
<blockquote>
<p>通过float类型指针，然后通过float类型指针访问，所以解析方式是相同的，所以答案正如所料。</p>
</blockquote>
</li>
</ul>
<p>总之，这个题就是需要考虑int类型和float类型的存储格式。如果按照不同的方式解析肯定会出现错误。</p>
<h2 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h2><p>内存只是一个字节数组而已，不管是float、int还是其他类型的变量，不过是内存中需要的大小或者是存储格式不同而已，无其他区别。</p>
<h2 id="int的存储格式"><a href="#int的存储格式" class="headerlink" title="int的存储格式"></a>int的存储格式</h2><p>int是4字节类型，也就是32位。int的存储格式就是32位补码。这个不必多言，很好理解。这篇文章重点写浮点数的存储格式。 </p>
<h2 id="float的存储格式"><a href="#float的存储格式" class="headerlink" title="float的存储格式"></a>float的存储格式</h2><p>float的存储格式正如下图，在这里我们只考虑简单的单精度浮点数和双精度浮点数：</p>
<p><img src="/images/loading.gif" data-original="/float-think/float.png" alt></p>
<h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p>因为浮点数的需求是要表示小数、特大数和非常接近零的数。当然由于浮点数精度总是有限的，所以有一些数值只能近似表示，而不能完全相等。</p>
<p>下面再来回想一下科学计数法，当然这我们很早之前就学过，比如下面这个数:</p>
<p>$$<br>    5.21\times10^{1314}<br>$$</p>
<p>如果我们不使用科学计数法的话就需要用1313位数字来表示，这样就太麻烦了。所以就采用了科学计数法来表示，用于节省“空间”。</p>
<h3 id="“二进制”科学计数法"><a href="#“二进制”科学计数法" class="headerlink" title="“二进制”科学计数法"></a>“二进制”科学计数法</h3><p>与此目的相同，计算机为了表示一些数，就采用了“二进制”版本的科学计数法，比如数值7.0，就可以用以下“二进制”科学计数法表示：</p>
<p>$$<br>    1.11\times2^2<br>$$</p>
<p>它是怎么来的呢？因为7.0的二进制表示为111，将小数点左移两位，相应的就需要乘上$2^2$来使其相等。</p>
<p>浮点数的存储格式的想法就来自于此，因为这样能够大大减少存储空间，另外一个好处就是能够在误差允许的范围内表示非常大的数（$\pm\infty$）或者非常接近于0的数($f\to0$)。</p>
<p>浮点数一般用如下方式表示：</p>
<p>$$<br>(-1)^S\times M\times2^E<br>$$</p>
<ul>
<li>S用于表示浮点数的符号</li>
<li>M用于表示有效数字，$1\leq M&lt;2$</li>
<li>E用于表示指数</li>
</ul>
<p>所以计算机只需要存储这三部分即可。</p>
<h3 id="单精度浮点数的存储格式"><a href="#单精度浮点数的存储格式" class="headerlink" title="单精度浮点数的存储格式"></a>单精度浮点数的存储格式</h3><p>与想象的方式还有点不同，除了一些优化外，还需要遵守（abicd）一些约定。</p>
<p>下面的表格便是32位浮点数大端法表示的存储格式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">sign（符号）</th>
<th style="text-align:center">exp（指数）</th>
<th style="text-align:center">frac（有效数字小数部分）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1位</td>
<td style="text-align:center">8位</td>
<td style="text-align:center">23位</td>
</tr>
</tbody>
</table>
<ul>
<li>32位浮点数的存储格式，大端法表示就是符号+指数+有效数字小数部分</li>
<li>因为有效数字必须满足 $1\le frac&lt;2$，所以二进制的小数点前的一位总是1，所以省略不写</li>
<li>因为指数不仅需要表示正数次幂，也需要能表示负数次幂，可能是字节对齐的缘故（for the sake of ），所以指数部分不能采用补码形式表示，而是采用IEEE 754规定采用找中间数的方法，中间数总是$\lfloor\frac{2^{EMax}-1}{2}\rfloor$，比如8位指数，中间数就是$\lfloor\frac{2^8-1}{2}\rfloor=127$。在表示的时候需要将真实值＋中间数。</li>
<li>E的规定<ul>
<li>E不全为0并且不全为1。浮点数的值就是E减去中间数127得到指数真实值，然后有效数字小数部分M前面加上1</li>
<li>E全为0。浮点数的指数为1-中间数（32位浮点数为1-127），有效数字前不再＋1，这样就为0.xxxx的小数，而且可以表示非常接近于0的数。</li>
<li>E全为1。如果有效数字全为0，则表示$\pm\infty$；否则就表示这不是一个数 <strong><em>NaN</em></strong>。</li>
</ul>
</li>
</ul>
<h3 id="双精度浮点数的存储格式"><a href="#双精度浮点数的存储格式" class="headerlink" title="双精度浮点数的存储格式"></a>双精度浮点数的存储格式</h3><p>解析方法与单精度浮点数相同，存储格式类似。<br>下面的表格便是64位浮点数大端法表示的存储格式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">sign（符号）</th>
<th style="text-align:center">exp（指数）</th>
<th style="text-align:center">frac（有效数字小数部分）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1位</td>
<td style="text-align:center">11位</td>
<td style="text-align:center">52位</td>
</tr>
</tbody>
</table>
<h2 id="例题题解"><a href="#例题题解" class="headerlink" title="例题题解"></a>例题题解</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> num=<span class="number">9</span>; <span class="comment">/* num是整型变量，设为9 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">float</span>* pFloat=&amp;num; <span class="comment">/* pFloat表示num的内存地址，但是设为浮点数 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"num的值为：%d\n"</span>,num); <span class="comment">/* 显示num的整型值 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"*pFloat的值为：%f\n"</span>,*pFloat); <span class="comment">/* 显示num的浮点值 */</span></span><br><span class="line"></span><br><span class="line">　　*pFloat=<span class="number">9.0</span>; <span class="comment">/* 将num的值改为浮点数 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"num的值为：%d\n"</span>,num); <span class="comment">/* 显示num的整型值 */</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"*pFloat的值为：%f\n"</span>,*pFloat); <span class="comment">/* 显示num的浮点值 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">coral@xx:~/workspace/csapp$ ./<span class="built_in">float</span></span><br><span class="line">num的值为：9</span><br><span class="line">*pFloat的值为：0.000000</span><br><span class="line">num的值为：1091567616</span><br><span class="line">*pFloat的值为：9.000000</span><br></pre></td></tr></table></figure>
<ol>
<li>第二行，为什么是0.00000？</li>
</ol>
<div class="note success">
            <p>执行<code>printf(&quot;*pFloat的值为：%f\n&quot;,*pFloat);</code>语句时，变量存储空间内是存储的int类型的9，二进制表示为0000-0000-0000-0000-0000-0000-0000-1001，但是输出使用float指针类型索引，所以按照此类型解析的话，二进制解析为0-00000000-00000000000000000001001，所以指数E为全0。浮点数真值为：</p><p>$$<br>V=(-1)^0×0.00000000000000000001001×2^{-126}=1.001×2^{-146}<br>$$<br>数值几乎为0，所以答案就明了了。</p>
          </div>
<ol start="2">
<li>第三行，为什么是1091567616？</li>
</ol>
<div class="note success">
            <p>这个同理了，只不过是反向思考。</p><p>首先用float指针将数值设置为9.0。9的二进制表示为1001，用”二进制“科学计数法表示为$1.001\times2^3$，所以S为0，E为3+127=130（二进制为10000010），有效数为001，所以变量存储的内容为0-10000010-00100000000000000000000，然后将这个值用int类型解析，0100-0001-0001-0000-0000-0000-0000-0000，结果为1091567616。</p>
          </div>]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 之 Data Lab</title>
    <url>/csapp-lab-1.html</url>
    <content><![CDATA[<div class="note default">
            <p>纸上得来终觉浅，绝知此事要躬行。</p>
          </div>
<a id="more"></a>
<hr>
<h2 id="CSAPP-实验记录"><a href="#CSAPP-实验记录" class="headerlink" title="CSAPP 实验记录"></a>CSAPP 实验记录</h2><div class="note info">
            <p><strong><a href="/tags/CSAPP-Lab/">本系列文章</a>主要记录 CSAPP 3.0 的实验过程，所有实验记录文章请查看<a href="/tags/CSAPP-Lab/">这儿</a></strong></p>
          </div>
<p>快速开始请访问 <code>CSAPP</code> <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvM2UvbGFicy5odG1s" title="http://csapp.cs.cmu.edu/3e/labs.html">Lab<i class="fa fa-external-link"></i></span> 官网，本次实验记录是基于 CSAPP 3.0，实验日期始于：<code>2019-1-5</code></p>
<p><strong><em>实验打算采用以下框架来记录</em></strong></p>
<ul>
<li>题目列表</li>
<li>实验题目题解<ul>
<li>题解代码</li>
<li>题目思考</li>
</ul>
</li>
<li>结果</li>
<li>关于本次实验的思考</li>
</ul>
<blockquote>
<p>当真正开始做实验的时候，才发现自己有多菜。</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/csapp-lab-1/1546740914782.png" alt="1546740946420"></p>
<h2 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h2><p>开始做 <code>CSAPP</code> 的实验了，这次是第一次实验，内容是关于计算机信息的表示，主要是位操作、整数题和浮点数相关的题。</p>
<h3 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h3><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">指令数目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bitXor(x,y)</td>
<td style="text-align:center">只使用<code>~</code>和<code>&amp;</code>实现<code>^</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">tmin()</td>
<td style="text-align:center">返回最小补码</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">isTmax(x)</td>
<td style="text-align:center">判断是否是补码最大值</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">allOddBits(x)</td>
<td style="text-align:center">判断补码所有奇数位是否都是1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">negate(x)</td>
<td style="text-align:center">不使用负号 <code>-</code> 实现 <code>-x</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">isAsciiDigit(x)</td>
<td style="text-align:center">判断 <code>x</code> 是否是 <code>ASCII</code> 码</td>
<td style="text-align:center">3</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">conditional(x, y, z)</td>
<td style="text-align:center">类似于 C 语言中的 <code>x?y:z</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">isLessOrEqual(x,y)</td>
<td style="text-align:center"><code>x&lt;=y</code></td>
<td style="text-align:center">3</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">logicalNeg(x)</td>
<td style="text-align:center">计算 <code>!x</code> 而不用 <code>!</code> 运算符</td>
<td style="text-align:center">4</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">howManyBits(x)</td>
<td style="text-align:center">计算表达 <code>x</code> 所需的最少位数</td>
<td style="text-align:center">4</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">floatScale2(uf)</td>
<td style="text-align:center">计算 <code>2.0*uf</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">floatFloat2Int(uf)</td>
<td style="text-align:center">计算 <code>(int) f</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">floatPower2(x)</td>
<td style="text-align:center">计算 $2.0^x$</td>
<td style="text-align:center">4</td>
<td style="text-align:center">30</td>
</tr>
</tbody>
</table>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="bitXor-x-y"><a href="#bitXor-x-y" class="headerlink" title="bitXor(x,y)"></a>bitXor(x,y)</h4><blockquote>
<p>只使用两种位运算实现异或操作。这个算是一个比较简单的问题了，难度系数1。学数电和离散二布尔代数的时候了解过。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>根据布尔代数，可以通过 <code>~</code> 和 <code>&amp;</code> ，即非和与操作实现异或操作。所谓异或就是当参与运算的两个二进制数不同时结果才为1，其他情况为0。<code>C</code> 语言中的位操作对基本类型变量进行运算就是对类型中的每一位进行位操作。所以结果可以使用“非”和“与”计算<strong>不是同时为0情况和不是同时为1的情况进行位与</strong>，即<code>~(~x&amp;~y)&amp;~(x&amp;y)</code> 。</p>
</li>
</ul>
<h4 id="tmin"><a href="#tmin" class="headerlink" title="tmin()"></a>tmin()</h4><blockquote>
<p>使用位运算获取对2补码的最小 <code>int</code> 值。这个题目也是比较简单。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>C 语言中 <code>int</code> 类型是32位，即4字节数。<strong>补码最小值就是符号位为1，其余全为0。</strong>所以只需要得到这个值就行了，我采用的是对数值 <code>0x1</code> 进行移位运算，得到结果。</p>
</li>
</ul>
<h4 id="isTmax-x"><a href="#isTmax-x" class="headerlink" title="isTmax(x)"></a>isTmax(x)</h4><blockquote>
<p>通过位运算计算是否是补码最大值。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = x+<span class="number">1</span>;<span class="comment">//Tmin,1000...</span></span><br><span class="line">  x=x+i;<span class="comment">//-1,1111...</span></span><br><span class="line">  x=~x;<span class="comment">//0,0000...</span></span><br><span class="line">  i=!i;<span class="comment">//exclude x=0xffff...</span></span><br><span class="line">  x=x+i;<span class="comment">//exclude x=0xffff...</span></span><br><span class="line">  <span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>做这个题目的前提就是必须知道补码最大值是多少，这当然是针对 <code>int</code> 类型来说的，最大值当然是符号位为0，其余全是1，这是补码规则，不明其意则 Google。在此说一下个人理解，最终返回值为 0 或 1，要想判断给定数 <code>x</code> 是不是补码最大值（<code>0x0111,1111,1111,1111</code>），则需要将给定值 <code>x</code> 向全 0 值转换判断，因为非0布尔值就是1，不管你是1还是2。根据我标注的代码注释理解，如果 <code>x</code> 是最大值，将其转换为全0有很多方法，不过最终要排除转换过程中其他的数值，比如本例子中需要排除<code>0xffffffffffffffff</code> 的情况：将 x 加1的值再和 x 相加，得到了全1（函数第二行），然后取反得到全0，<strong>因为补码-1也有这个特点</strong>，所以要排除，假设 x 是 -1，则 +1 后为全 0，否则不为全 0，函数4-5行则是排除这种情况。</p>
</li>
</ul>
<h4 id="allOddBits-x"><a href="#allOddBits-x" class="headerlink" title="allOddBits(x)"></a>allOddBits(x)</h4><blockquote>
<p>判断所有奇数位是否都为1，这里的奇数指的是位的阶级是2的几次幂。重在思考转换规律，如何转换为对应的布尔值。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mask = <span class="number">0xAA</span>+(<span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  mask=mask+(mask&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !((mask&amp;x)^mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>这个题目还是比较简单的，采用掩码方式解决。首先要构造掩码，使用移位运算符构造出奇数位全1的数 <code>mask</code> ，然后获取输入 <code>x</code> 值的奇数位，其他位清零（<code>mask&amp;x</code>），然后与 <code>mask</code> 进行异或操作，若相同则最终结果为0，然后返回其值的逻辑非。</p>
</li>
</ul>
<h4 id="negate-x"><a href="#negate-x" class="headerlink" title="negate(x)"></a>negate(x)</h4><blockquote>
<p>不使用 <code>-</code> 操作符，求 <code>-x</code> 值。这个题目是常识。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>补码实际上是一个<code>阿贝尔群</code>，对于 <code>x</code>，<code>-x</code> 是其补码，所以 <code>-x</code> 可以通过对 <code>x</code> 取反加1得到。</p>
</li>
</ul>
<h4 id="isAsciiDigit-x"><a href="#isAsciiDigit-x" class="headerlink" title="isAsciiDigit(x)"></a>isAsciiDigit(x)</h4><blockquote>
<p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值。这个题刚开始还是比较懵的，不过这个题让我认识到了位级操作的强大。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> upperBound = ~(sign|<span class="number">0x39</span>);</span><br><span class="line">  <span class="keyword">int</span> lowerBound = ~<span class="number">0x30</span>;</span><br><span class="line">  upperBound = sign&amp;(upperBound+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  lowerBound = sign&amp;(lowerBound+<span class="number">1</span>+x)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(upperBound|lowerBound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>通过位级运算计算 <code>x</code> 是否在 0x30 - 0x39 范围内就是这个题的解决方案。那如何用位级运算来操作呢？我们可以使用两个数，一个数是加上比0x39大的数后符号由正变负，另一个数是加上比0x30小的值时是负数。这两个数是代码中初始化的 <code>upperBound</code> 和 <code>lowerBound</code>，然后加法之后获取其符号位判断即可。</p>
</li>
</ul>
<h4 id="conditional-x-y-z"><a href="#conditional-x-y-z" class="headerlink" title="conditional(x, y, z)"></a>conditional(x, y, z)</h4><blockquote>
<p>使用位级运算实现C语言中的 <code>x?y:z</code>三目运算符。又是位级运算的一个使用技巧。</p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(3,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !!x;</span><br><span class="line">  x = ~x+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x&amp;y)|(~x&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>如果我们根据 <code>x</code> 的布尔值转换为全0或全1是不是更容易解决了，即 <code>x==0</code> 时位表示是全0的， <code>x!=0</code> 时位表示是全1的。这就是1-2行代码，通过获取其布尔值0或1，然后求其补码（0的补码是本身，位表示全0；1的补码是-1，位表示全1）得到想要的结果。然后通过位运算获取最终值。</p>
</li>
</ul>
<h4 id="isLessOrEqual-x-y"><a href="#isLessOrEqual-x-y" class="headerlink" title="isLessOrEqual(x,y)"></a>isLessOrEqual(x,y)</h4><blockquote>
<p>使用位级运算符实现<code>&lt;=</code></p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negX=~x+<span class="number">1</span>;<span class="comment">//-x</span></span><br><span class="line">  <span class="keyword">int</span> addX=negX+y;<span class="comment">//y-x</span></span><br><span class="line">  <span class="keyword">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>; <span class="comment">//y-x的符号</span></span><br><span class="line">  <span class="keyword">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;<span class="comment">//最大位为1的32位有符号数</span></span><br><span class="line">  <span class="keyword">int</span> xLeft = x&amp;leftBit;<span class="comment">//x的符号</span></span><br><span class="line">  <span class="keyword">int</span> yLeft = y&amp;leftBit;<span class="comment">//y的符号</span></span><br><span class="line">  <span class="keyword">int</span> bitXor = xLeft ^ yLeft;<span class="comment">//x和y符号相同标志位，相同为0不同为1</span></span><br><span class="line">  bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//符号相同标志位格式化为0或1</span></span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));<span class="comment">//返回1有两种情况：符号相同标志位为0（相同）位与 y-x 的符号为0（y-x&gt;=0）结果为1；符号相同标志位为1（不同）位与x的符号位为1（x&lt;0）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
</li>
</ul>
<p>通过位运算实现比较两个数的大小，无非两种情况：一是符号不同正数为大，二是符号相同看差值符号。</p>
<h4 id="logicalNeg-x"><a href="#logicalNeg-x" class="headerlink" title="logicalNeg(x)"></a>logicalNeg(x)</h4><blockquote>
<p>使用位级运算求逻辑非 <strong><code>!</code></strong></p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>逻辑非就是非0为1，非非0为0。利用其补码（取反加一）的性质，除了0和最小数（符号位为1，其余为0），外其他数都是互为相反数关系（符号位取位或为1）。0和最小数的补码是本身，不过0的符号位与其补码符号位位或为0，最小数的为1。利用这一点得到解决方法。</p>
<h4 id="howManyBits-x"><a href="#howManyBits-x" class="headerlink" title="howManyBits(x)"></a>howManyBits(x)</h4><blockquote>
<p>求值：“一个数用补码表示最少需要几位？”</p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="keyword">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);<span class="comment">//如果x为正则不变，否则按位取反（这样好找最高位为1的，原来是最高位为0的，这样也将符号位去掉了）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断缩小范围</span></span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;<span class="comment">//高十六位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b16;<span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;<span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b8;<span class="comment">//如果有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;<span class="comment">//同理</span></span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;<span class="comment">//+1表示加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>如果是一个正数，则需要找到它最高的一位（假设是n）是1的，再加上符号位，结果为n+1；如果是一个负数，则需要知道其最高的一位是0的（例如4位的1101和三位的101补码表示的是一个值：-3，最少需要3位来表示）。</p>
<h4 id="floatScale2-f"><a href="#floatScale2-f" class="headerlink" title="floatScale2(f)"></a>floatScale2(f)</h4><blockquote>
<p>求2乘一个浮点数</p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="keyword">int</span> sign = uf&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0</span>) <span class="keyword">return</span> uf&lt;&lt;<span class="number">1</span>|sign;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>) <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="built_in">exp</span>++;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>|sign;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|(uf&amp;<span class="number">0x807fffff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>首先排除无穷小、0、无穷大和非数值NaN，此时浮点数指数部分（<code>真正指数+bias</code>）分别存储的的为0，0，,255，255。这些情况，无穷大和NaN都只需要返回参数（$2\times\infty=\infty,2\times NaN=NaN$），无穷小和0只需要将原数乘二再加上符号位就行了（并不会越界）。剩下的情况，如果指数+1之后为指数为255则返回原符号无穷大，否则返回指数+1之后的原符号数。</p>
<h4 id="floatFloat2Int-f"><a href="#floatFloat2Int-f" class="headerlink" title="floatFloat2Int(f)"></a>floatFloat2Int(f)</h4><blockquote>
<p>将浮点数转换为整数</p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s_    = uf&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> exp_  = ((uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;</span><br><span class="line">  <span class="keyword">int</span> frac_ = (uf&amp;<span class="number">0x007fffff</span>)|<span class="number">0x00800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(!(uf&amp;<span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(exp_ &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">if</span>(exp_ &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(exp_ &gt; <span class="number">23</span>) frac_ &lt;&lt;= (exp_<span class="number">-23</span>);</span><br><span class="line">  <span class="keyword">else</span> frac_ &gt;&gt;= (<span class="number">23</span>-exp_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!((frac_&gt;&gt;<span class="number">31</span>)^s_)) <span class="keyword">return</span> frac_;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(frac_&gt;&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac_+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>首先考虑特殊情况：如果原浮点值为0则返回0；如果真实指数大于31（frac部分是大于等于1的，1&lt;&lt;31位会覆盖符号位），返回规定的溢出值<strong>0x80000000u</strong>；如果$exp&lt;0$（1右移x位,x&gt;0，结果为0）则返回0。剩下的情况：首先把小数部分（23位）转化为整数（和23比较），然后判断是否溢出：如果和原符号相同则直接返回，否则如果结果为负（原来为正）则溢出返回越界指定值<strong>0x80000000u</strong>，否则原来为负，结果为正，则需要返回其补码（相反数）。</p>
<div class="note info">
            <p><strong>C语言的浮点数强转为整数怎么转的？</strong></p><p>利用位级表示进行强转！</p>
          </div>
<h4 id="floatPower2-x"><a href="#floatPower2-x" class="headerlink" title="floatPower2(x)"></a>floatPower2(x)</h4><blockquote>
<p>求$2.0^x$</p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 31 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> INF = <span class="number">0xff</span>&lt;&lt;<span class="number">23</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">255</span>) <span class="keyword">return</span> INF;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>2.0的位级表示（$1.0\times2^1$）：符号位：0，指数：1+127=128，frac=1.0-1=0。$2.0^x=(1.0\times2^1)^x=1.0\times2^x$，所以x就当做真正的指数的。</p>
<p>这个比较简单，首先得到偏移之后的指数值e，如果e小于等于0（为0时，结果为0，因为2.0的浮点表示frac部分为0），对应的如果e大于等于255则为无穷大或越界了。否则返回正常浮点值，frac为0，直接对应指数即可。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>很遗憾，最终的一个题目<code>floatPower2</code>始终无法通过，不过不是逻辑上的错误，在VS2017上完全可以运行，没有进入死循环。（个人感觉可能是官方的评测出了问题:-(，:cry: ）</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/csapp-lab-1/result.png" alt></p>
<h2 id="关于本次实验的思考"><a href="#关于本次实验的思考" class="headerlink" title="关于本次实验的思考"></a>关于本次实验的思考</h2><h3 id="所感"><a href="#所感" class="headerlink" title="所感"></a>所感</h3><p>这是CSAPP实验的第一次实验，接下来还有10个Lab等着我，希望我能够坚持下来吧。做本次实验的有以下几点感受：</p>
<ul>
<li>大多题目都没有思路，或者是自己懒得想，有一些题目是照搬别人的代码</li>
<li>效率太低，这个实验在2019寒假前就开始做了，直到2019三月中旬才完成，有的题目甚至需要思考1个小时甚至更多。</li>
<li>自己变笨了，想到奶奶小时候一直说的话：<em>拳不离手，曲不离口，三天不动手生，三天不念口生，脑越用越灵，手越用越巧，脑子不学要生锈，人不学习要落后</em>，果然如此，大学后长期懒散（slack）惯了。</li>
</ul>
<h3 id="所得"><a href="#所得" class="headerlink" title="所得"></a>所得</h3><ul>
<li>基本的位操作指令</li>
<li>掌握了IEEE 754标准的浮点数格式和使用方法</li>
</ul>
<h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>虽然实验过程很坎坷，但是所有代码都搞懂了，以后有机会再二刷吧。本次实验的基础收获当然是关于信息的位级表示相关的内容了，对一些位级运算符更加熟悉了一些。不过更大的收获是实验所感给我敲响的警钟，如下：</p>
<ol>
<li>实验必须自己做，不会首先参考知识点的搜索，其次在找方法源码</li>
<li>实验必须要总结，总结自己实验的思路</li>
<li>总结实验的学习方法和如何提高效率问题</li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>Operating System</tag>
        <tag>CSAPP Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow 学习笔记</title>
    <url>/tflearn-1.html</url>
    <content><![CDATA[<div class="note default">
            <p>智能就是有学习能力。</p>
          </div>
<a id="more"></a>
<h2 id="神经网络具体实现"><a href="#神经网络具体实现" class="headerlink" title="神经网络具体实现"></a>神经网络具体实现</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>准备数据集，提取特征，作为输入喂给神经网络</li>
<li>搭建 NN 结构，从输入到输出（先搭建计算图，再用会话执行）<blockquote>
<p>NN 前向传播算法–&gt;计算输出</p>
</blockquote>
</li>
<li>大量特征数据喂给 NN，迭代优化 NN 参数<blockquote>
<p>NN 反向传播算法–&gt;优化参数训练模型</p>
</blockquote>
</li>
<li>使用训练好的模型预测和分类</li>
</ul>
<p>下面是一个具体的例子，这个例子中并没有反向传播优化参数。<br>这个例子是通过输入物品的两个指标：<code>质量</code>和<code>体积</code>，来判定物品是否合格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.constant([[<span class="number">0.7</span>,<span class="number">0.5</span>]])</span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"y is "</span>,sess.run(y)</span><br></pre></td></tr></table></figure>
<h3 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h3><p>数据源是来自于实际过程的，假设我们此处直接喂食一组或者多组数据：</p>
<p>使用 <code>placeholder</code> 方法进行预设值，在会话中输入实际值。</p>
<ul>
<li>喂食 1 组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.placeholder(tf.float32,shape=(<span class="number">1</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 喂食 1 组 2 维张量</span></span><br><span class="line">x = tf.placeholder(tf.float32,shape=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"y is "</span>,sess.run(y,feed_dict=&#123;x:[[<span class="number">0.7</span>,<span class="number">0.5</span>]]&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>喂食多组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 喂食多组 2 维张量</span></span><br><span class="line">x = tf.placeholder(tf.float32,shape=(<span class="literal">None</span>,<span class="number">2</span>))</span><br><span class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"y is \n"</span>,sess.run(y,feed_dict=&#123;x:[[<span class="number">0.7</span>,<span class="number">0.5</span>],[<span class="number">0.2</span>,<span class="number">0.3</span>],[<span class="number">0.3</span>,<span class="number">0.4</span>],[<span class="number">0.4</span>,<span class="number">0.5</span>]]&#125;)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"w1:\n"</span>,sess.run(w1)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"w2:\n"</span>,sess.run(w2)</span><br></pre></td></tr></table></figure>
<h3 id="定义前向传播过程"><a href="#定义前向传播过程" class="headerlink" title="定义前向传播过程"></a>定义前向传播过程</h3><p>在喂食数据的例子中，前向传播过程很简单，就是两条语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br></pre></td></tr></table></figure>
<h3 id="定义反向传播并训练"><a href="#定义反向传播并训练" class="headerlink" title="定义反向传播并训练"></a>定义反向传播并训练</h3><p>为了使反向传播更容易理解，我们再具体化一些。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 科学计算库</span></span><br><span class="line"></span><br><span class="line">BATCH_SIZE = <span class="number">8</span><span class="comment"># 每次喂食数量</span></span><br><span class="line">seed = <span class="number">23455</span><span class="comment"># 随机种子值，可以根据时间戳来设置</span></span><br><span class="line">rng = np.random.RandomState(seed)</span><br><span class="line">X = rng.rand(<span class="number">32</span>,<span class="number">2</span>)<span class="comment"># 随机生成数据集</span></span><br><span class="line">Y = [[int(x0+x1&lt;<span class="number">1</span>)] <span class="keyword">for</span> (x0,x1) <span class="keyword">in</span> X]<span class="comment"># 人为定义体积与质量和小于1才合格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"X:\n"</span>,X</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Y:\n"</span>,Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入、参数、输出、前向传播</span></span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32,shape=(<span class="literal">None</span>,<span class="number">2</span>))</span><br><span class="line">y_= tf.placeholder(tf.float32,shape=(<span class="literal">None</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">w1= tf.Variable(tf.random_normal([<span class="number">2</span>,<span class="number">3</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line">w2= tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">1</span>],stddev=<span class="number">1</span>,seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">a = tf.matmul(x,w1)</span><br><span class="line">y = tf.matmul(a,w2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数及反向传播</span></span><br><span class="line"></span><br><span class="line">loss = tf.reduce_mean(tf.square(y-y_))</span><br><span class="line"><span class="comment"># 梯度下降方法</span></span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.001</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    init_op = tf.global_variables_initializer()</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"w1:\n"</span>,sess.run(w1)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"w2:\n"</span>,sess.run(w2)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line">    </span><br><span class="line">    STEPS = <span class="number">3000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">        start = (i*BATCH_SIZE)%<span class="number">32</span></span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        sess.run(train_step,feed_dict=&#123;x:X[start:end],y_:Y[start:end]&#125;)</span><br><span class="line">        <span class="comment"># 每500次输出一次训练总误差</span></span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            total_loss = sess.run(loss,feed_dict=&#123;x:X,y_:Y&#125;)</span><br><span class="line">            print(<span class="string">"After %d training step(s),loss on all data is %g"</span>%(i,total_loss))</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"w1:\n"</span>,sess.run(w1)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"w2:\n"</span>,sess.run(w2)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据神经网络实现的步骤，或许能够理解代码如何编写了。再次总结一下，使用神经网络的目的是为了得到一个优秀的模型来进行预测或者分类。如何训练出一个优秀的模型那就是问题的关键了。首先，一个优秀模型的训练离不开数据和计算参数，数据通常来源于生活，而参数我们可以使用随机数初始化，训练之后就是我们需要的参数了。其次，有了数据和参数，我们评判模型的标准是什么，通过数据和参数搭建出计算图，这就是前向传播所需要做的内容。最后，我们搭建好了计算图，就要开始训练模型了，训练模型是一个迭代的过程，迭代过程需要指定如何优化，因此就需要定义误差函数和反向传播过程。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统开发平台</title>
    <url>/osdev-platform.html</url>
    <content><![CDATA[<div class="note default">
            <p>工欲善其事，必先利其器。</p>
          </div>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你也想体验开发操作系统的话，那么这篇博客会很适合你。当你想要开发操作系统的时候你可能需要这几样东西：</p>
<ul>
<li>模拟器</li>
<li>编辑器</li>
<li>编译器</li>
<li>汇编程序</li>
</ul>
<p>没错，虚拟模拟器用于运行你写好的镜像。编辑器就是你写代码的地方。刚开始你需要写汇编代码这就需要汇编程序来编辑它。编译器用于编译操作系统开发中主要使用的高级语言程序。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>因为作者考虑除了作者以外可能还有很多人想要学习操作系统，所以就使用 <code>docker</code> 把这些工具打包在一起了，如果想下载就访问文章末尾列出的 <code>Docker Hub</code> 中的镜像。所有组件一共<code>700MB</code>，你可能看着会有点大，这是因为我们使用了 <code>linux</code> 作为底层虚拟机。下面是主要工具：</p>
<ul>
<li>ubuntu 底层虚拟机</li>
<li>qemu 用于模拟实际电脑的模拟器</li>
<li>vim 编辑器之神</li>
<li>gcc C语言编译器</li>
<li>nasm 汇编程序</li>
</ul>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><img src="/images/loading.gif" data-original="/osdev-platform/osdev.png" alt></p>
<h3 id="有关文档"><a href="#有关文档" class="headerlink" title="有关文档"></a>有关文档</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3NjYXJib3JvdWdoY29yYWwvb3NkZXYtdWJ1bnR1Lw==" title="https://hub.docker.com/r/scarboroughcoral/osdev-ubuntu/">Docker Hub<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NmZW5vbGxvc2Evb3MtdHV0b3JpYWw=" title="https://github.com/cfenollosa/os-tutorial">开发参考教程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9xZW11LndlaWxuZXR6LmRlL2RvYy9xZW11LWRvYy5odG1s" title="https://qemu.weilnetz.de/doc/qemu-doc.html">QEMU 使用文档<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5za3l3aW5kLm1lL21ha2VyL2ludGVsLmh0bQ==" title="http://www.skywind.me/maker/intel.htm">Intel 汇编指令集<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWFzc2VtYmx5L2luZGV4Lmh0bWw=" title="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编开发指南（IBM）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vaW50ZWwtODAzODYtcmVmLW1hbnVhbC9jb250ZW50LzEuaHRtbA==" title="https://wizardforcel.gitbooks.io/intel-80386-ref-manual/content/1.html">Intel 80386 程序员参考手册<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jcy5iaGFtLmFjLnVrL35leHIvbGVjdHVyZXMvb3BzeXMvMTBfMTEvbGVjdHVyZXMvb3MtZGV2LnBkZg==" title="http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf">Writing a Simple Operating System —from Scratch<i class="fa fa-external-link"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>通用操作系统原理之虚拟内存</title>
    <url>/virtual-memory.html</url>
    <content><![CDATA[<div class="note default">
            <p>理论驱动实践，实践驱动理论。</p>
          </div>
<a id="more"></a>
<h3 id="虚拟内存问题概述"><a href="#虚拟内存问题概述" class="headerlink" title="虚拟内存问题概述"></a>虚拟内存问题概述</h3><p>如果你了解过一点虚拟内存的知识，这篇笔记可能会让你更深入的理解。</p>
<ul>
<li>三个内存相关的问题<ul>
<li>没有足够的内存</li>
<li>地址空间碎片化</li>
<li>地址冲突</li>
</ul>
</li>
<li>什么是虚拟内存<ul>
<li>中间件</li>
<li>如何解决三个内存问题</li>
<li>页表和转换</li>
</ul>
</li>
<li>如何实现虚拟内存<ul>
<li>怎么让转换变得更快</li>
</ul>
</li>
<li>虚拟内存和高速缓存Cache</li>
</ul>
<h3 id="三个内存相关的问题"><a href="#三个内存相关的问题" class="headerlink" title="三个内存相关的问题"></a>三个内存相关的问题</h3><ul>
<li>没有足够的内存怎么办</li>
</ul>
<p>MIPS提供给每个应用程序32位的地址空间，每个应用程序可以访问这32个地址空间中的任意一个字节。最早的MIPS架构是32位，最新的版本已经变成64位。也就是说你可以使用2^32bytes也就是4GB，这只是理论上，实际可能会缩小到2GB可用空间。</p>
<p>如果你的物理内存（内存条）是1GB该怎么办呢？就像下面这个图，可寻址空间大于实际物理内存大小。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/vm-problem1.png" alt></p>
<ul>
<li>程序如何分配内存（对于碎片内存）</li>
</ul>
<p>就像下面这张图，首先内存加载程序p1和p2，开始3G空间被占用，剩余1G空间剩余，这时候p1退出，p3想使用内存，虽然还有2G剩余空间，但空间是碎片化的，这也是一个问题。这被称作<strong>Memory fragmentation</strong><code>内存碎片化</code>。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/vm-problem2.png" alt></p>
<ul>
<li>如何保证进程安全（进程之间地址不相互访问）</li>
</ul>
<p>就像下面这张图，两个程序同时访问<code>1024</code>这个地址的空间，内存中的信息会不会相互覆盖？</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/vm-problem3.png" alt></p>
<p>总结一下，如果所有程序都有相同的32位的寻址空间，那么可能导致以下问题：</p>
<ul>
<li>如果实际物理能存大小小于4GB电脑可能会崩溃</li>
<li>如果运行多个程序可能会用光所有内存，这不是真正的用光而是碎片化的内存无法真正利用，这种碎片化依赖于我们不同程序的运行次序</li>
<li>不同的进程之间的数据可能会相互覆盖破坏，因为有相同的寻址地址</li>
</ul>
<p>那么如何解决？</p>
<p>问题的关键在于<strong>所有的程序有相同的寻址空间</strong>，那么我们可不可以有属于自己的<strong>虚拟内存</strong>？如果可以的话，我们可以</p>
<ul>
<li>将程序的内存空间和物理内存之间做一个映射（这使得我们使用物理内存RAM变的更加灵活）</li>
<li>当程序用光的时候，我们甚至可以将程序移动到硬盘</li>
</ul>
<h3 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>虚拟内存是一层“中间组件”，虚拟内存的想法来自于一句话：</p>
<blockquote>
<p>Any problem in computer science can be solved by adding indirection.<br>任何计算机问题都可以通过添加一个中间件来解决。</p>
</blockquote>
<p>如果没有虚拟内存这一层中间件，程序寻址空间将和实际物理内存相同。例如寻址空间大小大于实际RAM大小，如果你访问地址2024，得到的结果可能和访问地址24相同（因为地址越界最高位失效）。</p>
<p><em>虚拟内存的作用就是将程序地址空间做一层映射映射到实际RAM地址。</em></p>
<p>如下图所示：</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/whatis-vm1.png" alt></p>
<h4 id="如何解决三个内存问题"><a href="#如何解决三个内存问题" class="headerlink" title="如何解决三个内存问题"></a>如何解决三个内存问题</h4><ul>
<li>没有足够的内存<br>将一部分程序地址空间映射到硬盘，我们需要他的时候只需要将这一部分加载到内存中即可。内存中的暂时不使用的程序（比如Program0）可以将其放到硬盘中，这个过程叫做<code>Page Out</code>，即内存页换出，并更新映射，然后当新程序（P3）来了就可以映射到内存中原来旧程序（P0）部分。</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/not-enough-memory.png" alt></p>
<ul>
<li>碎片内存使用</li>
</ul>
<p>这就是前面提到过的问题，如何充分利用程序退出后碎片化的内存？<br>有了前面提及的映射，这个就比较容易解决了，<strong>我们可以将地址空间按照任意方式映射到实际物理内存RAM</strong></p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/memory-hole.png" alt></p>
<ul>
<li>进程安全（进程之间不相互访问）</li>
</ul>
<p>进程之间的内存如何能够独立、隔离（isolate）出来呢？例如同时访问<code>1024</code>的地址，两个程序如何能保证不是访问的实际物理内存中的同一个区域呢？</p>
<p>通过映射方式我们可以想出来，<strong>只需要保证不同程序的相同虚拟地址映射到不同的物理地址就可以了。</strong></p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/program-secure.png" alt></p>
<p>这样一来，因为每个程序都有自己的地址空间，那么他们不可能访问其他程序的数据，这非常的安全和可靠！</p>
<p>这也是有缺点的，当两个程序合作的时候，如何共享内存呢？<strong>只需要将两个程序各自的虚拟地址空间拿出一部分映射到相同的物理地址空间</strong>。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/memory-share.png" alt></p>
<h4 id="页表和转换"><a href="#页表和转换" class="headerlink" title="页表和转换"></a>页表和转换</h4><p>前面一直提到的映射就是页表的部分，页表所做的功能就是转换，<code>从VA（Virtual Address）虚拟地址转换为PA（Physical Address）物理地址</code>。页表映射的单位是一个<code>页</code>。</p>
<p>那程序是如何访问内存的呢？</p>
<ul>
<li>CPU执行使用虚拟地址。</li>
<li>MMU将虚拟地址转换成物理地址</li>
<li>（可选）如果转换过程中发现映射表中没有物理内存，那么操作系统就将它从硬盘加载到内存并修改映射表</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/vm-work1.png" alt></p>
<ul>
<li>通过物理地址读取RAM并将数据返还给程序。</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/vm-work2.png" alt></p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>页表保存着VA虚拟地址到PA物理地址的映射方式。</p>
<p>下面一步一步说明页表的构建过程，从有问题的页表到一个臻于完美的页表，这可能是现代计算机操作系统所利用的机制。</p>
<p>既然页表保存着虚拟地址到物理地址的映射，那么页表就需要保存每一个虚拟地址到每一个物理地址的映射，我们称每一条记录为页表入口<code>Page Table Entry (PTE)</code>。如果是这样的话，那需要多大的页表？<strong>结合下图：</strong>如果是32位地址空间，每个字就需要1个PTE，这里一个字是32位，也就是4个字节，所以每4个大小也就是2位的地址空间就需要1个PTE，所以总共需要2^30个PTE。又因为每个PTE存储的是一个映射，由于虚拟地址是连续的可以只用偏移地址来表示，只需要存32位的物理地址，所以总共需要2^30x32b=4GB个大小。这说明1个4GB大小的RAM我们就需要拿出全部容量来存储页表，而且这没有考虑每个程序都需要一个页表。如果你没有明白这个计算公式，你仅需要知道如果这样构造页表所需容量太大，需要改造！</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/page-table1.png" alt></p>
<p>那么如何改造呢？以上情况的映射是1个字对应一个PTE页表入口，我们称这种情况为<code>细粒度映射</code>，那我们可不可以使用<code>粗粒度映射</code>呢？就像这个图一样：</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/page-table2.png" alt></p>
<p>这个图中，我们将每4Kb大小的地址空间做一个PTE，我们称之为<code>4KB Pages</code>，因为每个RAM按字节计量，或者你可以看为1K个字大小的页。这样我们就减少了映射也就是PTE的个数。这4KB大小的页映射的内部是连续的，如下图：</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/page-table3.png" alt></p>
<p>有了以上改进，我们有了更少的PTE映射个数，但是我们页降低了使用RAM的灵活性，因为我们每次需要移动一个页（4KB）。</p>
<p>现代计算机系统中，比较典型的就是4KB Pages（1024 words per page，每一页1024个字）。</p>
<h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h5><p>我们需要将虚拟地址转换为物理地址。</p>
<p>假设我们使用的是4KB Pages，我们有32位虚拟地址，28位物理地址，如下图</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/addr-trans1.png" alt></p>
<p>那我们4KB大小的页内部没有做映射，这一部分如何映射呢？解决办法就是使用<code>偏移量offset</code>，如下图</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/addr-trans2.png" alt></p>
<p>我们将一个虚拟地址转换为物理地址，虚拟地址的pagenumber部分通过页表转换为实际物理地址的pagenumber部分，虚拟地址的offset部分直接作为物理地址的offset部分。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/addr-trans3.png" alt></p>
<p>下面这个例子，32位虚拟地址，28位物理地址，4KB大小的页，所以需要12位offset。当虚拟地址为<strong>0x00003204</strong>的时候，将虚拟地址分为虚拟页编号（<strong>0x00003</strong>）、偏移量（<strong>0x204</strong>），offset直接使用，所以物理页内偏移量为<strong>0x204</strong>，虚拟页编号通过查页表，得到物理页编号为<strong>0x0006</strong>。所以得到的物理地址为<strong>0x0006204</strong></p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/addr-trans4.png" alt></p>
<p>当然，如果查页表的时候可能会产生<code>page fault</code>，即所需要的内容没有在RAM中，如图中的<strong>0x00000</strong>，这就需要发生中断，加载内容到RAM，然后修改页表，返回到内存上次执行的位置，这时候就会找到所对应的物理页编号了。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/addr-trans5.png" alt></p>
<p>详细说一下当所需要的页不在内存中时会发生什么：</p>
<ul>
<li>页表入口PTE告诉你所需要的页在硬盘中</li>
<li>硬件（CPU）生成一个Page Fault页错误</li>
<li>硬件跳到Page Fault Handler页错误处理程序来处理<ul>
<li>操作系统选择RAM中的一个页剔除写到硬盘中</li>
<li>如果是需要读取的页是脏页，就需要先将其写回到硬盘再读取</li>
<li>操作系统读取所需要的页到RAM</li>
<li>操作系统修改页表的映射</li>
</ul>
</li>
<li>操作系统跳转到发生页错误的地方开始执行（这一次就不会产生页错误了）</li>
</ul>
<blockquote>
<p>脏页是指页中的数据被改变了，如果没有改变，那就没必要写回到硬盘了。</p>
</blockquote>
<blockquote>
<p>脏页－linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。（来自百度百科）</p>
</blockquote>
<p>那么页不在内存中时，这个过程需要多长时间呢？大约需要80 million 周期，这是采样自现代CPU，其中硬盘的读取占了大多数时间。<strong><em>页错误可能是计算机中最慢的操作了。</em></strong></p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/addr-trans6.png" alt></p>
<p>既然这么慢，那为什么还要用它呢？</p>
<p>优点：</p>
<ul>
<li>你用光了内存计算机不会发生崩溃<br>缺点：</li>
<li>如果发生页错误会很慢</li>
</ul>
<p>但是现代计算机还是使用内存页机制。如果你有非常大、足够大的RAM就不会发生页置换，这就是我们为什么认为内存越大计算机就变的越快的原因。</p>
<p>足够大的内存这是不可能的，不过一些现代操作系统不会发生页置换：</p>
<ul>
<li>IOS：如果你用了过多的内存，系统会杀死你的进程</li>
<li>OS X 10.9：系统会先压缩你的程序，只有不得不置换的时候才会发生</li>
</ul>
<blockquote>
<p>这可能就是为什么在国内Apple比较受欢迎的原因吧，o(<em>￣︶￣</em>)o</p>
</blockquote>
<p>每个程序都有自己的页表，我们可以把每个程序的虚拟地址映射到独一无二的内存中，这是为了程序之间不会没有预测的访问数据。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-protection1.png" alt></p>
<p>这说明每一个程序都有自己的32位虚拟地址空间，下面是Linux虚拟内存空间的使用情况。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-protection2.png" alt></p>
<p>1GB预留给linux内核作为内核区，栈区可以向下扩展到一个固定的最大值，Libraries区用于一些共享库的放置，堆区用于存储动态申请的内存向上扩展，接下来是data数据区用于存储静态变量，代码区用于放置程序编译之后的<code>二进制代码</code>。这之间有一些随机的偏移，这提高了安全性因为你不知道数据和代码区具体在哪儿。</p>
<p>这是一个具体的例子。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-protection3.png" alt></p>
<p>每个程序都有自己的虚拟地址空间，都有自己的页表映射方式保证了程序之间的隔离，因为不会随意相互访问内存，映射到内存的相同区域保证了程序之间的可合作性。</p>
<p>看一看实际如何使用独立的页表映射方式。这儿有两个程序，CPU都要执行这段指令<code>ld R2,2(R0)</code>，就是将内存地址2的数据加载到R2寄存器中，这里的内存地址是虚拟地址，因此需要通过查页表的方式来查询实际物理内存地址，然后取出数据。因为两个程序有不同的页表，执行指令时取得的虚拟地址2对应的物理地址一般不同或者相同（共享，这只需要将不同地址的虚拟地址映射到相同的RAM物理地址即可），因此最终访问的RAM地址也是不同的。CPU执行上下文切换切换进程时会将进程资源一起切换，这个切换就包含页表的切换。就像下面这张图。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-protection4.png" alt></p>
<h3 id="如何实现虚拟内存"><a href="#如何实现虚拟内存" class="headerlink" title="如何实现虚拟内存"></a>如何实现虚拟内存</h3><p>如何让虚拟内存有作用呢？因为虚拟内存使得内存使用更加灵活，但也有可能降低计算机系统的效率，我们只需要让虚拟内存机制达到尽可能大的效率即可。</p>
<p>虚拟内存的使用过程中需要做什么事情？</p>
<ul>
<li>访问内存中的页表</li>
<li>通过查询页表将虚拟地址转换为物理地址</li>
<li>访问RAM相应物理内存中的数据</li>
</ul>
<p>这个过程中访问了内存2次，访问内存有很多的工作要做，要了解到我们平均每条指令就需要访问1.33次内存（4/3，每三条指令访问4次内存），这部分显得很低效，这是优化的部分之一！</p>
<p>使用虚拟内存有优点，因为有“无限制”的程序和内存（每个程序都有地址空间，内存页可以换入换出），可以保护程序内存实现隔离，使用内存变得很灵活；但使用虚拟内存也会带来很昂贵的资源消耗，每个内存操作都需要查询页表，而且需要访问两次内存（1次页表访问、1次内存物理地址（访问RAM数据）访问）</p>
<h4 id="如何更快地完成虚拟地址到物理地址的转换"><a href="#如何更快地完成虚拟地址到物理地址的转换" class="headerlink" title="如何更快地完成虚拟地址到物理地址的转换"></a>如何更快地完成虚拟地址到物理地址的转换</h4><ul>
<li>TLB<br>因为页表的访问是必须的，所以不可能减少这一部分工作。那我们可不可以通过软件来实现？我们知道这又增加了指令条数，也就增加了内存访问次数。那可不可以通过硬件来实现？添加一个缓存Cache。我们称这个<code>Page Table Cache</code>为<code>Translation Lookaside Buffer(TLB)</code>。他的工作机制如下图</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-fast1.png" alt></p>
<p>最初，通过访问RAM中的页表来将虚拟地址转换为物理地址，这是非常慢的操作。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-fast2.png" alt></p>
<p>我们通过访问TLB缓存来获取虚拟地址对应的物理地址这是十分迅速的，因为访问速度比RAM快，这非常像一个Cache。如果想让TLB非常迅速，TLB就必须尽可能小。我们通常将TLB分离成指令页缓存（iTLB）和数据页缓存（dTLB），比如现代intel所生产的，每一页4KB，一共有64个页表入口PTE，或者是每一页2MB，32个PTE，都是4路关联（4路组关联，区别于全关联）</p>
<p>全部页表有1M个PTE，但是TLB里只有64个，这个差别很多大，这样访问页的时候如果在TLB里那就会变得很快。</p>
<ul>
<li>页在RAM中<ul>
<li>PTE在TLB<ul>
<li>最快</li>
<li>1个周期用于地址转换，然后访问RAM或cache中的数据</li>
</ul>
</li>
<li>PTE不在TLB<ul>
<li>较慢</li>
<li>20-1000个周期从RAM中加载PTE到TLB，然后访问RAM数据</li>
</ul>
</li>
</ul>
</li>
<li>页不在RAM<ul>
<li>PTE在TLB（几乎不可能，因为最近不经常使用的内存页被置换到硬盘，所以TLB在这段时间内也被置换了）<ul>
<li>很慢</li>
<li>大约80M周期从硬盘加载到内存</li>
</ul>
</li>
<li>PTE不在TLB<ul>
<li>比很慢还慢一点（o(<em>￣︶￣</em>)o）</li>
<li>20-1000个周期地址转换，这时知道内存页在硬盘</li>
<li>大约80M周期从硬盘加载到内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TLB非常的小，怎么让TLB看着大一点，换句话说如何充分利用这么小的一个空间？</p>
<ul>
<li>让每一页变的大一点。例如从64个4KB大小的页（共256KB数据）换为32个2MB大小的页（共64MB数据）</li>
<li>添加一个二级TLB，可能比一级TLB大一点，但是有一点慢。大多数二级TLB是一级TLB大小的八倍，当一级TLB的PTE没有命中的话就去二级TLB去查找加载到一级TLB</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/mem-fast3.png" alt></p>
<ul>
<li>让硬件自动填充TLB（因为不会经过操作系统的处理）。这被称为<code>Hardware Page Table Walk</code>，由MMU来完成。</li>
</ul>
<p>下面是如何通过TLB将虚拟地址转化为物理地址的例子。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-example1.png" alt></p>
<p>CPU执行指令的时候，使用到了虚拟内存地址<code>0x00003204</code>，需要将虚拟地址转化为物理地址，首先去TLB查找缓存页表，这个例子中发现TLB中没有所要查找的页表入口PTE，然后就需要通过查找RAM中的页表中的PTE，找到了之后就需要将该PTE加载到TLB，然后将虚拟页编号映射到物理页编号（<code>0x00003-&gt;0x0006</code>），页内偏移直接使用，最终获取物理地址<code>0x0006204</code>。</p>
<p>下面再看一个PTE在TLB中的例子。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-example2.png" alt></p>
<p>这个例子中CPU中使用虚拟地址<code>0x00003208</code>，首先通过虚拟页编号到TLB中去找，虚拟页编号<code>0x00003</code>，发现该页在TLB中，那就直接转化为物理地址。</p>
<p>下面又是一种情况，当所查找的页不在TLB中且TLB中满时需要做什么，<strong>需要将TLB中选取一个PTE剔除以释放空间</strong></p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-example3.png" alt></p>
<p>当所需要的页不在RAM中时会发生什么？CPU使用虚拟地址<code>0x00000860</code>，发现页编号<code>0x0000</code>不在TLB中，然后去RAM页表中查找，发现所需物理页在DISK中，然后就需要将DISK中数据加载到RAM中并更新RAM中的页表，然后将页表中对应的PTE加载到TLB中，将虚拟页号转换为物理页号获取物理地址。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-example4.png" alt></p>
<ul>
<li>多级页表</li>
</ul>
<p>多级页表是使优化地址转换的另一方法。首先我们考虑一下页表的大小，虽然我们使用了4KB大小的页来减少页表中PTE中的数量，但对于32位大小的虚拟地址空间来说还是会有1M个PTE，每个PTE大约占4B（20位物理地址，还有其他的权限标志位等）。总共4MB。但是我们<strong>每个程序都需要一个页表</strong>，假设我们有<strong>100</strong>个程序在运行，那内存中就需要有400MB来维护各个程序的页表！还有一点，我们无法将页表换出到DISK硬盘中，因为我们需要通过页表来获取实际RAM物理地址，如果页表不在RAM中那我们就没有办法找到页表了（因为我们需要页表进行地址转换，其他设备的数据都是通过页表加载到内存并更新页表）。</p>
<p>那怎么解决这个问题呢？</p>
<p>我们虚拟内存的实现是通过添加一个中间件的思想实现的，那我们可不可以再添加更过的中间件来处理这个问题，答案是肯定的，使用<code>多级页表</code>。</p>
<p>下图是一个例子。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/multi-level-page-table1.png" alt></p>
<p>这个例子中使用了二级页表,一级页表中存了1024个4KB的页的PTE，每个PTE中物理页编号指向的是一个二级页表，这个页表对应存储的才是真正数据对应的物理页。对于每个程序，每个二级页表有1024个PTE，一共有1024个二级页表，那么有1024x1024个PTE，刚好就是1M个PTE，和未使用多级页表中的情况是一样的。</p>
<p>所以有了多级页表机制，我们可以把一级以下的页表换出到DISK硬盘中，因为我们可以通过一级页表来获取它，这也说明了一点我们必须要把一级页表存储在RAM中，就像下面这张图。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/multi-level-page-table2.png" alt></p>
<p>我们来思考一下，使用了多级页表，对于一个32位应用程序我们至少需要多大的内存空间来保存页表呢？<code>4KB+4KB</code>，因为使用了多级页表，一级页表必须存储在RAM中，因为一级页表只告诉我们二级页表的物理地址，所以我们还需要一个二级页表来获取实际的程序数据所在物理地址。一级页表有1024个PTE，每个PTE大约4B，所以一级页表是4KB，二级页表同样如此，所以总共为4KB+4KB，这比4MB好多了！</p>
<p>下面是一个二级页表使用的一个例子。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/multi-level-page-table3.png" alt></p>
<p>CPU使用到了虚拟地址<code>0x00402204</code>，那就需要将其转换为物理地址，转换过程中将虚拟地址分为两个部分：虚拟页号和页内偏移，虚拟页号又分为一级页表编号和二级页表编号。两级页表分别使用虚拟页号的一半（10位），对于虚拟地址0x00402204，一级页表编号N1是<code>0000 0000 01</code>，二级页表编号N2是<code>00 0000 0010</code>，首先使用N1查询RAM中的一级页表得到二级页表的物理页地址（一个页刚好是4KB，二级页表的大小），如果页不在RAM中就需要将它加载到RAM中并更新一级页表，然后使用N2查询二级表获取实际数据的物理页地址，如果实际数据的内存页不在RAM中就需要加载到RAM中并更新二级页表，最终通过物理页地址和虚拟地址的页内偏移得到了最终的物理地址。</p>
<p>小结一下：</p>
<ul>
<li>每个运行的程序需要一个一级页表存储在RAM中，这样可以获取低级的页表以获取实际数据的物理页。</li>
<li>需要一个二级页表存储在RAM中，这样我们可以翻译程序的某些地址，随时切换。</li>
<li>使用两级页表共同完成地址<code>VA-&gt;PA</code>的转换</li>
<li>高10位地址用于索引一级页表的PTE</li>
<li>接下来的10位用于索引二级页表的PTE</li>
<li>我们可以置换页表中的一部分到DISK硬盘中</li>
</ul>
<h3 id="虚拟内存和高速缓存Cache"><a href="#虚拟内存和高速缓存Cache" class="headerlink" title="虚拟内存和高速缓存Cache"></a>虚拟内存和高速缓存Cache</h3><p>这一部分讨论有关TLB转译后备缓冲区和高速缓存Cache的交互问题。</p>
<p>我们通常有两种方式来将TLB和Cache来交互：</p>
<ul>
<li>物理缓存（<code>Physical Cache</code>），Cache使用物理地址（比较慢，访问cache之前必须做一次TLB地址转换，假设TLB转换需要1个周期、物理地址读取Cache需要1个周期）</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-cache1.png" alt></p>
<ul>
<li>虚拟缓存（<code>Virtual Cache</code>），Cache使用虚拟地址直接获取缓存数据（很快，1个周期），不必进行地址转换，如果Cache没有命中才会发生地址转换。</li>
</ul>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-cache2.png" alt></p>
<p>对于虚拟缓存来说，两个程序不能共享虚拟缓存，因为虚拟缓存使用的是虚拟地址，虚拟内存的程序隔离机制无法起作用（因为地址没有转换），这也是虚拟缓存的一个问题。我们也可以简单地解决这个问题，方法就是不仅仅使用虚拟地址，再添加一个标志位用于区分是哪一个应用程序（比如PID）。</p>
<p>有没有两全其美的方法，访问Cache的同时访问TLB，仍然可以使用虚拟内存的隔离机制。</p>
<ul>
<li>还是使用虚拟地址<strong>VA</strong>访问Cache，cache数据记录中有一个物理标志<strong>PTag</strong>，同时通过TLB将虚拟地址<strong>VA</strong>转换为物理地址<strong>PA</strong></li>
<li>通过物理标志<strong>PTag（缓存数据所在的RAM物理地址）</strong>和TLB获取的物理地址<strong>PA</strong>比较是不是命中</li>
</ul>
<p>这只是想法，具体实现还是有些差别，下面一步步说明。</p>
<p><img src="/images/loading.gif" data-original="/virtual-memory/tlb-cache3.png" alt></p>
<p>这种访问我们称之为<code>虚索引实标签缓存（Virtually Indexed,Physically Tagged）</code>，这是当今处理器中最常用的一级缓存。</p>
<blockquote>
<p>这种缓存利用了页面技术的一个特征，即虚拟地址和物理地址享有相同的页内偏移值（page offset）。(Wikipedia)</p>
</blockquote>
<ul>
<li>Cache通过页内偏移（虚拟和物理是相通的）索引</li>
<li>用物理页面号做标志</li>
</ul>
<p>这样我们既实现了使用虚拟地址访问Cache（快速，不用地址转换），又实现了虚拟内存隔离保护机制（物理地址做标志）。</p>
<blockquote>
<p>这种技术的一个缺点是，在使用直接匹配缓存的前提下，缓存大小不能超过页面大小，否则页面偏移范围就不足以覆盖缓存索引范围。这个弊端可以通过提高组相联路数来改善。(Wikipedia)<strong>（待完善）</strong></p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>TLB地址转换和查询Cache同时进行<ul>
<li>使用虚拟页号进行地址TLB转换</li>
<li>使用虚拟地址偏移量进行cache索引</li>
<li>通过TLB获取了物理页号</li>
<li>通过Cache获取了物理标志（物理页号）</li>
</ul>
</li>
<li>TLB转换得到的物理页号和物理标志<code>PA Tag</code>相等说明缓存命中。</li>
</ul>
<p>这种方式快速的原因是地址转换和cache索引同时进行，安全的原因是Cache只有在物理地址匹配的情况下才会命中。<br><img src="/images/loading.gif" data-original="/virtual-memory/tlb-cache4.png" alt></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong><em>以上便是对虚拟内存的学习和总结，可能还有一些地方会有错误或者知识点漏洞，希望读者可以热情的提出<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvT1MtTm90ZXMvaXNzdWVzL25ldw==" title="https://github.com/ScarboroughCoral/OS-Notes/issues/new">issue<i class="fa fa-external-link"></i></span>。如果还有不理解的地方可以查阅文章末尾我所参考的一些资料，谢谢阅读！</em></strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><h4 id="引用作品"><a href="#引用作品" class="headerlink" title="引用作品"></a>引用作品</h4><ul>
<li>David Black-Schaffer.(2014).<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xY0JJdm5RdDBCdyZhbXA7aW5kZXg9MSZhbXA7bGlzdD1QTGl3dDFpVlVpYjlzMlVvNUJlWW13a0RGVWg3MGZKUHhY" title="https://www.youtube.com/watch?v=qcBIvnQt0Bw&amp;index=1&amp;list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX">Virtual Memory<i class="fa fa-external-link"></i></span></li>
</ul>
<h4 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h4><ul>
<li>Aniruddha-Tapas.(2014).<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FuaXJ1ZGRoYS1UYXBhcy9PcGVyYXRpbmctU3lzdGVtcy1Ob3Rlcw==" title="https://github.com/Aniruddha-Tapas/Operating-Systems-Notes">Operating Systems Notes<i class="fa fa-external-link"></i></span></li>
<li>wikipedia.(2018).<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQ1BVJUU3JUJDJTkzJUU1JUFEJTk4" title="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98">CPU Cache<i class="fa fa-external-link"></i></span></li>
</ul>
<h4 id="参阅书目"><a href="#参阅书目" class="headerlink" title="参阅书目"></a>参阅书目</h4>]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Windows API</title>
    <url>/shadow-thinking-in-winapi.html</url>
    <content><![CDATA[<div class="note default">
            <p>尽管SEDF_JKHJKE这种变量定义形式很烂，但死磕一次。</p>
          </div>
<a id="more"></a>
<h3 id="Windows-API中的窗口程序API"><a href="#Windows-API中的窗口程序API" class="headerlink" title="Windows API中的窗口程序API"></a>Windows API中的窗口程序API</h3><p>这篇博客主要是想简单写一写Windows API中关于图形窗口程序的部分。我认为图形窗口部分最核心的就是消息循环机制，虽然不知道内部如何实现，不知道内部是不是需要调度，消息队列可能就是最简单的FIFS（先到先服务的思想来处理消息）。</p>
<h3 id="消息是什么消息"><a href="#消息是什么消息" class="headerlink" title="消息是什么消息"></a>消息是什么消息</h3><p>消息是I/O消息或者软件消息，这些消息是有编码的，比如按下键盘<code>VK_XXX</code>或者关闭程序<code>VM_CLOSE</code>这些，实际上这些消息都有一个唯一确定的ID，即它的编码。当消息被触发时，Windows会封装一个MSG对象，这个MSG对象里面至少有一个消息的编码<code>ID</code>，然后把这个MSG对象放入消息队列。当MSG对象排队到队头时，就会对此消息进行处理，进行处理的函数是<code>消息回调函数</code>（代码中的<code>MyWinProc</code>），这是自己定义的，需要你来对某些你所需要的消息进行特殊的处理。</p>
<blockquote>
<p>这是不停地从消息队列队头取消息并分发处理<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	TranslateMessage(&amp;msg);</span><br><span class="line">	DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这是处理消息时回调函数，根据不同的消息ID编码值做出不同的处理。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWinProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (msg)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		DestroyWindow(hwnd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, msg, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h3><p>创建窗口毫不意外需要以下东西：</p>
<ul>
<li>窗口属性配置信息，即代码中的<code>WNDCLASS</code></li>
<li>创建函数，及代码中的<code>CreateWindow</code></li>
</ul>
<p>另外还需要以下东西：</p>
<ul>
<li>创建窗口前需要将窗口属性配置信息注册<code>RegisterClass(&amp;wndclass)</code></li>
<li>创建完窗口之后需要将窗口显示<code>ShowWindow(hwnd, SW_NORMAL)</code>和开始更新<code>UpdateWindow(hwnd)</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWinProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (msg)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		DestroyWindow(hwnd);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hwnd, msg, wparam, lparam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span> </span>&#123;</span><br><span class="line">	WNDCLASS wndclass = &#123;</span><br><span class="line">		CS_HREDRAW | CS_VREDRAW,</span><br><span class="line">		MyWinProc,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		hInstance,</span><br><span class="line">		LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION),</span><br><span class="line">		LoadCursor(<span class="literal">NULL</span>, IDC_ARROW),</span><br><span class="line">		(HBRUSH)GetStockObject(GRAY_BRUSH),</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="string">"wincls"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	RegisterClass(&amp;wndclass);</span><br><span class="line">	HWND hwnd = CreateWindow(<span class="string">"wincls"</span>, <span class="string">"我的窗口"</span>, WS_OVERLAPPEDWINDOW, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	ShowWindow(hwnd, SW_NORMAL);</span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line">	MSG msg;</span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Windows API</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统——关于新的思考和新的目标</title>
    <url>/thinking-2018-9-23.html</url>
    <content><![CDATA[<div class="note default">
            <p>计算机操作系统是最复杂的软件之一。</p>
          </div>
<a id="more"></a>
<h3 id="2018年9月23日的思考——新的目标"><a href="#2018年9月23日的思考——新的目标" class="headerlink" title="2018年9月23日的思考——新的目标"></a>2018年9月23日的思考——新的目标</h3><blockquote>
<p>先来说一下为什么懒散的我很长时间没有动博客今日却心血来潮。此刻我电脑上有一个进程正在下载着<code>i386</code>的ubuntu镜像，今天的主题和这个镜像有关，它只是一个开发环境。开发什么呢，或者说这仅仅是一个实验，来自<code>MIT</code>操作系统的实验，这只是听某位学长偶然提及的。没错，核心主题就是<strong>操作系统</strong>，这个实验的训练价值确实有一定可取性，但学长更为推荐的是一本书：<code>《linux内核完全剖析》</code>，如果你有操作系统方面的研究兴趣的话可以借鉴一下。我认为操作系统的研究价值有二：其一是知识价值，计算机最基础的知识之一。其二如下。</p>
</blockquote>
<h4 id="为什么是操作系统"><a href="#为什么是操作系统" class="headerlink" title="为什么是操作系统"></a>为什么是操作系统</h4><blockquote>
<p>在暑假以及开学的2周里，我把操作系统的知识点回顾了一遍。也看了一部分<code>linux0.11</code>的源码，虽然至今仍未进入其<code>main</code>函数。</p>
</blockquote>
<p>为什么是操作系统？我认为操作系统是软件或者计算机硬件之上最重要的一部分。或许你认为当前最火的计算机技术有很多，比如说人工智能、大数据分析、云计算等等。没错，对于人工智能来说，如果你仅停留在如何调用<code>TensorFlow API</code>的层面上，那和普通咸鱼有什么区别。当然如果你能够解析内部实现原理，比如各种神经网路、误差缩减方法实现，而且能够进一步优化或者设计一种新的方法，那才是真正的工程师。将所有的开发技术抽象而言，都是工具。我认为对于这一方面有三个层次：使用工具，改造工具，创造工具。使用工具的人是普通咸鱼，能够改造工具的人是高级咸鱼，能够创造工具的才能称之为工程师。话说回来，为什么是操作系统？</p>
<p>这只是一个猜想：</p>
<p>操作系统存在于哪？存在于终端之上————电脑、手机、智能手表等等，常见的也就这几种。但是以后会有什么其他类型的终端？眼睛框上有个终端？加上增强现实，就像科幻电影里那样。项链上有个终端？戒指上有个终端？而且对于不同的终端有不尽相同的操作系统，这就是操作系统与终端的搭配。</p>
<h4 id="操作系统需要什么"><a href="#操作系统需要什么" class="headerlink" title="操作系统需要什么"></a>操作系统需要什么</h4><blockquote>
<p>操作系统是干什么的？用于管理硬件的软件。需要的就是如何管理硬件，如何有效的利用好各个硬件。如何更有效率的使用好CPU——CPU管理，有效率的使用好内存——内存管理，有效率的使用好外设——外设管理，更好的让用户操作——文件管理。</p>
</blockquote>
<p>计算机至少需要一个处理器、一个存储设备、一个输入设备和一个输出设备。最基础的就是管理这些东西而已。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>双系统的实现原理</title>
    <url>/daul-system-principle.html</url>
    <content><![CDATA[<div class="note default">
            <p>硬件令机器变快。软件则把快机器搞慢。</p>
          </div>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天谈一谈双系统的实现原理，其实写这篇博客的时候我还没怎么彻底搞懂，不过在写的过程中会边思考边写，因为借鉴了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvSW5udGVydmlld05vdGVzL2Jsb2IvbWFzdGVyL25vdGVzL0xpbnV4Lm1k" title="https://github.com/CyC2018/InnterviewNotes/blob/master/notes/Linux.md">CyC2018/Interview-Notebook<i class="fa fa-external-link"></i></span>，这个文档也是借鉴了一本书<code>《鸟哥的Linux私房菜》</code>。</p>
<h3 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h3><p>你也许会发现身边有许多装逼大神，用电脑就用电脑了，还非得矫揉造作地弄一个双系统，<code>Windows+Linux</code>，旁人一看，立马感觉逼格顶呱呱。双系统很好理解，无非就是一个选择问题，内部过程一目了然，<code>一个if语句嘛</code>。打个不合适的比方，就比如上厕所，这厕所就好比是操作系统，有男厕所、女厕所，你进厕所前就是一个选择嘛。下面我们就看一下机器是如何选择的。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在谈实现原理之前，我们必须要搞清楚几个概念，也许你可能听说过这些概念，但却不知道它是干嘛用的，那么你很适合读这篇文章。</p>
<blockquote>
<p>在看这些概念的过程中，你可以结合这张图来看。虽然有些繁体字，就当<code>涨姿势了</code>我滴乖。</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/daul-system-principle/daul.jpg" alt></p>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><p>我靠，是你！<code>BIOS</code>，之前安装<code>virtual box</code>的时候还见过你，当时让我开启一下<code>Intel VT-x</code>，然后就需要让<code>BIOS</code>大哥帮忙。操作系统老师好像也讲过，好像。。。<br>那么这个<code>BIOS</code>到底是个什么鬼？<code>Basic Input Output System</code>。结合英文全称来说一下，基本输入输出系统。没错，<strong>BIOS 是开机的时候计算机执行的第一个程序</strong>，他会决定你开启电脑后的下一步工作。<code>BIOS</code>大哥知道你的磁盘里哪些可以开机，并且会读取第一个扇区的<code>MBR</code>，那什么又是<code>MBR</code>？</p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p><code>Master boot record, MBR</code>，翻译过来是主要开机记录，这又是什么鬼？我也不太明确这个定义，不过我确切的知道它是用来干嘛的。<code>MBR是可以执行自己内部的开机管理程序的</code>。</p>
<h4 id="开机管理程序"><a href="#开机管理程序" class="headerlink" title="开机管理程序"></a>开机管理程序</h4><p>wtf？定义一个跟一个，什么鬼？客官您别着急，好戏马上开始。。。开机管理程序是干嘛的？开机管理程序会加载操作系统的核心文件。那就很清楚了吧，一个电脑里装上两个系统，<strong>只需要有两个开机管理程序就行了呗。</strong><br>我们再来仔细看一下开机管理程序的其他功能。</p>
<blockquote>
<p>选单、载入核心文件以及转交其它开机管理程序。<code>转交这个功能可以用来实现了多重引导</code>，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动 MBR 中的开机管理程序时，就可以选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>捋一捋思路。一切从开启电源开始。。。</p>
<blockquote>
<p>电源开启，电脑启动<code>BIOS</code>，BIOS读取第一个扇区的<code>MBR</code>，MBR看自己内部有没有<code>开机管理程序</code>（没有的话就废了，没装系统嘛），有的话，看看<code>选单</code>里面有啥东西，（如果安装了Linux和Windows），自身的开机管理程序是Windows的，并且可以转发到另一个开机管理程序。那么选单里就有两个选项，载入Windows和<code>载入Linux</code>，而载入Linux实际上是两个步骤，先<code>转发到Linux开机管理程序的位置</code>，然后由Linux的开机管理程序，载入Linux系统核心。</p>
</blockquote>
<p>嗯，就这样了，照着图看更清晰哟。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>DAO层设计规范</title>
    <url>/dao-specification.html</url>
    <content><![CDATA[<div class="note default">
            <p>人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1万小时的锤炼是任何人从平凡变成世界级大师的必要条件。</p>
          </div>
<a id="more"></a>
<h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p><code>DAO</code>,Data Acess Object。数据访问对象，顾名思义，是用来访问数据的，数据存在于数据库中，显然DAO用于访问数据库。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>为什么要用连接池呢？数据库连接池正如同线程池的目的一样都是为了提高效率，对于数据库连接池，用户每次请求都需要创建一个数据库连接，这毫无疑问会使系统变得异常缓慢，为了避免这样的系统效率问题，所以有了连接池这种方式，系统启动时就会创建一个连接池，连接池中有一定量的数据库连接对象，当用户发起请求，系统会到连接池中取一个连接，当请求完成后会将连接放回到连接池中，这样就大大提高了系统的执行效率。在JAVA Web开发中使用数据源DataSource来获取连接。</p>
<h3 id="DAO设计规范"><a href="#DAO设计规范" class="headerlink" title="DAO设计规范"></a>DAO设计规范</h3><p>刚刚入门的时候，我对DAO的设计一无所知，我只是单纯的把一张表对应一个DAO对象，直接创建一个类，并未做任何抽象。看了《Java Web应用开发和案例教程》之后，确实对DAO层的设计有了一定的了解。</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul>
<li><p>肯定需要抽象，所有DAO在使用的时候都会先获取数据库连接，因此可以抽象一个接口出来。把他叫做<code>DAO</code></p>
</li>
<li><p>把DAO层公共的地方抽取出来当做一个类，比如说获取连接。其他普通的DAO类都会扩展此类，即继承此类。它叫做<code>BaseDAO</code></p>
</li>
<li><p>对于特定的DAO也需要进行接口设计，因为这样有利于管理和设计</p>
</li>
<li><p>特定的DAO会继承BaseDAO并实现其特定接口</p>
</li>
</ul>
<h4 id="整体类图"><a href="#整体类图" class="headerlink" title="整体类图"></a>整体类图</h4><p><img src="/images/loading.gif" data-original="/dao-specification/UMLer.jpg" alt></p>
]]></content>
      <categories>
        <category>Back-End Development</category>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>多容器APP之Compose学习笔记(一)</title>
    <url>/docker-zero.html</url>
    <content><![CDATA[<div class="note default">
            <p>人类善用工具，是因为懒。</p>
          </div>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一段时间比较乱,不知道要干点什么,索性就直接刷了几本书.现在在刷的是《Java Web 应用开发与案例教程》，这本书本人觉着比较棒，虽然讲了JSP的使用，毕竟现在JSP不是主流了，应该是如此，自从前后端分离之后，HTML，CSS，JavaScript的出现，使客户端实现动态网页流行了起来。但其中的一些知识点还是需要知道的，比如说ServletContext、Session、Request、PageContext的生命周期，转发和重定向等。恩，接下来进入主题。</p>
<h3 id="Compose的学习"><a href="#Compose的学习" class="headerlink" title="Compose的学习"></a>Compose的学习</h3><p>前几天对Docker的入门直接刷了一个Mooc，但是不怎么系统。就像那样说的<code>现在手机使得知识点变得零碎起来，而系统学习是必须的</code>。那如何做到系统学习？一是书籍，而是官方教程。我认为如此。我打算在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS8=" title="https://docs.docker.com/compose/">官方教程<i class="fa fa-external-link"></i></span>里面看一下Compose的系统学习思路。</p>
<h3 id="Compose的构建过程"><a href="#Compose的构建过程" class="headerlink" title="Compose的构建过程"></a>Compose的构建过程</h3><p>首先要明确一点，我们用Docker是来干嘛的？用Compose是用来干嘛的？Docker是为了让工程摆脱环境，Compose是集成多个容器，这是因为有时候单个容器并不能完成我们的需求。那么Compose是如何构建的呢？</p>
<p>我们思考，为什么Docker让工程摆脱了环境？这是因为Docker已经将环境也顺便打包到集装箱里了。那么构建过程第一步便是底层环境的构建，<code>任何应用必须运行在操作系统上</code>，这里就是Dockerfile的构建，当然这里面可能有一系列命令，总之Compose会让Dockerfile里面的命令先执行完毕。就像下面这个文件一样<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.4</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>然后第二步便会找Compose的配置文件<code>docker-compose.yml</code>这里面配置了你所需要的服务，需要哪些容器镜像，配置端口等等。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure></p>
<p>这是构建过程<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Building web</span><br><span class="line">Step 1/5 : FROM python:3.4-alpine</span><br><span class="line">3.4-alpine: Pulling from library/python</span><br><span class="line">81033e7c1d6a: Pull complete</span><br><span class="line">9b61101706a6: Pull complete</span><br><span class="line">415e2a07c89b: Pull complete</span><br><span class="line">f22df7a3f000: Pull complete</span><br><span class="line">8c16bf19c1f9: Pull complete</span><br><span class="line">Digest: sha256:fe436cb066394d81cf49448a04dec7c765082445a500bc44f1ae5e8a455793bd</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> python:3.4-alpine</span><br><span class="line"> ---&gt; 5c72717ec319</span><br><span class="line">Step 2/5 : ADD . /code</span><br><span class="line"> ---&gt; 73b857a9e7be</span><br><span class="line">Step 3/5 : WORKDIR /code</span><br><span class="line">Removing intermediate container 36713f6d9d18</span><br><span class="line"> ---&gt; 7de417856227</span><br><span class="line">Step 4/5 : RUN pip install -r requirements.txt</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> f9b8a9c9be05</span><br><span class="line">Collecting flask (from -r requirements.txt (line 1))</span><br><span class="line">  Downloading Flask-0.12.2-py2.py3-none-any.whl (83kB)</span><br><span class="line">Collecting redis (from -r requirements.txt (line 2))</span><br><span class="line">  Downloading redis-2.10.6-py2.py3-none-any.whl (64kB)</span><br><span class="line">Collecting Jinja2&gt;=2.4 (from flask-&gt;-r requirements.txt (line 1))</span><br><span class="line">  Downloading Jinja2-2.10-py2.py3-none-any.whl (126kB)</span><br><span class="line">Collecting itsdangerous&gt;=0.21 (from flask-&gt;-r requirements.txt (line 1))</span><br><span class="line">  Downloading itsdangerous-0.24.tar.gz (46kB)</span><br><span class="line">Collecting click&gt;=2.0 (from flask-&gt;-r requirements.txt (line 1))</span><br><span class="line">  Downloading click-6.7-py2.py3-none-any.whl (71kB)</span><br><span class="line">Collecting Werkzeug&gt;=0.7 (from flask-&gt;-r requirements.txt (line 1))</span><br><span class="line">  Downloading Werkzeug-0.14.1-py2.py3-none-any.whl (322kB)</span><br><span class="line">Collecting MarkupSafe&gt;=0.23 (from Jinja2&gt;=2.4-&gt;flask-&gt;-r requirements.txt (line 1))</span><br><span class="line">  Downloading MarkupSafe-1.0.tar.gz</span><br><span class="line">Building wheels <span class="keyword">for</span> collected packages: itsdangerous, MarkupSafe</span><br><span class="line">  Running setup.py bdist_wheel <span class="keyword">for</span> itsdangerous: started</span><br><span class="line">  Running setup.py bdist_wheel <span class="keyword">for</span> itsdangerous: finished with status <span class="string">'done'</span></span><br><span class="line">  Stored <span class="keyword">in</span> directory: /root/.cache/pip/wheels/<span class="built_in">fc</span>/a8/66/24d655233c757e178d45dea2de22a04c6d92766abfb741129a</span><br><span class="line">  Running setup.py bdist_wheel <span class="keyword">for</span> MarkupSafe: started</span><br><span class="line">  Running setup.py bdist_wheel <span class="keyword">for</span> MarkupSafe: finished with status <span class="string">'done'</span></span><br><span class="line">  Stored <span class="keyword">in</span> directory: /root/.cache/pip/wheels/88/a7/30/e39a54a87bcbe25308fa3ca64e8ddc75d9b3e5afa21ee32d57</span><br><span class="line">Successfully built itsdangerous MarkupSafe</span><br><span class="line">Installing collected packages: MarkupSafe, Jinja2, itsdangerous, click, Werkzeug, flask, redis</span><br><span class="line">Successfully installed Jinja2-2.10 MarkupSafe-1.0 Werkzeug-0.14.1 click-6.7 flask-0.12.2 itsdangerous-0.24 redis-2.10.6</span><br><span class="line">Removing intermediate container f9b8a9c9be05</span><br><span class="line"> ---&gt; 9daf3f18ec3b</span><br><span class="line">Step 5/5 : CMD [<span class="string">"python"</span>,<span class="string">"app.py"</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> bd6fd9143af8</span><br><span class="line">Removing intermediate container bd6fd9143af8</span><br><span class="line"> ---&gt; 159831743522</span><br><span class="line">Successfully built 159831743522</span><br><span class="line">Successfully tagged composetest_web:latest</span><br><span class="line">WARNING: Image <span class="keyword">for</span> service web was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.</span><br><span class="line">Pulling redis (redis:alpine)...</span><br><span class="line">alpine: Pulling from library/redis</span><br><span class="line">ff3a5c916c92: Already exists</span><br><span class="line">aae70a2e6027: Pull complete</span><br><span class="line">87c655da471c: Pull complete</span><br><span class="line">a0bd51ac7350: Pull complete</span><br><span class="line">755565c3ea2b: Pull complete</span><br><span class="line">8bf100ea488d: Pull complete</span><br><span class="line">Digest: sha256:4f54ade2260d5c80283d044ab9657f390cb8effd9a7a847765693a3670f6874a</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:alpine</span><br><span class="line">Creating composetest_web_1   ... <span class="keyword">done</span></span><br><span class="line">Creating composetest_redis_1 ... <span class="keyword">done</span></span><br><span class="line">Attaching to composetest_web_1, composetest_redis_1</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Docker-Compose</tag>
      </tags>
  </entry>
  <entry>
    <title>多容器APP之Compose学习笔记(二)</title>
    <url>/docker-two.html</url>
    <content><![CDATA[<div class="note default">
            <p>人类善用工具，是因为懒。</p>
          </div>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>已经不能称之为学习笔记了，因为官方文档实在是枯燥，于是我就直接对着某个实例上了。本次我搭建了一个可以复用的环境，<code>Mysql+Tomcat+Nginx</code>可能这样搭配有点不合理，或许，毕竟对这方面了解的不多，不过搭建出来确实能用。而且能够复用，你只需要将你的JavaWeb工程打包成War文件放到Tomcat的webapps目录下就行了。</p>
<h3 id="Compose服务配置"><a href="#Compose服务配置" class="headerlink" title="Compose服务配置"></a>Compose服务配置</h3><p>这个环境中需要三层服务，一是数据库层，二是app层，三是nginx用作代理层。因为是比较小的项目所以没有做反向代理的配置，但是此环境可用于扩展，将Tomcat部署到不同的模拟服务器下，并用nginx反向代理。这是可扩展的。下面是我的目录结构：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">env_template</span></span><br><span class="line">│   </span><br><span class="line">│   <span class="selector-tag">docker-compose</span><span class="selector-class">.yml</span></span><br><span class="line">│</span><br><span class="line">└───<span class="selector-tag">lostfound</span></span><br><span class="line">│   │   </span><br><span class="line">│   │   <span class="selector-tag">Dockerfile</span></span><br><span class="line">│   </span><br><span class="line">└───<span class="selector-tag">nginx</span></span><br><span class="line">    │   </span><br><span class="line">    │   <span class="selector-tag">nginx</span><span class="selector-class">.conf</span></span><br><span class="line">    │   <span class="selector-tag">Dockerfile</span></span><br></pre></td></tr></table></figure>
<p>服务配置使用默认名为docker-compose.yml的配置文件来配置的。下面是我的配置文件<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">lostfound:</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">lostfound:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">lostfound</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lostfound</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/lostfound/webapps:/usr/local/tomcat/webapps</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lostfound</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lostfound</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"mysql:5.7.15"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lostfound</span> </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">lostfound</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">******</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$PWD/data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3306:3306"</span></span><br></pre></td></tr></table></figure></p>
<p>简单说一下，三层服务配置。三项服务在同一个网络<code>lostfound</code>内，lostfound层就是app层，是从工程目录下的lostfound文件夹构建的，里面就是tomcat，端口映射8080。为了容易部署我的web应用程序，我将lostfound层的<code>tomcat/webapps</code>挂载到本地。然后app层依赖于数据库层，等待数据库层构建运行，数据库层应用了Mysql5.7里面有一些环境的配置，另外为了使得数据持久化，我将容器中的保存数据的文件夹也挂载到本地，端口映射为3306，<strong>如果你的3306端口被占用，时会报错的，你需要停止你的3306端口的应用程序，一般来说是Mysql服务</strong>。使用<code>sudo service mysql stop</code>来结束本地的mysql服务。然后是nginx服务，这层服务对于这种小工程来说不是必需的，但是为了可扩展我就加上了。端口映射为默认端口80。</p>
<h3 id="Tomcat-构建"><a href="#Tomcat-构建" class="headerlink" title="Tomcat 构建"></a>Tomcat 构建</h3><p>这个比较简单，就是<code>pull</code>一个镜像，并暴露端口8080。这是其Dockerfile文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomcat</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<h3 id="Nginx-构建"><a href="#Nginx-构建" class="headerlink" title="Nginx 构建"></a>Nginx 构建</h3><p>这个也是<code>pull</code>一个镜像，然后将代理设置一下。</p>
<ul>
<li><p>Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx.conf</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>;</span><br><span class="line"><span class="section">events</span> &#123;<span class="attribute">worker_connections</span> <span class="number">1024</span>;&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://lostfound:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>将tomcat运行的webapp代理到nginx。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote>
<p>运行此环境需要你安装以下工具：</p>
<ul>
<li>Docker</li>
<li>Docker-Compose</li>
</ul>
</blockquote>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打开浏览器，地址栏内输入<code>localhost/yourappname</code></p>
</blockquote>
<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjYXJib3JvdWdoQ29yYWwvU0VfRG9ja2Vy" title="https://github.com/ScarboroughCoral/SE_Docker">https://github.com/ScarboroughCoral/SE_Docker<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Docker-Compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门思考</title>
    <url>/docker-one.html</url>
    <content><![CDATA[<div class="note default">
            <p>人类善用工具，是因为懒。</p>
          </div>
<a id="more"></a>
<h3 id="Docker的本地博客"><a href="#Docker的本地博客" class="headerlink" title="Docker的本地博客"></a>Docker的本地博客</h3><blockquote>
<p>这是我用组合镜像工具搭建的一个本地博客，用到了nginx反向代理服务器，ghost博客镜像（npm包管理），还一个mysql镜像。<br><img src="/images/loading.gif" data-original="/docker-one/docker.png" alt></p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>最近弄了一下自己的<span class="exturl" data-url="aHR0cDovL3NjYXJib3JvdWdoY29yYWwudG9w" title="http://scarboroughcoral.top">个人网站<i class="fa fa-external-link"></i></span>和博客，花了2块钱买了一年的域名。域名解析github page太让人欲罢不能，现在想来就吐血。这篇文章主要是写最近使用的一项技术，感觉逼格真高。但更重要的是非常方便。我猜测docker可能是以后老师检查课设的重要手段之一，嘘，猜测。从一开始学习使用，到搭建一个本地博客。这<code>docker</code>果然是个好东西。</p>
</blockquote>
<h3 id="拿来就用，不依赖第三方环境"><a href="#拿来就用，不依赖第三方环境" class="headerlink" title="拿来就用，不依赖第三方环境"></a>拿来就用，不依赖第三方环境</h3><blockquote>
<p>就是这样，只要你的电脑上安装上docker，并且在<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=" title="https://hub.docker.com/">Docker Hub<i class="fa fa-external-link"></i></span>上有一个账号，你就可以从上面下载镜像并跑起来。正因如此，童鞋们可以将自己的课设通过docker打造镜像上传到<code>Docker Hub</code>上供老师们欣赏。不想原来那样，将自己的源代码打包发给老师，老师能不能运行起来都难说。</p>
</blockquote>
<h3 id="不同于虚拟机"><a href="#不同于虚拟机" class="headerlink" title="不同于虚拟机"></a>不同于虚拟机</h3><blockquote>
<p>我们知道虚拟机非常的大，一个就论G之算，而Docker镜像，往往你所需要的非常精简，甚者是说这镜像完全是为你打造的，你是需要将相应的文件加入其中，二次打造，就非常完美了，可以说是非常OK了！</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>上次IBM讲座可以说是没怎么听，全程王者荣耀（坏笑）。对一些概念一知半解，比如说镜像和容器，仓库什么的。</p>
</blockquote>
<h4 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h4><blockquote>
<p>个人理解，<code>镜像是死的，容器是活的</code>。就类似于虚拟机一样，你安装时需要的便是镜像，当你运行起来时对其文件进行操作，那便成了你挥洒笔墨的容器。程序和进程也是类似。</p>
</blockquote>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><blockquote>
<p>Docker仓库分为本地仓库和远程仓库，这类似于任何仓库类型的工具，比如npm包，github也是类似。这个仓库就是镜像仓库，当你需要一个镜像时，比如说nginx,ubuntu,arch,centos,mysql等等其中之一时，你需要进行pull操作，他会先从你的本地仓库去找，突然发现没有，然后他就去远程仓库了，找到了你想要的镜像，然后就给你运来了。</p>
</blockquote>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><blockquote>
<p>docker有许多的命令。常见的就是这些</p>
</blockquote>
<ul>
<li>pull 要一个镜像，类似git命令</li>
<li>push 推送一个镜像，类似git</li>
<li>build 打造合成</li>
<li>run 运行</li>
<li>ps 显示正在运行的容器</li>
<li>images 显示本地有哪些镜像</li>
<li>stop 停止容器</li>
<li>rm 删除打造的镜像</li>
<li>rmi 删除仓库中的镜像</li>
</ul>
<blockquote>
<p>就记得这些了,当然这只是基础的一些，其他的类似。</p>
</blockquote>
<h3 id="Logo"><a href="#Logo" class="headerlink" title="Logo"></a>Logo</h3><blockquote>
<p>Docker的logo挺有意思的，一个小鲸鱼和一堆集装箱。docker的作用正如此logo，那些集装箱就是镜像，小鲸鱼就是docker端。当拿镜像时，你吩咐小鲸鱼去仓库运一个，它哧溜哧溜的先去本地仓库，我屮艸芔茻，没有，然后又呼哧呼哧的到远程仓库，然后哼登哼登的跑回来把他给你。你拿来这集装箱打开就用。没错，很六！</p>
</blockquote>
<h3 id="组合镜像"><a href="#组合镜像" class="headerlink" title="组合镜像"></a>组合镜像</h3><blockquote>
<p>用了一个工具，<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZS9pbnN0YWxsLw==" title="https://docs.docker.com/compose/install/">Docker Compose<i class="fa fa-external-link"></i></span>,我的本地博客就是用这玩意弄得，用到了nginx反向代理服务器，ghost博客镜像（npm包管理），还一个mysql镜像。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack打包优化指南</title>
    <url>/webpack-optimize.html</url>
    <content><![CDATA[<div class="note default">
            <p>Stay hungry. Stay foolish.</p>
          </div>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>web前端打包工具对于高效开发来说已是必不可少，但高效开发并不能保证用户体验好，我们经常为了减少http请求而将所有代码打包到一个js文件中，但这明显不科学。因为随着项目的扩展，js文件会越来越大，这会导致许多问题。这就需要我们来优化组织打包文件，对于webpack来说这也是很有必要的。</p>
</blockquote>
<h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><blockquote>
<p>今天意外地发现了一个神奇的工具，是一个将webpack打包后的文件关系可视化的工具，叫<strong>webpack-bundle-analyzer</strong>，这里是npm的工具<span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2VicGFjay1idW5kbGUtYW5hbHl6ZXI=" title="https://www.npmjs.com/package/webpack-bundle-analyzer">链接<i class="fa fa-external-link"></i></span>,其效果如下。</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/webpack-optimize/analyzer.png" alt></p>
<h3 id="优化第一步——第三方依赖分离"><a href="#优化第一步——第三方依赖分离" class="headerlink" title="优化第一步——第三方依赖分离"></a>优化第一步——第三方依赖分离</h3><blockquote>
<p>上图中很明显的看到只打包了一个js文件，app.js。它包含了第三方依赖代码和业务代码。每次http请求都会请求这个文件，而这个文件中常常有一些不变化的第三方依赖包。因为第三方依赖不想业务代码那样多变，所以我们就想能不能将业务代码和第三方依赖代码分离打包?然后第三方依赖缓存到客户端，这样就不必多次请求了。Bingo！我们只需要配置另一个入口文件，将第三方依赖配置上就OK了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ……</span><br><span class="line">    entry:&#123;</span><br><span class="line">        app:<span class="string">"./src/main.js"</span>,</span><br><span class="line">        vender:[<span class="string">"vue"</span>,<span class="string">"vue-router"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后打包后的结果是这样的。</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/webpack-optimize/optimize1.png" alt></p>
<blockquote>
<p>但是为毛打包的第三方依赖会重复？这不就相当于什么也没干而且还增加了负担？我们希望只有一份vue和vue-router然后让这两部分引用就行了。解决办法如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在webpack配置中添加优化公共块插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ……</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name:<span class="string">"vendor"</span></span><br><span class="line">            &#125;)</span><br><span class="line">    ]</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样就将公共的块抽取出来放到vendor中，结果如下：</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/webpack-optimize/optimize2.png" alt></p>
<blockquote>
<p>这样第三方依赖就提取出来了，然后右边的业务代码单独分到一个打包文件中。</p>
</blockquote>
<h3 id="优化第二步——自动提取"><a href="#优化第二步——自动提取" class="headerlink" title="优化第二步——自动提取"></a>优化第二步——自动提取</h3><blockquote>
<p>我们会遇到这种情况，尽管已经使用了vue、vue-router这些依赖，但随着项目的增大，需求的扩展，我们需要另外一些第三方依赖，但每次都需要想入口文件中添加依赖。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ……</span><br><span class="line">    entry:&#123;</span><br><span class="line">        app:<span class="string">"./src/main.js"</span>,</span><br><span class="line">        vender:[<span class="string">"vue"</span>,<span class="string">"vue-router"</span>,<span class="string">"vuex"</span>,<span class="string">"element-ui"</span>,<span class="string">"很多很多很多很多"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有成千上万个第三方依赖，你难道需要一个个手打上去，这显然是傻。我们有没有什么方法让webpack大佬自动提取这些第三方依赖到打包文件中？方法是有的，我们需要配置一个脚本，代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ……</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name:<span class="string">"vendor"</span>,</span><br><span class="line">            minChunk:<span class="function">(<span class="params">&#123;resource&#125;</span>)=&gt;</span>(</span><br><span class="line">                resource&amp;&amp;</span><br><span class="line">                resource.indexOf(<span class="string">"node_modules"</span>)&amp;&amp;</span><br><span class="line">                resource.match(<span class="regexp">/\.js$/</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码即判断打包模块是否是第三方依赖的js，若是则放到vendor里。效果同上：</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/webpack-optimize/optimize2.png" alt></p>
<h3 id="优化第三步——业务代码打包优化"><a href="#优化第三步——业务代码打包优化" class="headerlink" title="优化第三步——业务代码打包优化"></a>优化第三步——业务代码打包优化</h3><blockquote>
<p>可能你认为打包后的文件中第三方依赖大小比重占得多，所以业务代码打包不必优化。但这是错的，事实上恰恰相反，业务代码比重一般是最大的，所以需要对其进行分离组织优化。将一些模块懒加载，一些必要的首先加载,公共的代码需要提取。</p>
</blockquote>
<h4 id="如何懒加载"><a href="#如何懒加载" class="headerlink" title="如何懒加载"></a>如何懒加载</h4><blockquote>
<p>首先先谈一下为什么要懒加载。比如你有许多模块，首先展示的是主页，然后同路由下有其他模块，这些模块的脚本就需要懒加载，让主页代码优先加载。那么如何懒加载呢？这一点我也很好奇，使用了以下代码。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LazyModule = <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">"The Module"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如说我在这儿有个路由下的失物列表需要懒加载，就需要这样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GoodsList=<span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/GoodsList.vue'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打包结果如下：</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/webpack-optimize/optimize3.png" alt></p>
<blockquote>
<p>就将需要懒加载的模块单独打包了，<strong>0.chunk.js</strong></p>
</blockquote>
<blockquote>
<p>懒加载前后页面资源变化</p>
<ul>
<li>主页<br><img src="/images/loading.gif" data-original="/webpack-optimize/optimize4.png" alt></li>
<li>其他路由页<br><img src="/images/loading.gif" data-original="/webpack-optimize/optimize5.png" alt></li>
</ul>
</blockquote>
<h4 id="重复依赖提取"><a href="#重复依赖提取" class="headerlink" title="重复依赖提取"></a>重复依赖提取</h4><p><img src="/images/loading.gif" data-original="/webpack-optimize/optimize6.png" alt></p>
<blockquote>
<p>有时候我们会发现不同的页面用了相同第三方依赖，比如说<strong>axios</strong>（类似jQuery中的Ajax），我们需要将这些公共的依赖提取出来，这就需要再一次请教webpack大佬了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，这里的name必须和上面入口文件相同，以便提取</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name:<span class="string">"app"</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="string">"common-in-lazy"</span>,</span><br><span class="line">    minChunks:<span class="function">(<span class="params">&#123;resource&#125;</span>)=&gt;</span>(</span><br><span class="line">    resource&amp;&amp;</span><br><span class="line">    resource.indexOf(<span class="string">"node_modules"</span>)&gt;<span class="number">-1</span>&amp;&amp;</span><br><span class="line">    /axious/.test(resource)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样，公共的依赖代码就提取出来了，效果如下：</p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/webpack-optimize/optimize7.png" alt></p>
<blockquote>
<p>再一次感受到了webpack的强大之处，然后这个webpack-bundle-analyzer这个工具的有趣与强大。</p>
</blockquote>
<h3 id="Thanks！"><a href="#Thanks！" class="headerlink" title="Thanks！"></a>Thanks！</h3>]]></content>
      <categories>
        <category>Front-End Development</category>
      </categories>
      <tags>
        <tag>Front-End Development</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>web前端入门建议</title>
    <url>/web-study.html</url>
    <content><![CDATA[<div class="note default">
            <p>基础决定上层建筑。</p>
          </div>
<a id="more"></a>
<h3 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h3><blockquote>
<p>首先预祝学弟学妹们新年快乐！欢迎各位准备参与web前端的学习，没错，这篇文章适合于准备学习web前端但又不知道如何下手学习哪些知识的你们。</p>
</blockquote>
<h3 id="web前端是什么"><a href="#web前端是什么" class="headerlink" title="web前端是什么"></a>web前端是什么</h3><blockquote>
<p>首先你要了解前端是什么，“所见即为前端”，前端就是给用户看的。当你打开一个手机app，打开一个浏览器进入一个网页，或者打开一个游戏，你看到的便是前端。当然这些前端归根结底都是同样的架构，不过是不同的实现方式而已。<br></p>
</blockquote>
<blockquote>
<p>web前端就是你打开浏览器进入一个网页所看到的，比如你现在正在看的这篇博客，比如你打开的bilibili，斗鱼直播等等<br></p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/web-study/web前端.png" alt></p>
<blockquote>
<p>可能你会混淆web前端和ui设计这两个概念。web前端工程师是根据ui设计师设计的原型来编写代码形成网页的，当然也有一些人同时做这两个工作。</p>
</blockquote>
<h3 id="web前端需要学些什么"><a href="#web前端需要学些什么" class="headerlink" title="web前端需要学些什么"></a>web前端需要学些什么</h3><blockquote>
<p>web前端需要学些什么，看这张图就知道了，这便是咱们web前端的本命法宝，其他的不管是什么框架还是什么工具库，都离不开这三个家伙（所以你一上来不必马上研究框架，基础打牢一切都好说，而如果基础不打牢固框架的学习会相对比较吃力，孰轻孰重显而易见）。<br></p>
</blockquote>
<p><img src="/images/loading.gif" data-original="/web-study/web-study.jpg" alt="布局"></p>
<blockquote>
<p>你可以打开一个网页，<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW1vb2MuY29tL2NvdXJzZS9wcm9ncmFtZGV0YWlsL3BpZC8zMg==" title="https://www.imooc.com/course/programdetail/pid/32">Web前端工程师学习路径<i class="fa fa-external-link"></i></span>，<strong>这是一个神奇的网站，慕课网——程序员的梦工厂，你会从这里收获很多</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p>当你真正接触项目以后，你会发现这些软件项目（或者直接就拿web前端来说）和其他类项目（建筑行业，汽车行业）都有许多相同之处。<br><br> 就拿建筑行业盖房子为例吧，需要对房子的布局进行设计（哪儿是厨房，哪儿是客厅，占多大区域），然后对样式进行设计（墙漆刷什么颜色的，门要装什么样的），最后在设计一下细微的东西（窗帘是横着拉还是竖着拉，门是双侧门还是单侧门）。<br><br> 而web前端也类似，需要对各个模块布局进行设计（多大，位置在哪），然后样式设计（需要什么颜色，字体大小多少，需要什么背景图片），然后是脚本控制（点击按钮会触发什么事件，弹出窗口？跳转页面？发生动画？）<br><br><img src="/images/loading.gif" data-original="/web-study/布局.png" alt></p>
</blockquote>
<blockquote>
<p> 啰啰嗦嗦说这么多，这和大法宝HTML，CSS，Javascript有什么关系呢？先看看这三个东西的全称是什么。HTML（<strong>HyperText Markup Language，超级文本标记语言</strong>），CSS（<strong>Cascading Style Sheets，层叠样式表</strong>），Javascript（JavaScript一种<strong>直译式脚本语言</strong>，是一种动态类型、弱类型、基于原型的语言）。然后你应该差不多明白了，CSS是控制布局样式的，javascript是控制脚本的，然后HTML是控制结构的（哪个是按钮，哪个是文本框）。再直接一点，CSS是控制HTML结构的样式，Javascript是控制HTML的脚本。</p>
</blockquote>
<h3 id="讲一下我平时的开发流程"><a href="#讲一下我平时的开发流程" class="headerlink" title="讲一下我平时的开发流程"></a>讲一下我平时的开发流程</h3><ul>
<li>从美工那拿到原型图和切图（切图上标注的字体大小颜色等等）</li>
<li>根据切图进行界面代码的编写（包括布局样式事件等等）</li>
<li>对接接口（通过网络向后端请求资源，你先不必深入了解后端是干什么的，以后你就会慢慢清楚，你只需要知道你需要的数据时后端提供的。这里需要javascript控制ajax进行网络请求。）</li>
<li>测试修改</li>
</ul>
<h3 id="web前端的开发工具"><a href="#web前端的开发工具" class="headerlink" title="web前端的开发工具"></a>web前端的开发工具</h3><blockquote>
<p> 你可能认为txt就可以编写，但高效开发是必不可少的。人类之所以是高级动物是因为有更高级的大脑，能够使用合理的工具。在这里推荐几个编辑器：vs code（这是我现在在用的，开源的）、sublime text（虽然收费，但可破解，也很好用）、atom（有一些不可思议的插件，像打游戏一般敲代码combo）。<strong>合理使用这几个编辑器里的插件会大大提高开发效率！！！</strong></p>
</blockquote>
<ul>
<li>VS Code<br><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v" title="https://code.visualstudio.com/">官网<i class="fa fa-external-link"></i></span></li>
</ul>
<p><img src="/images/loading.gif" data-original="/web-study/edit.png" alt></p>
<ul>
<li>sublime text<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3VibGltZXRleHQuY29t" title="https://www.sublimetext.com">官网<i class="fa fa-external-link"></i></span></li>
</ul>
<p><img src="/images/loading.gif" data-original="/web-study/sublime.png" alt></p>
<ul>
<li>atom<br><span class="exturl" data-url="aHR0cHM6Ly9hdG9tLmlvLw==" title="https://atom.io/">官网<i class="fa fa-external-link"></i></span></li>
</ul>
<p><img src="/images/loading.gif" data-original="/web-study/atom.png" alt></p>
<h3 id="寒假祝福语"><a href="#寒假祝福语" class="headerlink" title="寒假祝福语"></a>寒假祝福语</h3><blockquote>
<p> 祝各位学弟学妹新年快乐！假期是赶英超美鹤立鸡群青出于蓝胜于蓝长江后浪推前浪的好时机，假期少不了娱乐游玩，也少不了学习，希望各位能够在寒假放松的同时好好学习，过一个充实的寒假，让这个寒假在你的人生路上变得有意义。最后再说一句，<strong>这个<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW1vb2MuY29tLw==" title="https://www.imooc.com/">网站<i class="fa fa-external-link"></i></span>对你很重要</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Front-End Development</category>
      </categories>
      <tags>
        <tag>Front-End Development</tag>
      </tags>
  </entry>
</search>
